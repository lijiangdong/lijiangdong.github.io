<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java类加载机制]]></title>
    <url>%2F2018%2F10%2F24%2F20181024_Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[综述在前面两篇文章主要分析了Java的内存以及Java的垃圾回收机制。在这篇文章中分析一下类是如何加载的。 类加载时机类从被加载到虚拟机内存开始，到卸载出内存为止。它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3阶段统称为连接（Linking）。 对于开始类加载过程的第一个阶段加载，Java虚拟机并没有强制约束，可以交给虚拟机自由把握。但是对于初始化阶段，虚拟机规范严格规定了有且只有5种情况必需立即对类进行“初始化”（而加载、验证、准备需要再这之前开始） 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先初始化。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一了类的静态字段（被final修饰、已在编译期把结果放到常量池的静态字段除外）的时候，以及调用一个类的静态方法。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先进行初始化。 注：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化的时，并不要求其父接口全部都完成了初始化，只有在真正使用到父类接口的时候（如引用父类定义的常量）才会初始化。 类加载过程加载类的加载阶段主要完成以下工作： 通过一个类的全限定名来获取定义此类的二进制流。 将这个字节流所代表的静态存储结构转化为方法区的运行时结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证验证是连接阶段的第一步，这一阶段为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成以下4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。而”初始值“通常情况下是数据类型的零值。在一些特殊情况下，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值。解析虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要是针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。初始化类的初始化阶段是类加载的最后一步，在前面的类加载过程中除了加载阶段是用户应用程序可以通过自定义类加载器参与之外，其余动作都是由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定的Java字节码。而初始化阶段就是执行类构造器 &lt; clinit &gt;()方法的过程。&lt; clinit &gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。&lt; clinit &gt;()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕。 类加载器类加载器分类对于任何一个类，都需要由加载他的类加载器和这个类的本身一同确定其在Java虚拟机中的唯一性，每一个了类加载器，都拥有一个独立的类名空间。也就是说比较两个类是否”相等“，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必不相等。 从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分;另一种就是所有其他的类加载器，这些类加载器都是由Java语言实现的，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader。 如果划分的更细致一点，，绝大部分Java程序都会使用到以下3种系统提供的类加载器。 启动类加载器（Bootstrap ClassLoader）： 由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。 扩展类加载器（Extension ClassLoader）： 负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。 应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 双亲委派模型双亲委派模型要求除了顶层的启动类加载器以外，其余的类加载器都应该有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合的关系来复用父加载器的代码。 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载。 这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。 双亲委派模型的代码实现ClassLoader中loadClass方法实现了双亲委派模型 1234567891011121314151617181920212223242526272829protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats &#125; &#125; return c;&#125; 从上面代码中可以看出，首先检查该类是否已经被加载过，如果没有被加载则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，在调用自己的findClass()方法进行加载。 总结首先在类的加载过程中成中需要经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）这7个阶段。在使用类加载器的过程成，采用的是双亲委托模型对类进行加载。 参考周志明的《深入理解Java虚拟机》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java垃圾回收机制]]></title>
    <url>%2F2018%2F10%2F19%2F20181019_Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[综述在上篇文章中我们分析了Java内存空间的划分和分配，在这篇文章中我们来了解一下Java对于不再使用的对象是如何回收的。 回收的内存区域在Java内存运行时，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。每一个栈中分配多少内存基本上是在类结构确定下来时就知道的。因此这几个区域的内存分配和回收都具有确定性，也就是说在这几个区域内不需要过多考虑回收问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而在Java堆和方法区不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的多个内存也不一样，只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收关注的u也是这部分内存。 对象死亡引用计数法给对象添加一个引用器，每当有一个地方应用它时，计数器加1;当引用失效时，计数器减1;任何时刻计数器为0的对象就是不可能在被使用的。但是最主要的缺点就是很难解决对象之间相互循环引用的问题。 可达性分析算法通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。 在Java中，可以作为GC Roots的对象包括一下几种： 虚拟机栈（栈帧中本地变量表）中引用的对象 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 引用引用分为4类，强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。这四种引用强度依次逐渐减弱。 强引用：在程序代码中普遍存在的，类似“Object obj = new Object()”。只要强引用还存在，来及收集器就不会回收掉被引用的对象。 软引用： 描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。通过SoftReference类来实现软引用。 弱引用：用来描述非必需对象，强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否充足，都会回收掉只被弱引用关联的对象。通过WeakReference类来实现弱引用。 虚引用：也称幽灵引用或者幻影引用。它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过一个虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 通过PhantomReference类来实现虚引用。 对象生存还是死亡即使在可达性分析算法中不可达的对象也并非是“非死不可”的，这时他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Root相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定有必要执行finalize()方法，那么对象将会放置一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不确定会等待他运行结束，原因是如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很有可能导致F-Queue队列中其他对象永久等待，设置导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己（只要重新与引用链上的任何一个对象建立关联），那么在第二次标记时他将被移除“即将回收”的集合;如果对象这个时候还没有逃脱，那基本上真的就要被回收了。也就是说一个对象的finalize()方法被执行，但是它仍然可以存活 任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会在被再次执行。 回收方法区很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾手机，而且在方法区中进行垃圾收集的“性价比”一般比较低。在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般可以回收70%～90%的空间，而永久代的垃圾收集效率远低于此。 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。而判断一个类是无用的类需要满足下面三个条件。 该类所有的实例已经被回收，也就是Java堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法标记-清除（Mark-Sweep）算法首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。他的不足指出主要有两个：一个是效率问题，标记和清除两个过程效率都不高。另一个是空间问题，标记清楚之后会产生大量不连续的内存碎片，内存碎片太多可能会导致以后程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前出发一次垃圾收集。 复制算法将可用内存按容量划分为大小相等两块，每次只使用其中的一块。当这一块的内存用完，就将还存活的对象复制到另外一块上面，然后把以使用过的内存空间一次清理掉。这样每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配即可。 现在商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%是“朝生夕死”的，所以并不是按照1：1的比例来划分内村空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1,也就是每次新生代中可用内存空间为整个新生代的90%，只有10%的内存会被浪费。当然，98%的对象可回收只是一般场景下的数据，不能够保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 如果另外一块Survivor空间没有足够空间存放当上一次新生代收集下来存活对象时，这些对象将直接通过分配担保机制进入老年代。 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键如果不想浪费50%的空间，就需要有额外的空间进行分配担保，来应对被使用内存中所有对象都100%存货的极端情况。所以在老年代一般不能直接采用复制收集算法 标记-整理（Mark-Compact）算法在老年代一般采用该算法。标记过程与“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有可存活的对象都向一端移动，然后直接清理掉边缘以外的内存。 分代收集算法当前商业模式虚拟机都采用“分代收集”算法。一般是将Java内存分为新生代和老年代。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存货对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。 空间分配担保在发生在Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有的对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次GC是有风险的;如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次Full GC。 总结在Java对象中，我们不应该在去复写finalize()方法，来做一些逻辑或者释放的操作。我们应该避免去使用finalize()方法。而对于Java的垃圾回收算法。在新生代往往采用复制算法，而对于老年代往往采用“标记-清理”或者“标记-整理”算法。 参考周志明的《深入理解Java虚拟机》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存划分和分配]]></title>
    <url>%2F2018%2F10%2F18%2F20181018_Java%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E5%92%8C%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[综述在这边文章中我们将了解一下Java的内存区域是怎么划分的以及每个区域的功能。在了解Java每个内存区域的功能之后，进一步分析Java对象如何的创建和对象的内存分配，以及如何访问对象中的内存。最后学习一下Java堆内存的分代划分和内存分配。 Java内存区域划分首先通过一张图来看一下Java虚拟机是如何划分内存空间的。 程序计数器：是一块较小内存，可以看作是当前线程所执行的字节码的行号指示器。每条线程都需要有一个独立的程序计数器，各个线程之间计数器互不影响。 Java虚拟机栈：Java虚拟机栈也是线程私有，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量、操作数、操作数栈、动态链接、方法出口等信息。每一个方法的调用过程直至执行完成的过成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;如果虚拟机可以动态扩展，如扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。 本地方法栈：与虚拟机栈类似，他们之间的区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 Java堆：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在此内存区域中唯一目的就是存放对象实例，几乎所有的对象都在这里分配内存。 Java堆是垃圾收集器管理的主要区域。也叫“GC堆”。从内存回收的角度来看，由于现在的收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代;在细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的家读来看，线程共享的Java堆中可能划分出多个线程私有分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论那个区域，存储的都是对象实例，进一步划分的目的是为了更好地回收内存，或者更快的分配内存。Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。 方法区（Method Area）：和Java堆一样也是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。使用永久代实现方法区。 对象的创建对象内存的分配虚拟机遇到一条new指令时，先去检查这个指令的参数是否能在常量池中定位到一个类的符号的引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。如果没有，那必须先执行相应的类的加载过程。在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需要的内存在类加载完成之后便可完全确定。 指针碰撞：假设Java堆是绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放一个指针作为分界点的指示器。为对象分配内存时把那个指针向空闲空间那边挪动一段与对象大小相等的距离。 空闲列表：Java堆中的内存不是规整的，以使用的内存和空闲的内存相互交错，无法使用指针碰撞。这时虚拟机就必须维护一个列表，记录上哪些内存是可用的，在分配内存的时候从列表中找一块足够大的空间划分给对象实例，并更新列表上的记录。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 如果只是修改一个指针所指向的位置，在并发情况下并不是线程安全，可能出现正在给对象A分配内存，指针还没来的及修改，对象B又同时使用了原来的指针来分配内存的情况。两种解决方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性;另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。那个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。 对象的内存布局对象在内存存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息,第一部分用于存储对象自身的运行时数据,如哈希码(HashCode),GC分代年龄,锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳等.这部分数据在长度32位和64位的虚拟机(未开启压缩指针)中分别为32bit和64bit,官方称它为”Mark Word”.考虑到虚拟机的空间效率,Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息,他会根据对象的状态复用自己的存储空间,对象头的另一部分是类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例.并不是所有的虚拟机实现都必须在对象数据上保留类型指针.另外,如果对象是一个Java数组,那么在对象头中还必须有一块用于记录数组长度的数据,因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小. 实例数据部分是对象真正存储的有效信息,也是在程序代码中多定义的各种类型字段内容.无论是从父类继承下来的,还是在子类定义的,都需要记录起来. 对其填充不是必然存在的,只是起着占位符的作用.由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍,也就是说对象大小必须是8字节的证书倍.对象头部分正好是8字节的倍数(1倍或者2倍),因此当实例数据部分没有对齐时,就需要通过对齐填充来补全. 对象访问定位目前主流的访问方式有使用句柄和直接指针两种。 句柄访问：Java堆将会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。 直接指针访问：Java堆对象的布局中就须考虑如何放置访问类型数据相关信息，而reference中存储的就是对象地址。 使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问的最大好处就是速度更快，他节省了一次指针定位时间的开销。HotSpot采用的是直接指针进行对象访问的。 Java内存分配Java堆内存可以分为新生代和老年代。在新生代中可以分为一块较大的Eden空间和两块较小的Survivor空间，HotSpot虚拟机默认Eden和Survivor的大小比例是8：1。 对象的内存分配，一般来说，就是在堆上分配（也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配规则并不是固定的。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。新生代GC（Minor GC）：是指发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度比较快。老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（并非绝对）。Major GC的速度一般会比 Minor GC 慢10倍以上。 大对象直接进入老年代大对象对虚拟机内存分配来说是一个坏消息（写程序应该避免写出一群“朝生夕死”的“短命大对象”），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。 长期存活的对象将进入老年代如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将会被移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁）的时候就会被晋升到老年代当中。对象晋升老年代年龄的阀至可以通过参数-XX:MaxTenuringThreshold设置。 为了更好的适应内存的不同状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。 总结Java内存可以分为程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区这几个部分。其中程序计数器、Java虚拟机栈、本地方法栈属于线程私有，而Java堆和方法区属于线程共享区域。对于Java的堆内存可以划分为新生代和老年代。在新生代中划分为一个Eden区和两个Survivor区。创建一个Java对象时，会通过指针碰撞或空闲列表法为对象分配内存。而当我们访问一个对象的时候可以通过句柄或者直接地址的方式进行对象的访问。 参考周志明的《深入理解Java虚拟机》]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Kotlin优雅的添加Fragment]]></title>
    <url>%2F2018%2F03%2F24%2F20180324_kotlin%E6%B7%BB%E5%8A%A0Fragment%2F</url>
    <content type="text"><![CDATA[综述在上面文章聊一聊Kotlin扩展函数run,with,let,also和apply的使用和区别中讲解Kotlin的几个扩展函数的使用和区别。那么在这篇文章中去自己定义一些扩展函数来更加优雅的去将添加Fragment到Activity中。 回顾Fragment使用在使用Kotlin之前，首先回顾一下在Java中是如何添加一个Fragment到Activity当中的。1234FragmentManager manager = getSupportFragmentManager();FragmentTransaction transaction = manager.beginTransaction();transaction.add(frameId, fragment);transaction.commit(); 上面这段代码是在熟悉不过了，在项目中为了避免大量的重复书写上面那段代码，通常会创建一个ActivityUtil的类，在这个类中写一个static方法来封装上面那段代码。1234567public static void addFragmentToActivity(FragmentManager manager, Fragment fragment, int frameId) &#123; FragmentTransaction transaction = manager.beginTransaction(); transaction.add(frameId, fragment); transaction.commit(); &#125; 这时候在Activity当中便能够直接使用上面的方法： 12ActivityUtil.addFragmentToActivity( getSupportFragmentManager(), fragment, R.id.frag_container); 在介绍完使用Java来添加Fragment后，下面就来看一下如何使用Kotlin更优雅的来添加Fragment。 Kotlin添加Fragment使用Kotlin完成Fragment的天假只需要两步即可： 消除beginTransaction() and commit()方法对于Fragment的操作每次都需要beginTransaction()和commit()，如果在开发中少写了一个commit()方法，或许会花费大量时间进行调试找到问题所在。所以省去beginTransaction()和commit()代码的书写还是很有必要的。 在Kotlin中，可以为FragmentManager类写一个扩展函数，将一个带有接收者函数的lambda作为扩展函数的参数。下面简单介绍一下相关知识点： 扩展函数(Extension functions)扩展函数能够向已经存在的类中添加新的函数或属性，也包含第三方库或者SDK中的类。在函数内部，可以不使用任何限定符来访问类的公共函数和属性，就像这个函数在类的内部一样。 高阶函数(Higher-Order Functions)高阶函数是将函数作为参数，或返回一个函数的函数。可以传递函数或者从函数中返回一个函数。 带接收者的Lambda函数（Function Literals with Receiver）可以说是以上两个的组合，一个高阶函数将一个扩展函数作为它的参数。将lambda表达式中作为参数传递，并且我们可以访问接收者的函数和属性，就好像lambda函数在接收者对象的内部一样。 现在书写一个FragmentManager的扩展函数，它将一个带有接受者的Lambda函数作为传入的参数，而这个FragmentTransaction就是接收者对象。 12345inline fun FragmentManager.inTransaction(func: FragmentTransaction.() -&gt; Unit) &#123; val fragmentTransaction = beginTransaction() fragmentTransaction.func() fragmentTransaction.commit()&#125; 上面这段代码是一个扩展函数，他接收的参数是一个带有接收者的Lambda函数。这个Lambda函数没有任何参数并且返回的是Unit。在这个inTransaction扩展函数体内首先调用beginTransaction()获取FragmentTransaction对象，然后在执行Lambda函数之后执行commit()方法。 那么就可以通过一下代码将我们的Fragment添加到Activity当中： 123supportFragmentManager.inTransaction &#123; add(R.id.frameLayoutContent, fragment)&#125; 在这里可以看出来在Lambda函数当中可以直接操作FragmentTransaction中的方法，并且没有任何的使用限制。因为这个Lambda函数本身就是FragmentTransaction的一个扩展函数。 在使用上面的扩展函数当中不需要每次再执行beginTransaction()和commit()方法。甚至我们还能够在inTransaction方法中执行多次操作。 1234supportFragmentManager.inTransaction &#123; remove(fragmentA) add(R.id.frameLayoutContent, fragmentB)&#125; 现在再次对inTransaction函数进行一次升级，可以将传入的Lambda函数添加一个返回值，返回FragmentTransaction对象。这样会使得我们的代码更加简洁。 123inline fun FragmentManager.inTransaction(func: FragmentTransaction.() -&gt; FragmentTransaction) &#123; beginTransaction().func().commit()&#125; 使用扩展函数来替代ActivityUtil现在就可以使用上面的inTransaction方法来写一些FragmentActivity的扩展函数来取代Java中的ActivityUtil类。那么就以对Fragment的add和replace操作为例写两个FragmentActivity的扩展函数addFragment和replaceFragment。 12345678fun FragmentActivity.addFragment(fragment: Fragment, frameId: Int)&#123; supportFragmentManager.inTransaction &#123; add(frameId, fragment) &#125;&#125;fun FragmentActivity.replaceFragment(fragment: Fragment, frameId: Int) &#123; supportFragmentManager.inTransaction&#123;replace(frameId, fragment)&#125;&#125; 由于这些扩展函数是FragmentActivity的扩展函数。所以在这些扩展函数内部就能够直接访问到FragmentActivity中的supportFragmentManager。 使用上面的扩展函数，就可以通过一行代码在Activity中添加Fragment。123addFragment(fragment, R.id.fragment_container)replaceFragment(fragment, R.id.fragment_container) 总结通过上篇文章了解了Kotlin一些扩展函数。而在这篇文章中去通过对Fragment添加去了解扩展函数的意义以及对高阶函数的使用。当然通过扩展函数也能够更佳的完善一些SDK中一些不合理的API。还能够写出更漂亮简洁的代码。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊Kotlin扩展函数run,with,let,also和apply的使用和区别]]></title>
    <url>%2F2018%2F03%2F16%2F20180316_%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[综述和Java相比，在Kotlin中提供了不少新的特性。这次我们就来聊一聊Kotlin的一些通用的扩展函数run,with,let,also和apply。对于这五个扩展函数它们都存在于Kotlin的源码标准库当中，也就是在Standard.kt文件当中。它们都是适用于任何对象的通用扩展函数。但是对于run,with,let,also和apply这五个函数他们的用法及其相似，以至于我们无法确定去选择使用哪一个。那么现在我们就来聊一下这五个函数它们的使用方法，它们的不同之处以及在什么场景下去使用。 作用域函数在这里我们重点是看一下run,with,T.run,T.let,T.also,和T.apply，对于这几个函数来说它们最重要的功能之一是在调用函数的内部又提供了一个作用域。 那么下面就通过一段代码来看一下run函数的作用域，对于其它函数来说当然也是类似。 12345678fun test()&#123; var animal = "cat" run &#123; val animal = "dog" println(animal) // dog &#125; println(animal) //cat&#125; 在这个简单的test函数当中我们拥有一个单独的作用域，在run函数中能够重新定义一个animal变量，并且它的作用域只存在于run函数当中。 目前对于这个run函数看起来貌似没有什么用处，但是在run函数当中它不仅仅只是一个作用域，他还有一个返回值。他会返回在这个作用域当中的最后一个对象。 例如现在有这么一个场景，用户领取app的奖励，如果用户没有登录弹出登录dialog，如果已经登录则弹出领取奖励的dialog。我们可以使用以下代码来处理这个逻辑。 123run &#123; if (islogin) loginDialog else getAwardDialog&#125;.show() 可以看到上面这段代码会变得更加的简洁，并且可以将show方法一次应用到上面两个dialog当中，而不是去调用两次。 with和其它通用扩展函数在这里之所以将with函数单独拿出来进行说明，是因为with得用法和其它通用的扩展函数的用法比较独特。在这里我们依然使用run函数来进行对比。对于下面这段代码做的是同样一件事。它们的不同之处就是一个使用了with(T)函数，而另一个则是使用了T.run函数。 123456789with(webView.settings)&#123; javaScriptEnabled = true databaseEnabled = true&#125;webView.settings.run &#123; javaScriptEnabled = true databaseEnabled = true&#125; 但是我们觉得使用哪一个会更好呢？现在假设一种场景，那就是webView.settings可能为null。那我们就来再次看一下下面这段代码. 123456789with(webView.settings)&#123; javaScriptEnabled = true databaseEnabled = true&#125;webView.settings?.run &#123; javaScriptEnabled = true databaseEnabled = true&#125; 这么以来就很明显了，当然是T.run方法会更好，因为我们可以在使用这些函数之前可以进行对null的检查。 对于with也是存在一个返回值，它也是会返回在这个作用域当中的最后一个对象。 作用域中接收者this和it在这几个扩展函数当中，它们都能直接获取到调用的对象或者是with中传入参数的对象。在这五个扩展函数在它们的作用域中的接收者可以是this或者是it。那么我们来对比一下T.run和T.let函数。这两个函数也是十分的相似。 1234567stringVariable?.run &#123; println("字符串的长度为$length")&#125;stringVariable?.let &#123; println("字符串的长度为 $&#123;it.length&#125;")&#125; 在这两段代码中可以清晰的看到。在T.run函数中通过this来获取stringVariable对象，而在T.let函数中通过it来取出stringVariable对象。当然我们也能够为it重新命名。如果我们不想覆盖外部作用域的this，这时候去使用T.let会更加的方便。至于哪些函数的接收者是this，哪些函数的接收者是it，在后面会通过一张树状图清晰的体现出来。 在作用域中返回值的类型在这些作用域中它们都会存在一个返回值。在上面的讲述的run,with,T.run,T.let中它们返回的都是作用域中最后一个对象。当然它们所返回的值是允许和接受者it或者this对象的类型不同。但是并不是所有的扩展函数都是返回作用域的最后一个对象。例如T.also函数。 12345678910111213141516171819202122val original = "abc"original.let &#123; println("The original String is $it") // "abc" it.reversed() &#125;.let &#123; println("The reverse String is $it") // "cba" it.length &#125;.let &#123; println("The length of the String is $it") // 3&#125;original.also &#123; println("The original String is $it") // "abc" it.reversed() &#125;.also &#123; println("The reverse String is $&#123;it&#125;") // "abc" it.length &#125;.also &#123; println("The length of the String is $&#123;it&#125;") // "abc"&#125; 从上面两段代码可以看出T.let和T.also的返回值使不同的。T.let返回的是作用域中的最后一个对象，它的值和类型都可以改变。但是T.also不管调用多少次返回的都是原来的original对象。 对于T.let和T.also都能够进行链式操作，那么我们现在结合一下T.let和T.also的链式调用来看一下在实际场景中的应用。 123456789//原始函数fun makeDir(path: String): File &#123; val result = File(path) result.mkdirs() return result&#125;//通过let和also的链式调用改进后的函数fun makeDir(path: String) = path.let&#123; File(it) &#125;.also&#123; it.mkdirs() &#125; 扩展函数的特性到目前为止除了T.apply没有使用到以外，根据上面的用法我们可以总结出来这些扩展函数的三大特性。 它们都有自己的作用域 它们作用域中的接收者是this或者it 它们都有一个返回值，返回最后一个对象(this)或者调用者自身(itself) 由此可想到对于T.apply无非也就是这三个特性。对于T.apply它作用域中的接收者是this，并且返回的调用者T。因此，T.apply的其中一个使用场景可以用来创建一个Fragment，代码如下所示： 1234567891011// 使用普通的方法创建一个Fragmentfun createInstance(args: Bundle) : MyFragment &#123; val fragment = MyFragment() fragment.arguments = args return fragment&#125;// 通过apply来改善原有的方法创建一个Fragmentfun createInstance(args: Bundle) = MyFragment().apply &#123; arguments = args &#125; 我们也能够通过T.apply的链式调用创建一个Intent：123456789101112// 普通创建Intent方法fun createIntent(intentData: String, intentAction: String): Intent &#123; val intent = Intent() intent.action = intentAction intent.data=Uri.parse(intentData) return intent&#125;// 通过apply函数的链式调用创建Intentfun createIntent(intentData: String, intentAction: String) = Intent().apply &#123; action = intentAction &#125; .apply &#123; data = Uri.parse(intentData) &#125; 如何选择使用在这里我们通过一个树状图来看一下对着五个扩展函数的区别，使用以及如何选取扩展函数（图片来源于参考文献当中） 总结在这里做一下总结，我们可以看出在这五个扩展函数当中它们的特性也是十分的简单，无非也就是接收者和返回值的不同。对于with,T.run,T.apply接收者是this，而T.let和T.also接受者是it；对于with,T.run,T.let返回值是作用域的最后一个对象（this）,而T.apply和T.also返回值是调用者本身(itself)。 参考文献（需要科学上网） https://android.jlelse.eu/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android稳定性测试工具Monkey的使用]]></title>
    <url>%2F2017%2F01%2F15%2F20170115_Monkey%2F</url>
    <content type="text"><![CDATA[综述 Monkey是一个命令行工具，它可以运行在我们的模拟器或者设备当中。它可以发送一些伪随机（pseudo-random）的用户事件流，例如点击，触摸，手势等。我们能够使用Monkey工具来对我们所开发的应用进行压力测试。Monkey测试是一种为了测试软件的稳定性，健壮性的快速有效的方法。 Monkey程序介绍 Monkey是Android自带的系统工具，是由java语言编写。他在Android文件系统存放的路径是：/system/framework/monkey.jar启动moneky.jar的shell脚本文件在Android文件系统存放的路径为：/system/bin/monkey。打开这个monkey文件我们可以看一下这个脚本文件很简单。 1234567# Script to start "monkey" on the device, which has a very rudimentary# shell.#base=/systemexport CLASSPATH=$base/framework/monkey.jartrap "" HUPexec app_process $base/bin com.android.commands.monkey.Monkey $* 我们可以看到他调用的是com.android.commands.monkey.Monkey包。 Monkey常用命令 下面我们就来执行这个monkey脚本。我们执行如下命令。1adb shell monkey 这时候，monkey将以无反馈模式进行启动，并把事件任意发送到安装在目标环境下中的全部包。运行结果如下所示。 1234567891011121314151617181920212223242526LiJiangdongdeMacBook-Pro:~ lijiangdong$ adb shell monkeyusage: monkey [-p ALLOWED_PACKAGE [-p ALLOWED_PACKAGE] ...] [-c MAIN_CATEGORY [-c MAIN_CATEGORY] ...] [--ignore-crashes] [--ignore-timeouts] [--ignore-security-exceptions] [--monitor-native-crashes] [--ignore-native-crashes] [--kill-process-after-error] [--hprof] [--pct-touch PERCENT] [--pct-motion PERCENT] [--pct-trackball PERCENT] [--pct-syskeys PERCENT] [--pct-nav PERCENT] [--pct-majornav PERCENT] [--pct-appswitch PERCENT] [--pct-flip PERCENT] [--pct-anyevent PERCENT] [--pct-pinchzoom PERCENT] [--pkg-blacklist-file PACKAGE_BLACKLIST_FILE] [--pkg-whitelist-file PACKAGE_WHITELIST_FILE] [--wait-dbg] [--dbg-no-events] [--setup scriptfile] [-f scriptfile [-f scriptfile] ...] [--port port] [-s SEED] [-v [-v] ...] [--throttle MILLISEC] [--randomize-throttle] [--profile-wait MILLISEC] [--device-sleep-time MILLISEC] [--randomize-script] [--script-log] [--bugreport] [--periodic-bugreport] COUNT 这时候可以看到monkey并没有运行起来，只是显示了usage，这是因为少了一个重要的参数，这是指发送的事件数。如果我们需要发送500个随机事件，执行如下命令。 1adb shell monkey 500 这时候我们可以看到手机已经疯狂的运行起来了。moneky的基本语法为 1$ adb shell monkey [options] &lt;event-count&gt; monkey的option操作都是根据具体需求设定的，主要分为常规类，事件类，约束类和调试类。下面就对这些命令进行说明。 Category Option Description 常规类 –help 显示moneky参数帮助信息usage -v 打印日志信息，每个-v将增加反馈信息的级别。-v越多日志信息就会越详细，不过目前最多支持三个-v。Level0：一个-v，除启动提示、测试完成和最终结果之外，提供较少信息。Level1：两个-v，提供较为详细的测试信息，如逐个发送到Activity的事件。Level2：三个-v，提供更加详细的设置信息，如测试中被选中的或未被选中的Activity。 事件类 -s &lt;seed&gt; 伪随机数生成器的seed值。如果用相同的seed值再次运行 Monkey，它将生成相同的事件序列。 –throttle &lt;milliseconds&gt; 后面接时间，单位为毫秒，表示事件之间的固定延时（即执行每一个指令的间隔时间），若不接这个选项，monkey则不会延时 –pct-touch &lt;percent&gt; 后面接触摸事件的百分比。(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置) –pct-motion &lt;percent&gt; 后面接动作事件的百分比。(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)。 –pct-trackball &lt;percent&gt; 后面接轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)。 –pct-nav &lt;percent&gt; 后面接“基本”导航事件百分比(导航事件主要来自方向输入设备的上，下，左，右事件) –pct-majornav &lt;percent&gt; 后面接“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键) –pct-syskeys &lt;percent&gt; 后面接“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、StartCall、End Call及音量控制键)。 –pct-appswitch &lt;percent&gt; 后面接启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。 –pct-anyevent &lt;percent&gt; 调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。 约束类 -p &lt;allowed-package-name&gt; 如果用此参数指定了一个或几个包，Monkey将只允许系统启动这些包里的Activity。如果你的应用程序还需要访问其它包里的Activity(如选择取一个联系人)，那些包也需要在此同时指定。如果不指定任何包，Monkey将允许系统启动全部包里的Activity。要指定多个包，需要使用多个-p选项，每个-p选项只能用于一个包。 -c &lt;main-category&gt; 如果用此参数指定了一个或几个类别，Monkey将只允许系统启动被这些类别中的某个类别列出的Activity。如果不指定任何类别，Monkey将选择下列类别中列出的Activity：Intent.CATEGORY_LAUNCHER或Intent.CATEGORY_MONKEY。要指定多个类别，需要使用多个-c选项，每个-c选项只能用于一个类别。 调试类 –dbg-no-events 设置此选项，Monkey将执行初始启动，进入到一个测试Activity，然后不会再进一步生成事件。为了得到最佳结果，把它与-v、一个或几个包约束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换。 –hprof 设置此选项，将在Monkey事件序列之前和之后立即生成profiling报告。这将会在data/misc中生成大文件(~5Mb)，所以要小心使用它。 –ignore-crashes 通常，当应用程序崩溃或发生任何失控异常时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 –ignore-timeouts 通常，当应用程序发生任何超时错误(如“ApplicationNot Responding”对话框)时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 –ignore-security-exceptions 通常，当应用程序发生许可错误(如启动一个需要某些许可的Activity)时，Monkey将停止运行。如果设置了此选项，Monkey将继续向系统发送事件，直到计数完成。 –kill-process-after-error 通常，当Monkey由于一个错误而停止时，出错的应用程序将继续处于运行状态。当设置了此选项时，将会通知系统停止发生错误的进程。注意，正常的(成功的)结束，并没有停止启动的进程，设备只是在结束事件之后，简单地保持在最后的状态。 –monitor-native-crashes 监视并报告Android系统中本地代码的崩溃事件。如果设置了–kill-process-after-error，系统将停止运行。 –wait-dbg 停止执行中的Monkey，直到有调试器和它相连接。 一条常用的Monkey命令1adb shell monkey -v -v -v -p [PackageName] --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes --throttle 1000 100000 &gt; monkey.txt 执行这条命令后会在当前文件夹下面生成一个名为monkey.txt的日志文件，我们可以通过搜索exception和ANR来找到monkey测试中所出现的Crash和ANR。 停止Monkey 对于正在运行的monkey应用。如果我们想要停止monkey测试可以如下命令。 12345678$ adb shellshell@lte26007:/ $ top | grep monkey26194 0 0% S 10 461848K 23012K shell com.android.commands.monkey26194 0 0% S 10 461848K 23012K shell com.android.commands.monkey26194 0 0% S 10 461848K 23012K shell com.android.commands.monkey$ kill -9 26194 $ kill -9 26194 在这里是通过杀死正在运行的monkey的进程来终止monkey的测试。 如何编写Monkey脚本 我们了解了一些Monkey的基本命令以后，但这通过这些命令运行Monkey测试所有的事件都是随机的，只会在手机屏幕进行随机点击。那么我们如何使用monkey做到自动填写，选择，提交呢？在这就来看一下如何编一个Monkey脚本。 常用Monkey Api介绍1.启动应用1LaunchActivity(String pkg_name, String cl_name) 启动应用的Activity。参数为包名和启动的Activity。2.轨迹球事件1DispatchTrackball(long downTime, long eventTime, int action, float x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int device, int edgeFlags) 这里参数很多，只需要关注action,x,y.对于参数action值为0代表按下（KeyDown）,1代表弹起（KeyUp）。如果使用这个方法实现点击事件，这个方法就应该成对出现，先传入0，然后在传入1。对于x，y就是定位的坐标点。下面列出其中参数含义。 long downTime:键最初被按下时间 long eventTime:事件发生时间 int action:动作ACTION_DOWN=0,ACTION_UP=1,ACTION_MULTIPLE=2 float x:x坐标 float y:y坐标 float pressure:当前事件的压力，值为0～1 float size:触摸的近似值，范围为0～1 int metaState:当前按下的meta键的标识 float xPrecision:x坐标精确值 float yPrecision:y坐标精确值 int device:事件来源，范围0～x，0表示不来自物理设备 int edgeFlags:坐标是否超出了屏幕范围 3.输入字符串事件1DispatchString(String text) 输入一个不加引号的字符串4.点击事件12DispatchPointer(long downTime, long eventTime, int action, loat x, float y, float pressure, float size, int metaState, float xPrecision, float yPrecision, int device, int edgeFlags)与轨迹球事件类似 5.等待事件1UserWait(long sleeptime) 6.按下事件1DispatchPress(int keyCode) 7.单击事件1Tap(int x,int y) 8.长按事件1LongPress() 9.发送键值1DispatchKey(long downTime, long eventTime, int action, int code, int repeat, int metaState, int device, int scancode) 10.开关软键盘1DispatchFlip(boolean keyboardOpen) 编写Monkey脚本 在写Monkey脚本之前首先看一下怎么获取包名和应用名，已经怎么怎么获取点击坐标。 获取包名和应用名1.查看包名12$ adb shell# ls data/data 2.查看应用（主界面）名12$ adb shell# logcat | grep START 以QQ为例看一下输出结果12345678LiJiangdongdeMacBook-Pro:~ lijiangdong$ adb shellshell@lte26007:/ $ suroot@lte26007:/ # logcat | grep STARTI/libmc ( 9161): received event[index:0,mask:0x80,name:SYSTEM_RESTART@1487131192515.txt]D/MSF.C.NetConnInfoCenter(18238): receive broadcast Intent &#123; act=android.intent.action.MEDIA_SCANNER_STARTED dat=file:///system/media flg=0x10 cmp=com.tencent.mobileqq/.msf.core.NetConnInfoCenter &#125;D/MSF.C.NetConnInfoCenter(18238): receive broadcast Intent &#123; act=android.intent.action.MEDIA_SCANNER_STARTED dat=file:///storage/emulated/0 flg=0x10 cmp=com.tencent.mobileqq/.msf.core.NetConnInfoCenter &#125;D/AndroidRuntime(19635): &gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START com.android.internal.os.RuntimeInit &lt;&lt;&lt;&lt;&lt;&lt;I/ActivityManager(17556): START u0 &#123;act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.tencent.mobileqq/.activity.SplashActivity bnds=[34,466][170,602]&#125; from pid 17844 从cmp=com.tencent.mobileqq/.activity.SplashActivity这句话可以看出QQ应用的主界面名为SplashActivity。 获取点击坐标1$ adb shell getevent 之后我们手指在屏幕上操作就可以看到输出的事件信息。下面看一下输入信息。123456789/dev/input/event1: 0003 0039 00003809/dev/input/event1: 0003 0035 00000172/dev/input/event1: 0003 0036 000002aa/dev/input/event1: 0001 014a 00000001/dev/input/event1: 0000 0000 00000000/dev/input/event1: 0003 0039 ffffffff/dev/input/event1: 0001 014a 00000000/dev/input/event1: 0000 0000 00000000 (DeviceName) (Type)(Code)(Value) 当Code出现0030和0032时，表示有触屏事件发生，而0035和0036出现时则代表实际触屏时的绝对坐标x，y。比如这里点172和2aa，这个是16进制，对应10进制为370和682。 Monkey脚本 上面api明白以后Monkey脚本的编写就很简单了，下面就以QQ为列变了一段monkey脚本。对于头文件是必须的。Monkey脚本是没有文件格式限制的。 12345678910111213141516#头文件信息 type=raw events count=10 speed=1.0 start data &gt;&gt; #具体的脚本内容 LaunchActivity(com.tencent.mobileqq,com.tencent.mobileqq.activity.SplashActivity) UserWait(1000) DispatchPointer(10,10,0,165,189,1,1,-1,1,1,0,0)DispatchPointer(10,10,1,165,189,1,1,-1,1,1,0,0)UserWait(1000) DispatchString(1234567) DispatchFlip(false) UserWait(5000)Tap(359,257) 上面这段脚本执行的命令是：启动QQ-&gt;点击搜索-&gt;输入1234567-&gt;点击QQ号为1234567的人。下面就来看一下如何执行这段脚本代码。 12$ adb push monkey_test /mnt/sdcard/$ adb shell monkey -f /mnt/sdcard/monkey_test 1 总结 在这里介绍了Monkey的使用，对于我们的应用通过monkey进行压力测试，也能够发现众多的ANR以及Crash。对于Monkey也有一定缺点的，它是不支持截屏，录制回放等操作的。 附录Monkey源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android官方MVP架构解读]]></title>
    <url>%2F2016%2F05%2F22%2F20160522_Android%E5%AE%98%E6%96%B9MVP%E6%9E%B6%E6%9E%84%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[对于MVP (Model View Presenter)架构是从著名的MVC(Model View Controller)架构演变而来的。而对于Android应用的开发中本身可视为一种MVC架构。通常在开发中将XML文件视为MVC中的View角色，而将Activity则视为MVC中的Controller角色。不过更多情况下在实际应用开发中Activity不能够完全充当Controller，而是Controller和View的合体。于是Activity既要负责视图的显示，又要负责对业务逻辑的处理。这样在Activity中代码达到上千行，甚至几千行都不足为其，同时这样的Activity也显得臃肿不堪。所以对于MVC架构并不很合适运用于Android的开发中。下面就来介绍一下MVP架构以及看一下google官方给出的MVP架构示例。 MVP架构简介 对于一个应用而言我们需要对它抽象出各个层面，而在MVP架构中它将UI界面和数据进行隔离，所以我们的应用也就分为三个层次。 View: 对于View层也是视图层，在View层中只负责对数据的展示，提供友好的界面与用户进行交互。在Android开发中通常将Activity或者Fragment作为View层。 Model: 对于Model层也是数据层。它区别于MVC架构中的Model，在这里不仅仅只是数据模型。在MVP架构中Model它负责对数据的存取操作，例如对数据库的读写，网络的数据的请求等。 Presenter:对于Presenter层他是连接View层与Model层的桥梁并对业务逻辑进行处理。在MVP架构中Model与View无法直接进行交互。所以在Presenter层它会从Model层获得所需要的数据，进行一些适当的处理后交由View层进行显示。这样通过Presenter将View与Model进行隔离，使得View和Model之间不存在耦合，同时也将业务逻辑从View中抽离。 下面通过MVP结构图来看一下MVP中各个层次之间的关系。 在MVP架构中将这三层分别抽象到各自的接口当中。通过接口将层次之间进行隔离，而Presenter对View和Model的相互依赖也是依赖于各自的接口。这点符合了接口隔离原则，也正是面向接口编程。在Presenter层中包含了一个View接口，并且依赖于Model接口，从而将Model层与View层联系在一起。而对于View层会持有一个Presenter成员变量并且只保留对Presenter接口的调用，具体业务逻辑全部交由Presenter接口实现类中处理。 官方MVP架构分析项目介绍 对于MVP架构有了一些的了解，而在前端时间Google给出了一些App开发架构的实现。 项目地址为：https://github.com/googlesamples/android-architecture. 在这里进入README看一下这次Google给出那些Android开发架构的实现。 对于上面五个开发架构的实现表示到目前为止是已经完成的项目，而下面两个则表示正在进行的中的项目。现在首先来介绍一下这几个架构。 todo-mvp: 基础的MVP架构。 todo-mvp-loaders:基于MVP架构的实现，在获取数据的部分采用了loaders架构。 todo-mvp-databinding: 基于MVP架构的实现，采用了数据绑定组件。 todo-mvp-clean: 基于MVP架构的clean架构的实现。 todo-mvp-dagger2: 基于MVP架构，采用了依赖注入dagger2。 dev-todo-mvp-contentproviders: 基于mvp-loaders架构，使用了ContenPproviders。 dev-todo-mvp-rxjava: 基于MVP架构，对于程序的并发处理和数据层（MVP中的Model）的抽象。 从上述的介绍中可以看出，对于官方给出所有的架构的实现最终都是基于MVP架构。所以在这里就对上面的基础的MVP架构todo-mvp进行分析。 项目结构的分析 对于这个项目，它实现的是一个备忘录的功能。对于工作中未完成的任务添加到待办任务列表中。我们能够在列表中可以对已完成的任务做出标记，能够进入任务详细页面修改任务内容，也能够对已完成的任务和未完成的任务数量做出统计。 首先在这里来看一下todo-mvp整体的项目结构 从上图中可以看出，项目整体包含了一个app src目录，四个测试目录。在src目录下面对代码的组织方式是按照功能进行划分。在这个项目中包含了四个功能，它们分别是：任务的添加编辑(addedittask),任务完成情况的统计(statistics),任务的详情(taskdetail),任务列表的显示(tasks)。对于data包它是项目中的数据源，执行数据库的读写，网络的请求操作都存放在该包内，也是MVP架构中的Model层。而util包下面则是存放一些项目中使用到的工具类。在最外层存放了两接口BasePresenter和BaseView。它们是Presenter层接口和View层接口的基类，项目中所有的Presenter接口和View层接口都继承自这两个接口。 现在进入功能模块内看下在模块内部对类是如何划分的。在每个功能模块下面将类分作xxActivity,xxFragment,xxPresenter,xxContract。也正是这些类构成了项目中的Presenter层与View层。下面就来分析在这个项目中是如何实现MVP架构。 MVP架构的实现 在这里只从宏观上关注MVP架构的实现,对于代码的内部细节在就不在具体分析。那么就以任务的添加和编辑这个功能来看一下Android官方是如何实现MVP架构。 Model层的实现 首先我们从MVP架构的最内层开始分析，也就是对应的Model层。在这个项目中对应的data包下的内容。在data下对数据库等一些数据源的封装。对于Presenter层提供了TasksDataSource接口。在这里看一下这个TasksDataSource接口。 123456789101112131415161718192021222324public interface TasksDataSource &#123; interface LoadTasksCallback &#123; void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); &#125; interface GetTaskCallback &#123; void onTaskLoaded(Task task); void onDataNotAvailable(); &#125; void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); ......&#125; TasksDataSource接口的实现是TasksLocalDataSource，在TasksDataSource中的方法也就是一些对数据库的增删改查的操作。而在TasksDataSource的两个内部接口LoadTasksCallback和GetTaskCallback是Model层的回调接口。它们的真正实现是在Presenter层。对于成功获取到数据后变或通过这个回调接口将数据传递Presenter层。同样，若是获取失败同样也会通过回调接口来通知Presenter层。下面来看一下TasksDataSource的实现类。 1234567891011121314151617181920212223242526272829303132333435public class TasksLocalDataSource implements TasksDataSource &#123; ...... @Override public void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback) &#123; //根据taskId查训出相对应的task ...... if (task != null) &#123; callback.onTaskLoaded(task); &#125; else &#123; callback.onDataNotAvailable(); &#125; &#125; @Override public void saveTask(@NonNull Task task) &#123; checkNotNull(task); SQLiteDatabase db = mDbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(TaskEntry.COLUMN_NAME_ENTRY_ID, task.getId()); values.put(TaskEntry.COLUMN_NAME_TITLE, task.getTitle()); values.put(TaskEntry.COLUMN_NAME_DESCRIPTION, task.getDescription()); values.put(TaskEntry.COLUMN_NAME_COMPLETED, task.isCompleted()); db.insert(TaskEntry.TABLE_NAME, null, values); db.close(); &#125; ......&#125; 在这里我们针对任务的添加和编辑功能，所以省略很多代码。可以看出在TasksLocalDataSource中实现的getTask方法，在这个方法中传入TasksDataSource内的GetTaskCallback回调接口。在getTask方法的实现可以看出在查询到Task以后调用回调方法，若是在Presenter层中实现了这两个回调方法，便将数据传递到Presenter层。而对于查询到的Task为空的时候也是通过回调方法执行对应的操作。 同样对于通过网络请求获取到数据也是一样，对于成功请求到的数据可以通过回调方法将数据传递到Presenter层，对于网络请求失败也能够通过回调方法来执行相对应的操作。 Presenter与View层提供的接口 由于在Presenter和View层所提供的接口在一个类中，在这里就先来查看他们对外所提供了哪些接口。首先观察一下两个基类接口BasePresenter和BaseView。 BasePresenter 1234567package com.example.android.architecture.blueprints.todoapp;public interface BasePresenter &#123; void start();&#125; 在BasePresenter中只存在一个start方法。这个方法一般所执行的任务是在Presenter中从Model层获取数据，并调用View接口显示。这个方法一般是在Fragment中的onResume方法中调用。 BaseView 1234567package com.example.android.architecture.blueprints.todoapp;public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; 在BaseView中只有一个setPresenter方法，对于View层会存在一个Presenter对象。而setPresenter正是对View中的Presenter进行初始化。 AddEditTaskContract 在Android官方给出的MVP架构当中对于Presenter接口和View接口提供的形式与我们平时在网上所见的有所不同。在这里将Presenter中的接口和View的接口都放在了AddEditTaskContract类里面。这样一来我们能够更清晰的看到在Presenter层和View层中有哪些功能，方便我们以后的维护。下面就来看一下这个AddEditTaskContract类。123456789101112131415161718192021222324public interface AddEditTaskContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void createTask(String title, String description); void updateTask( String title, String description); void populateTask(); &#125;&#125; 在这里很清晰的可以看出在View层中处理了一些数据显示的操作，而在Presenter层中则是对Task保存，更新等操作。 Presenter层的实现 下面就来看一下在Presenter是如何实现的。1234567891011121314151617181920212223242526272829303132333435363738394041public class AddEditTaskPresenter implements AddEditTaskContract.Presenter, TasksDataSource.GetTaskCallback &#123; ...... public AddEditTaskPresenter(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository); mAddTaskView = checkNotNull(addTaskView); mAddTaskView.setPresenter(this); &#125; @Override public void start() &#123; if (mTaskId != null) &#123; populateTask(); &#125; &#125; ...... @Override public void populateTask() &#123; if (mTaskId == null) &#123; throw new RuntimeException("populateTask() was called but task is new."); &#125; mTasksRepository.getTask(mTaskId, this); &#125; @Override public void onTaskLoaded(Task task) &#123; // The view may not be able to handle UI updates anymore if (mAddTaskView.isActive()) &#123; mAddTaskView.setTitle(task.getTitle()); mAddTaskView.setDescription(task.getDescription()); &#125; &#125; ......&#125; 在这里可以看到在AddEditTaskPresenter中它不仅实现了自己的Presenter接口，也实现了GetTaskCallback的回调接口。并且在Presenter中包含了Model层TasksDataSource的对象mTasksRepository和View层AddEditTaskContract.View的对象mAddTaskView。于是整个业务逻辑的处理就担负在Presenter的身上。 从Presenter的业务处理中可以看出，首先调用Model层的接口getTask方法，通过TaskId来查询Task。在查询到Task以后，由于在Presenter层中实现了Model层的回调接口GetTaskCallback。这时候在Presenter层中就通过onTaskLoaded方法获取到Task对象，最后通过调用View层接口实现了数据的展示。 View层的实现 对于View的实现是在Fragment中，而在Activity中则是完成对Fragment的添加，Presenter的创建操作。下面首先来看一下AddEditTaskActivity类。 12345678910111213141516171819202122232425public class AddEditTaskActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.addtask_act); ...... if (addEditTaskFragment == null) &#123; addEditTaskFragment = AddEditTaskFragment.newInstance(); ...... ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), addEditTaskFragment, R.id.contentFrame); &#125; // Create the presenter new AddEditTaskPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment); &#125; ......&#125; 对于Activity的提供的功能也是非常的简单，首先创建Fragment对象并将其添加到Activity当中。之后创建Presenter对象，并将Fragment也就是View传递到Presenter中。 下面再来看一下View的实现，也就是Fragment。 123456789101112131415161718192021222324public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View &#123; ...... @Override public void onResume() &#123; super.onResume(); mPresenter.start(); &#125; @Override public void setPresenter(@NonNull AddEditTaskContract.Presenter presenter) &#123; mPresenter = checkNotNull(presenter); &#125; ...... @Override public void setTitle(String title) &#123; mTitle.setText(title); &#125; ......&#125; 在这对于源码就不在过多贴出。在Fragment中，通过setPresenter获取到Presenter对象。并通过调用Presenter中的方法来实现业务的处理。而在Fragment中则只是对UI的一些操作。这样一来对于Fragment类型的代码减少了很多，并且逻辑更加清晰。 我们注意到View层的实现是通过Fragment来完成的。对于View的实现为什么要采用Fragment而不是Activity。来看一下官方是如何解释的。 The separation between Activity and Fragment fits nicely with this implementation of MVP: the Activity is the overall controller that creates and connects views and presenters.Tablet layout or screens with multiple views take advantage of the Fragments framework. 在这里官方对于采用Fragment的原因给出了两种解释。 通过Activity和Fragment分离非常适合对于MVP架构的实现。在这里将Activity作为全局的控制者将Presenter于View联系在一起。 采用Fragment更有利于平板电脑的布局或者是多视图屏幕。 总结 通过MVP架构的使用可以看出对于各个层次之间的职责更加单一清晰，同时也很大程度上降低了代码的耦合度。对于官方MVP架构示例，google也明确表明对于他们所给出的这些架构示例只是作为参考，而不是一个标准。所以对于基础的MVP架构有更大的扩展空间。例如综合google给出的示例。我们可以通过在MVP架构的基础上使用dagger2，rxJava等来构建一个Clean架构。也是一个很好的选择。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProGuard详解]]></title>
    <url>%2F2016%2F05%2F03%2F20160503_proguard%2F</url>
    <content type="text"><![CDATA[综述 对于ProGuard工具想必我们都不陌生，它能够通过移除无用代码，使用简短无意义的名称来重命名类，字段和方法。从而能够达到压缩、优化和混淆代码的目的。最终我们会获取一个较小的apk文件，并且我们这个通过ProGuard处理的apk文件更难于进行逆向工程。 ProGuard工作原理简介 ProGuard能够对Java类中的代码进行压缩（Shrink）,优化（Optimize）,混淆（Obfuscate）,预检（Preveirfy）。 1. 压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性。 2. 优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令。 3. 混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名。 4. 预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检。 对于ProGuard执行流程图如下图所示。 对于ProGuard的原理更详细的介绍可以参考Proguard手册，在这里就不在进行更详细的介绍。 ProGuard使用 ProGuard已集成到Android构建系统中，所以我们不用手动调用这个工具。我们可以选择在只发布模式下构建系统的时候再去运行ProGuard。 在AndroidStudio中我们需要将Proguard添加到gradle.build文件的构建类型当中。不过在我们创建一个Android工程的时候，系统已经自动为我们添加到了gradle.build中。123456buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; minifyEnabled:开启混淆,我们新建的工程默认为false，因此，如果我们需要开启混淆的话就需要手动设为true。 proguardFiles:这部分有两段，前一段代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，免去了我们很多事，这个文件的目录在/tools/proguard/proguard-android.txt , 后一部分是我们项目里的自定义的混淆文件，目录就在 app/proguard-rules.pro,在这个文件里我们可以声明一些我们所需要的定制的混淆规则。 下面我们就来看一下这个默认的android程序混淆文件proguard-android.txt。对于下面一些指令与代码的含义在后面会进行说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-verbose# Optimization is turned off by default. Dex does not like code run# through the ProGuard optimize and preverify steps (and performs some# of these optimizations on its own).-dontoptimize-dontpreverify# Note that if you want to enable optimization, you cannot just# include optimization flags in your own project configuration file;# instead you will need to point to the# "proguard-android-optimize.txt" file instead of this one from your# project.properties file.-keepattributes *Annotation*-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# For native methods, see http://proguard.sourceforge.net/manual/examples.html#native-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# keep setters in Views so that animations can still work.# see http://proguard.sourceforge.net/manual/examples.html#beans-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;# We want to keep methods in Activity that could be used in the XML attribute onClick-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# The support library contains references to newer platform versions.# Don't warn about those in case this app is linking against an older# platform version. We know about them, and they are safe.-dontwarn android.support.**# Understand the @Keep support annotation.-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; proguard-rules.pro配置ProGuard基本指令 下面列举了我们开发中需要使用的一些指令。12345678910111213141516171819202122232425262728293031#代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5#混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames#指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses#这句话能够使我们的项目混淆后产生映射文件#包含有类名-&gt;混淆后类名的映射关系-verbose#指定不去忽略非公共库的类-dontskipnonpubliclibraryclassmembers#不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify#保留Annotation不混淆-keepattributes *Annotation*,InnerClasses#避免混淆泛型-keepattributes Signature#抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable#指定混淆是采用的算法，后面的参数是一个过滤器#这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/* 需要保留的代码 下面列举了一些在我们的app开发中需要保留的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#保留我们使用的四大组件，自定义的Application等等这些类不被混淆#因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService#保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125;#保留R下面的资源-keep class **.R$* &#123;*;&#125;#保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留在Activity中的方法参数是view的方法，#这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;#保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;#保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;#保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;#对于带有回调函数的onXXEvent的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event);&#125; 针对我们的App进行配置1. 对于实体类我们不能混淆 对于实力类我们不能进行混淆，我们需要保留他们的set和get方法。对于boolean类型的get方法为isXXX,不能够遗漏。在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。12345-keep public class com.ljd.example.entity.** &#123; public void set*(***); public *** get*(); public *** is*();&#125; 2. 在我们的app中使用了webView需要进行特殊处理 在我们的项目中经常会嵌入一些webview做一些复杂的操作，这时候我们能够添加如下代码。12345678910-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; 3. 在app中与HTML5的JavaScript的交互进行特殊处理 在我们的App中有时候需要与Html5中的JavaScript进行交互。例如：12345678package com.ljd.example;public class JSInterface &#123; @JavascriptInterface public void callAndroidMethod()&#123; // do something &#125;&#125; 我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理：123-keepclassmembers class com.ljd.example.JSInterface &#123; &lt;methods&gt;;&#125; 4. 对含有反射类的处理 1-keep class 类所在的包.** &#123; *; &#125; 5.对于第三方依赖库的处理 这个取决于第三方的混淆策略。下面列举一些第三方依赖库的混淆策略。具体还以官方给出的为准。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#支付宝-libraryjars libs/alipaysdk.jar-dontwarn com.alipay.android.app.**-keep public class com.alipay.** &#123; *; &#125;# Retrolambda-dontwarn java.lang.invoke.*#realm-keep class io.realm.annotations.RealmModule-keep @io.realm.annotations.RealmModule class *-keep class io.realm.internal.Keep-keep @io.realm.internal.Keep class * &#123; *; &#125;-dontwarn javax.**-dontwarn io.realm.**# OrmLite-keep class com.j256.**-keepclassmembers class com.j256.** &#123; *; &#125;-keep enum com.j256.**-keepclassmembers enum com.j256.** &#123; *; &#125;-keep interface com.j256.**-keepclassmembers interface com.j256.** &#123; *; &#125;#极光推送-dontoptimize-dontpreverify-dontwarn cn.jpush.**-keep class cn.jpush.** &#123; *; &#125;#EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;#retroift-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions#ButterKnife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;#fastjson-dontwarn com.alibaba.fastjson.**-keep class com.alibaba.fastjson.** &#123; *; &#125;#rxjava-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;#jackson-dontwarn org.codehaus.jackson.**-dontwarn com.fasterxml.jackson.databind.**-keep class org.codehaus.jackson.** &#123; *;&#125;-keep class com.fasterxml.jackson.** &#123; *; &#125;#Facebook-keep class com.facebook.** &#123;*;&#125;-keep interface com.facebook.** &#123;*;&#125;-keep enum com.facebook.** &#123;*;&#125;#Fresco-keep class com.facebook.fresco.** &#123;*;&#125;-keep interface com.facebook.fresco.** &#123;*;&#125;-keep enum com.facebook.fresco.** &#123;*;&#125; 在Android中配置ProGuard模板代码 对于ProGuard的配置在下面给出代码的通用部分，在使用的时候直接复制即可，之后根据自己的项目进行添加一些自己项目中所需要保留的内容，以及所依赖第三方库的处理即可。在下面代码中对于在proguard-android.txt中已经添加过得代码在这里可以选择忽略。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899############################################### 对于一些基本指令的添加##############################################-optimizationpasses 5-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-verbose-dontskipnonpubliclibraryclassmembers-dontpreverify-keepattributes *Annotation*,InnerClasses-keepattributes Signature-keepattributes SourceFile,LineNumberTable-optimizations !code/simplification/cast,!field/*,!class/merging/*############################################### Android开发中一些需要保留的公共部分##############################################-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService-keep class android.support.** &#123;*;&#125;-keep class **.R$* &#123;*;&#125;-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;-keepclassmembers class * &#123; void *(**On*Event);&#125;#webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;############################################### 项目中特殊处理部分###############################################-----------处理反射类---------------......#-----------处理js交互---------------......#-----------处理实体类---------------......#-----------处理第三方依赖库---------...... 注意事项1. 确保混淆不会对项目产生影响 对于我们的Android项目最好是能够在一开始就是用ProGuard进行处理。并且在debug模式下也进行ProGuard处理，这样就能够在我们的开发中进行处理ProGuard所造成的影响。 2. 打包时忽略警告 在我们打包的时候，会发现很多could not reference class之类的warning信息。如果我们能够确认App在运行中和那些引用没有什么关系，可以添加-dontwarn标签。如-dontwarn org.apache.harmony.**。 我们不要使用-ignorewarnings语句，这个会忽略所有警告，会有很多潜在的风险。 总结 对于ProGuard的使用不是很复杂，但是在我们的项目中使用ProGuard是必不可少的，它不仅仅能够对代码进行混淆，还能够优化我们的代码，减少我们apk文件的体积。从而优化我们的代码 附录 Proguard手册ProGuard ReTrace 手册]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ProGuard</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的线程池]]></title>
    <url>%2F2016%2F04%2F28%2F20160428_threadpool%2F</url>
    <content type="text"><![CDATA[综述 在我们的开发中经常会使用到多线程。例如在Android中，由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中运行。我们往往会通过new Thread来开启一个子线程，待子线程操作完成以后通过Handler切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者OOM。所以在Java中为我们提供了线程池来管理我们所创建的线程。 线程池的使用采用线程池的好处 在这里我们首先来说一下采用线程池的好处。 1. 重用线程池中已经存在的线程，减少了线程的创建和消亡多造成的性能开销。 2. 能够有效控制最大的并发线程数，提高了系统资源的使用率，并且还能够避免大量线程之间因为相互抢占系统资源而导致阻塞。 3. 能够对线程进行简单管理，并提供定时执行、定期执行、单线程、并发数控制等功能。 ThreadPoolExecutor 我们可以通过ThreadPoolExecutor来创建一个线程池。下面我们就来看一下ThreadPoolExecutor中的一个构造方法。 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor参数含义1. corePoolSize 线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。 2. maximumPoolSize 线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。 3. keepAliveTime 非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。 4. unit 用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒); 5. workQueue 线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。 ArrayBlockingQueue:基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 LinkedBlockingQueue:基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 SynchronousQueue:内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。 PriorityBlockingQueue:具有优先级的无限阻塞队列。 我们还能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。 6. threadFactory 线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 7. handler 他是RejectedExecutionHandler对象，而RejectedExecutionHandler是一个接口，里面只有一个rejectedExecution方法。当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。在ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler接口。在线程池中它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常。下面是在ThreadPoolExecutor中提供的四个可选值。 CallerRunsPolicy:只用调用者所在线程来运行任务。 AbortPolicy:直接抛出RejectedExecutionException异常。 DiscardPolicy:丢弃掉该任务，不进行处理 DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。 ThreadPoolExecutor执行规则 如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。 如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。 由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。 如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。 ThreadPoolExecutor的使用 上面说了那么多，我们现在就来看一下到底是如何使用这个ThreadPoolExecutor。首先我们通过ThreadPoolExecutor创建一个一个线程池。 1ExecutorService executorService = new ThreadPoolExecutor(5,10,10,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;&gt;()); 对于ThreadPoolExecutor有多个构造方法，对于上面的构造方法中的其他参数都采用默认值。我们创建完一个线程池以后，下面就再来看一下如何向线程池提交一个任务。我们可以通过execute和submit两种方式来向线程池提交一个任务。 execute 当我们使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。 12345678executorService.execute(new Runnable() &#123; @Override public void run() &#123; // doSomething &#125;&#125;); submit 当我们使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。 1234567891011121314151617Future&lt;Object&gt; future = executorService.submit(new Callable&lt;Object&gt;() &#123; @Override public String call() throws Exception &#123; // TODO Auto-generated method stub return null; &#125;&#125;);try &#123; Object object = future.get();&#125; catch (InterruptedException e) &#123; // 处理中断异常 e.printStackTrace();&#125; catch (ExecutionException e) &#123; // 处理无法执行异常 e.printStackTrace();&#125; 关闭线程池 我们可以通过shutdown方法或者shutdownNow方法来关闭线程池。对于这两种关闭线程池的方式他们都是通过遍历线程池中所有的线程，然后依次调用线程的interrupt方法来中断线程。当然对于这两种关闭线程池的方法也是有一定区别的（具体区别见下面注释）。 当我们调用了下面任何一个关闭方法时，isShutdown方法就会返回true。而当线程池关闭成功以后isTerminaed方法会返回true。对于线程池中的正在执行的任务如果我们希望他们执行完成以后再去关闭线程池则调用shutdown方法；而我们希望在关闭线程池的时候中断线程池内正在执行的任务，则调用shutdownNow方法。1234567891011/*** 首先将线程池的状态设置成SHUTDOWN状态，然后中断所* 有没有正在执行任务的线程。*/executorService.shutdown();/*** 首先将线程池的状态设置为STOP，然后开始尝试停止所有的正在* 工作或暂停任务的线程*/executorService.shutdownNow(); Java线程池Java中的线程池分类 在这里我们介绍一下Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置ThreadPoolExecutor来实现他们各自的功能。这四种线程池分别是newFixedThreadPool,newCachedThreadPool,newScheduledThreadPool和newSingleThreadExecutor。这四个线程池可以通过Executors类获取。下面分别介绍这四种线程池。 1. newFixedThreadPool 我们可以通过Executors中的newFixedThreadPool方法来创建，该线程池是一种线程数量固定的线程池。在这个线程池中所容纳最大的线程数就是我们设置的核心线程数。如果线程池的线程处于空闲状态的话，它们并不会被回收，除非是这个线程池被关闭。如果所有的线程都处于活动状态的话，新任务就回处于等待状态，直到有线程空闲出来。由于newFixedThreadPool只有核心线程，并且这些线程都不会被回收，也就是它能够更快速的响应外界请求。从下面的newFixedThreadPool方法的实现可以看出，newFixedThreadPool只有核心线程，并且不存在超时机制，采用LinkedBlockingQueue，所以对于任务队列的大小也是没有限制的。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 2. newCachedThreadPool 我们可以通过Executors中的newCachedThreadPool方法来创建，通过下面的newCachedThreadPoolfan’f在这里我们可以看出它的核心线程数为0，线程池的最大线程数Integer.MAX_VALUE。而Integer.MAX_VALUE是一个很大的数，也差不多可以说这个线程池中的最大线程数可以任意大。当线程池中的线程都处于活动状态的时候，线程池就会创建一个新的线程来处理任务。该线程池中的线程超时时长为60秒，所以当线程处于闲置状态超过60秒的时候便会被回收。这也就意味着若是整个线程池的线程都处于闲置状态超过60秒以后，在newCachedThreadPool线程池中是不存在任何线程的，所以这时候它几乎不占用任何的系统资源。对于newCachedThreadPool他的任务队列采用的是SynchronousQueue，上面说到在SynchronousQueue内部没有任何容量的阻塞队列。SynchronousQueue内部相当于一个空集合，我们无法将一个任务插入到SynchronousQueue中。所以说在线程池中如果现有线程无法接收任务,将会创建新的线程来执行任务。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 3. newScheduledThreadPool 我们可以通过Executors中的newScheduledThreadPool方法来创建，它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。 1234567public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 4. newSingleThreadExecutor 我们可以通过Executors中的newSingleThreadExecutor方法来创建，在这个线程池中只有一个核心线程，对于任务队列没有大小限制，也就意味着这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行。newSingleThreadExecutor将所有的外界任务统一到一个线程中支持，所以在这个任务执行之间我们不需要处理线程同步的问题。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 四种线程池的使用 下面我们就来看一下对于上面四种线程池是如何使用的。 1234567891011121314151617181920Runnable command = new Runnable() &#123; public void run() &#123; //doSomething &#125;&#125;; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);fixedThreadPool.execute(command);ExecutorService cachedThreadPool= Executors.newCachedThreadPool();cachedThreadPool.equals(command);ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);//1000毫秒后执行coommandscheduledThreadPool.schedule(command, 1000, TimeUnit.MILLISECONDS);//延时5毫秒后，每隔100毫秒执行一次commandscheduledThreadPool.scheduleAtFixedRate(command, 5, 100, TimeUnit.MILLISECONDS);ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();singleThreadExecutor.execute(command); 总结 对于Java中的线程池概念同样适用于Android，例如在我们开发一个app时，我们可以创建一个线程池，将所有的子线程任务交由线程池来处理，于是我们便可以通过这个线程池来管理维护我们的子线程。减少了应用的开销。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
</search>
