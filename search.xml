<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android稳定性测试工具Monkey的使用]]></title>
    <url>%2F2017%2F01%2F15%2Fmonkey%2F</url>
    <content type="text"><![CDATA[Monkey是一个命令行工具，它可以运行在我们的模拟器或者设备当中。它可以发送一些伪随机（pseudo-random）的用户事件流，例如点击，触摸，手势等。我们能够使用Monkey工具来对我们所开发的应用进行压力测试。Monkey测试是一种为了测试软件的稳定性，健壮性的快速有效的方法。 Monkey程序介绍 Monkey是Android自带的系统工具，是由java语言编写。他在Android文件系统存放的路径是：/system/framework/monkey.jar启动moneky.jar的shell脚本文件在Android文件系统存放的路径为：/system/bin/monkey。打开这个monkey文件我们可以看一下这个脚本文件很简单。1234567# Script to start "monkey" on the device, which has a very rudimentary# shell.#base=/systemexport CLASSPATH=$base/framework/monkey.jartrap "" HUPexec app_process $base/bin com.android.commands.monkey.Monkey $* 我们可以看到他调用的是com.android.commands.monkey.Monkey包。 Monkey常用命令 下面我们就来执行这个monkey脚本。我们执行如下命令。1adb shell monkey 这时候，monkey将以无反馈模式进行启动，并把事件任意发送到安装在目标环境下中的全部包。运行结果如下所示。1234567891011121314151617181920212223242526LiJiangdongdeMacBook-Pro:~ lijiangdong$ adb shell monkeyusage: monkey [-p ALLOWED_PACKAGE [-p ALLOWED_PACKAGE] ...] [-c MAIN_CATEGORY [-c MAIN_CATEGORY] ...] [--ignore-crashes] [--ignore-timeouts] [--ignore-security-exceptions] [--monitor-native-crashes] [--ignore-native-crashes] [--kill-process-after-error] [--hprof] [--pct-touch PERCENT] [--pct-motion PERCENT] [--pct-trackball PERCENT] [--pct-syskeys PERCENT] [--pct-nav PERCENT] [--pct-majornav PERCENT] [--pct-appswitch PERCENT] [--pct-flip PERCENT] [--pct-anyevent PERCENT] [--pct-pinchzoom PERCENT] [--pkg-blacklist-file PACKAGE_BLACKLIST_FILE] [--pkg-whitelist-file PACKAGE_WHITELIST_FILE] [--wait-dbg] [--dbg-no-events] [--setup scriptfile] [-f scriptfile [-f scriptfile] ...] [--port port] [-s SEED] [-v [-v] ...] [--throttle MILLISEC] [--randomize-throttle] [--profile-wait MILLISEC] [--device-sleep-time MILLISEC] [--randomize-script] [--script-log] [--bugreport] [--periodic-bugreport] COUNT 这时候可以看到monkey并没有运行起来，只是显示了usage，这是因为少了一个重要的参数，这是指发送的事件数。如果我们需要发送500个随机事件，执行如下命令。1adb shell monkey 500 这时候我们可以看到手机已经疯狂的运行起来了。moneky的基本语法为1$ adb shell monkey [options] &lt;event-count&gt; monkey的option操作都是根据具体需求设定的，主要分为常规类，事件类，约束类和调试类。下面就对这些命令进行说明。 Category Option Description 常规类 –help 显示moneky参数帮助信息usage -v 打印日志信息，每个-v将增加反馈信息的级别。-v越多日志信息就会越详细，不过目前最多支持三个-v。Level0：一个-v，除启动提示、测试完成和最终结果之外，提供较少信息。Level1：两个-v，提供较为详细的测试信息，如逐个发送到Activity的事件。Level2：三个-v，提供更加详细的设置信息，如测试中被选中的或未被选中的Activity。 事件类 -s &lt;seed&gt; 伪随机数生成器的seed值。如果用相同的seed值再次运行 Monkey，它将生成相同的事件序列。 –throttle &lt;milliseconds&gt; 后面接时间，单位为毫秒，表示事件之间的固定延时（即执行每一个指令的间隔时间），若不接这个选项，monkey则不会延时 –pct-touch &lt;percent&gt; 后面接触摸事件的百分比。(触摸事件是一个down-up事件，它发生在屏幕上的某单一位置) –pct-motion &lt;percent&gt; 后面接动作事件的百分比。(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个up事件组成)。 –pct-trackball &lt;percent&gt; 后面接轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随有点击)。 –pct-nav &lt;percent&gt; 后面接“基本”导航事件百分比(导航事件主要来自方向输入设备的上，下，左，右事件) –pct-majornav &lt;percent&gt; 后面接“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如：5-way键盘的中间按键、回退按键、菜单按键) –pct-syskeys &lt;percent&gt; 后面接“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、StartCall、End Call及音量控制键)。 –pct-appswitch &lt;percent&gt; 后面接启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。 –pct-anyevent &lt;percent&gt; 调整其它类型事件的百分比。它包罗了所有其它类型的事件，如：按键、其它不常用的设备按钮、等等。 约束类 -p &lt;allowed-package-name&gt; 如果用此参数指定了一个或几个包，Monkey将只允许系统启动这些包里的Activity。如果你的应用程序还需要访问其它包里的Activity(如选择取一个联系人)，那些包也需要在此同时指定。如果不指定任何包，Monkey将允许系统启动全部包里的Activity。要指定多个包，需要使用多个-p选项，每个-p选项只能用于一个包。 -c &lt;main-category&gt; 如果用此参数指定了一个或几个类别，Monkey将只允许系统启动被这些类别中的某个类别列出的Activity。如果不指定任何类别，Monkey将选择下列类别中列出的Activity：Intent.CATEGORY_LAUNCHER或Intent.CATEGORY_MONKEY。要指定多个类别，需要使用多个-c选项，每个-c选项只能用于一个类别。 调试类 –dbg-no-events 设置此选项，Monkey将执行初始启动，进入到一个测试Activity，然后不会再进一步生成事件。为了得到最佳结果，把它与-v、一个或几个包约束、以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个环境，可以监视应用程序所调用的包之间的转换。 –hprof 设置此选项，将在Monkey事件序列之前和之后立即生成profiling报告。这将会在data/misc中生成大文件(~5Mb)，所以要小心使用它。 –ignore-crashes 通常，当应用程序崩溃或发生任何失控异常时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 –ignore-timeouts 通常，当应用程序发生任何超时错误(如“ApplicationNot Responding”对话框)时，Monkey将停止运行。如果设置此选项，Monkey将继续向系统发送事件，直到计数完成。 –ignore-security-exceptions]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化之内存泄漏]]></title>
    <url>%2F2016%2F12%2F11%2Fmemory-leak%2F</url>
    <content type="text"><![CDATA[内存泄漏（memory leak）是指由于疏忽或错误造成程序未能释放已经不再使用的内存。那么在Android中，当一个对象持有Activity的引用，如果该对象不能被系统回收，那么当这个Activity不再使用时，这个Activity也不会被系统回收，那这么以来便出现了内存泄漏的情况。在应用中内出现一次两次的内存泄漏获取不会出现什么影响，但是在应用长时间使用以后，若是存在大量的Activity无法被GC回收的话，最终会导致OOM的出现。那么我们在这就来分析一下导致内存泄漏的常见因素并且如何去检测内存泄漏。 导致内存泄漏的常见因素情景一：静态Activity和View 静态变量Activity和View会导致内存泄漏，在下面这段代码中对Activity的Context和TextView设置为静态对象，从而产生内存泄漏。123456789101112131415161718import android.content.Context;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private static Context context; private static TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; textView = new TextView(this); &#125;&#125; 情景二：Thread，匿名类，内部类 在下面这段代码中存在一个非静态的匿名类对象Thread，会隐式持有一个外部类的引用LeakActivity，从而导致内存泄漏。同理，若是这个Thread作为LeakActivity的内部类而不是匿名内部类，他同样会持有外部类的引用而导致内存泄漏。在这里只需要将为Thread匿名类定义成静态的内部类即可（静态的内部类不会持有外部类的一个隐式引用）。12345678910111213141516171819202122public class LeakActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); leakFun(); &#125; private void leakFun()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(Integer.MAX_VALUE); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 情景三：动画 在属性动画中有一类无限循环动画，如果在Activity中播放这类动画并且在onDestroy中去停止动画，那么这个动画将会一直播放下去，这时候Activity会被View所持有，从而导致Activity无法被释放。解决此类问题则是需要早Activity中onDestroy去去调用objectAnimator.cancel()来停止动画。12345678910111213public class LeakActivity extends AppCompatActivity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); textView = (TextView)findViewById(R.id.text_view); ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(textView,"rotation",0,360); objectAnimator.setRepeatCount(ValueAnimator.INFINITE); objectAnimator.start(); &#125;&#125; 情景四：Handler 对于Handler的内存泄漏在(Android的消息机制——Handler的工作过程)[http://blog.csdn.net/ljd2038/article/details/50889754]这篇文章中已经详细介绍，就不在赘述。 情景五：第三方库使用不当 对于EventBus，RxJava等一些第三开源框架的使用，若是在Activity销毁之前没有进行解除订阅将会导致内存泄漏。 使用MAT检测内存泄漏 对于常见的内存泄露进行介绍完以后，在这里再看一下使用MAT（Memory Analysis Tool）来检测内存泄露。MAT的下载地址为：http://www.eclipse.org/mat/downloads.php。 下面来看一段会导致内存泄露的错误代码。1234567891011121314public class LeakActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); EventBus.getDefault().register(this); &#125; @Subscribe public void subscriber(String s)&#123; &#125;&#125; 在上面这段代码中有会导致内存泄漏，原因是EventBus没有解除注册。下面就以这段代码为例来看一下如何分析内存泄漏。 打开AndroidStudio中的Monitors可以看到如下界面。 在这里可以看到在应用刚启动的时候，所占用的内存为15M，然后我们现在开始操作APP，反复进入退出LeakActicity。点击上如中的GC按钮。这时候我们在看一下内存使用情况。 在这里我们可以看到，内存一直在持续增加，已经达到33M，并且无法被GC所回收。所以我们可以判断，这时候必然出现内存泄漏的情形。那么现在再点击Dump Java Heap按钮，在captures窗口看到生成得hprof文件。但这时候所生成的hprof文件不是标准格式的，我们需要通过SDK所提供的工具hprof-conv进行转化，该工具在SDK的platform-tools目录下。执行命令如下：1 hprof-conv XXX.hprof converted-dump.hprof 当然在AndroidStudio中可以省去这一步，可以直接导出标准格式的hprof文件。 这时候可以通过MAT工具来打开导出的hprof文件。打开界面如下图所示： 在MAT中我们最常用的就是Histogram和Dominator Tree，他们分别对应上图中的A和B按钮。Histogram可以看出内存中不同类型的buffer的数量和占用内存的大小，而Dominator Tree则是把内存中的对象按照从大到小的顺序进行排序，并且可以分析对象之间的引用关系。在这里再来介绍一下MAT中两个符号的含义。 ShallowHeap:对象自身占用的内存大小，不包括他引用的对象 RetainedHeap:对象自身占用的内存大小并且加上它直接或者间接引用对象的大小Histogram 由于在Android中一般内存泄漏大多出现在Acivity中，这时候可以点击Histogram按钮，并搜索Activity。 在这里可以看出LeakActivity存在69个对象，基本上可以断定存在内存泄漏的情形，这时候便可以通过查看GC对象的引用链来进行分析。点击鼠标右键选择Merge Shortest paths to GC Roots并选择exclude weak/soft references来排除弱引用和软引用。 在排除软引用和弱引用以后如下图所示： 在这里可以看出由于EventBus导致的LeakActivity内存泄漏。 在Histogram中还可以查看一个对象包含了那些对象的引用。例如，现在要查看LeakActivity所包含的引用，可以点击鼠标右键，选择list objects中的with incoming reference。而with outcoming reference表示选中对象持有那些对象的引用。 Dominator Tree 现在我们点击这时候可以点击Dominator Tree按钮，并搜索Activity。可以看到如下图所示： 在这里可以看到存在大量的LeakActivity。然后点击鼠标右键选择Path To GC Roots-&gt;exclude weak/soft references来排除弱引用和软引用。 之后可以看到如下结果，依然是EventBus导致的内存泄漏： 总结 内存泄漏往往被我们所忽略，但是当大量的内存泄漏以后导致OOM。它所造成的影响也是不容小觑的。当然除了上述内存泄漏的分析以为我们还可以通过LeakCanary来分析内存泄漏。对于LeakCanary的使用在这里就不在进行详细介绍。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2源码解读]]></title>
    <url>%2F2016%2F06%2F18%2Fretrofit2.0-source%2F</url>
    <content type="text"><![CDATA[Retrofit2的用法在Retrofit2.0使用详解这篇文章中已经详细介绍过了。那么在这就来看一下Retrofit2它是如何实现的。Retrofit2中它的内部网络请求是依赖于OKHttp，所以Retrofit2可以看做是对OKHttp的一次封装，那么下面就开看下Retrofit2是如何对OKHttp进行封装的。 回顾Retrofit2的使用 在这里首先来回顾一下Retrofit2的使用。对于Retrofit2的使用可以分为三步。 首先，我们创建一个Java接口GitHubService来作为Http请求接口。123456public interface GitHubService &#123; @GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors") Call&lt;ResponseBody&gt; contributorsBySimpleGetCall(@Path("owner") String owner,@Path("repo") String repo);&#125; 然后我们需要创建一个Retrofit实例，并通过Retrofit对象创建一个GitHubService接口的实现。12345678Retrofit retrofit = new Retrofit.Builder() //添加对RxJava的支持 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) //添加对Json转换器的支持 .addConverterFactory(GsonConverterFactory.create()) .baseUrl("https://api.github.com/") .build();GitHubService service = retrofit.create(GitHubService.class); 最后通过调用我们创建的接口便能够向后台发起请求。123456789101112Call&lt;ResponseBody&gt; call = service.contributorsBySimpleGetCall(&quot;square&quot;, &quot;retrofit&quot;);call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; ...... &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; ...... &#125;&#125;); Retrofit2源码分析 首先通过@GET来标识这个接口是一个GET请求。那么看一下这个GET注解的定义。12345678910111213141516package retrofit2.http;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.Target;import okhttp3.HttpUrl;import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.RetentionPolicy.RUNTIME;@Documented@Target(METHOD)@Retention(RUNTIME)public @interface GET &#123; String value() default "";&#125; 从注解中可以看出这个注解是对方法的声明，并且在运行时VM依然保留注解。Java自定义注解在这里就不在过多说明，可以参考 Java注解在Android中使用这篇文章。 下面就再来看一下是如何创建Retrofit对象的。对于Retrofit对象的创建采用的是Builder模式。那么在这里我们就来看一下这个Builder类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static final class Builder &#123; //对平台的支持 private Platform platform; //发起请求OKHttp3的Client工厂 private okhttp3.Call.Factory callFactory; //OKHttp2的HttpUrl对象，也就是将我们传入的baseUrl字符串包装成HttpUrl private HttpUrl baseUrl; //转换器工厂集合，retrofit可以插入多个转化器，例如：Gson，Jackson等等 private List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); //用于发起请求和接收响应的Call适配器工厂集合， //Retrofit对RxJava的支持就是通过在该集合中添加RxJavaCallAdapterFactory, //而RxJavaCallAdapterFactory正是继承自CallAdapter.Factory private List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); //Executor并发框架，用于对请求后响应结果的回调执行 private Executor callbackExecutor; //是否需要立即生效 private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform; // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; //对属性的配置 ...... public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125;&#125; 对于Retrofit中的属性配置已经在注释中进行说明。在这里在对Platform进行一下介绍。我们可以看出通过Platform.get()来获取到当前运行的平台。下面就进出Platform.get()方法中来查看一下Retrofit到底支持哪些平台。1234567891011121314151617181920212223242526private static final Platform PLATFORM = findPlatform();static Platform get() &#123; return PLATFORM;&#125;private static Platform findPlatform() &#123; try &#123; Class.forName("android.os.Build"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName("java.util.Optional"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName("org.robovm.apple.foundation.NSObject"); return new IOS(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform();&#125; 在Platform的get方法中实际上还是调用了findPlatform方法，通过findPlatform方法我们可以看出Retrofit支持三个平台，它们分别是Android，Java8，IOS。这里的IOS指的是RoboVM。RoboVM它是一种可以在iOS设备上运行Java应用程序的技术，这种技术主要还是用于在游戏开发中。在这里我们只讨论在Android平台中的使用。在获取到当前平台为Android平台之后返回一个Android对象，这个Android类是Platform中的一个静态内部类，并且它继承自Platform。下面就在来看一下这个Android类。1234567891011121314151617static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 在这个Android类中重写了父类的defaultCallbackExecutor和defaultCallAdapterFactory方法。对于defaultCallbackExecutor方法它所返回的一个Executor，从它的实现类MainThreadExecutor可以看出，实际上就是在主线中创建一个Handler对象，然后通过Handler的post方法将请求的结果回调到主线程中运行。而defaultCallAdapterFactory它是默认的Call适配器，它是一个ExecutorCallAdapterFactory对象，对于ExecutorCallAdapterFactory在后面会进行说明。在这里完成了对于Retrofit对象的创建以后，便通过Retrofit中的create方法创建一个我们请求接口的实现。下面就来看一下这个create方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125;private void eagerlyValidateMethods(Class&lt;?&gt; service) &#123; Platform platform = Platform.get(); for (Method method : service.getDeclaredMethods()) &#123; if (!platform.isDefaultMethod(method)) &#123; loadServiceMethod(method); &#125; &#125;&#125;ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 在create方法中首先会进行判断所传入进来的Service是否是一个接口，当我们将validateEagerly属性设为true的时候，在我们调用create方法创建一个Service，就直接调用eagerlyValidateMethods方法。而eagerlyValidateMethods的作用是通过反射获取我们创建service接口中所有的接口方法，然后根据接口方法和当前的retrofit对象来获得ServiceMethod并且以接口方法作为Key，ServiceMethod作为值添加到serviceMethodCache缓存中。下次便可以通过接口方法直接获取ServiceMethod。 现在在往下看我们就明白为什么通过接口来作为一个Http请求，以及为什么调用create方法时需要验证我们的service是否为一个接口。因为在这里是通过Java的动态代理来实现Http请求，并返回一个代理类对象。对于Java的动态代理它是需要委托类与代理类实现同一个接口，在这里也就是我们创建的service请求接口。对于Java的动态代理可参考Java设计模式之代理模式这篇文章。当我们通过代理类（也就是我们调用create方法后返回的service）调用我们所创建的接口方法时。InvocationHandler中的invoke方法将会被调用。在invoke方法中由于method.getDeclaringClass()获取到的是一个接口，并不是Object类，所以第一个条件不成立。而在Android平台下platform.isDefaultMethod(method)返回的为false，所以这个条件也不成立。之后通过loadServiceMethod方法来获取ServiceMethod。最后调用ServiceMethod中callAdapter的adapt方法。而ServiceMethod中的callAdapter属性是通过ServiceMethod中createCallAdapter方法所创建。在createCallAdapter中实际上是调用了Retrofit中的callAdapter方法来对ServiceMethod中的callAdapter进行初始化。下面再看一下Retrofit中的callAdapter方法。12345678910111213141516171819public CallAdapter&lt;?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123; return nextCallAdapter(null, returnType, annotations);&#125;public CallAdapter&lt;?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123; checkNotNull(returnType, "returnType == null"); checkNotNull(annotations, "annotations == null"); int start = adapterFactories.indexOf(skipPast) + 1; for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123; CallAdapter&lt;?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) &#123; return adapter; &#125; &#125; ......&#125; 在这段代码中，通过遍历adapterFactories并根据我们的接口方法所中返回值类型来获取响应的适配器callAdapter。例如上面的例子中返回值是一个Call对象，将会采用默认的适配器，如果我们返回的是RxJava中Observable对象，如果我们添加了RxJavaCallAdapterFactory，那么返回的就是RxJavaCallAdapter。如果没有添加那么此处的adapter为null，便会抛出异常。在正是通过这种适配器模式完成了对RxJava的完美结合。下面就以Retrofit默认的callAdapter为例来看一下是如何调用OKHttp来完成对网络的请求的。对于此时的callAdapter就是通过platform.defaultCallAdapterFactory(callbackExecutor)所创建的适配器。从刚才观察Platform内部类Android中可以看出它返回的是一个ExecutorCallAdapterFactory对象。下面就来看一下这个ExecutorCallAdapterFactory类。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException("callback == null"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(final Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(call, new IOException("Canceled")); &#125; else &#123; callback.onResponse(call, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(final Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(call, t); &#125; &#125;); &#125; &#125;); &#125; ......&#125; 从ExecutorCallAdapterFactory类中可看出通过get方法返回一个CallAdapter对象，从对CallAdapter的实现中可以看出在CallAdapter中的adapt方法返回的是ExecutorCallbackCall对象。它实现了Retrofit中的Call接口。到这里我们也就明白了，当通过代理调用我们创建的接口方法中所返回的Call对象就是这个ExecutorCallbackCall。当我们通过call.enqueue来完成网络请求操作实际上就是调用ExecutorCallbackCall中的enqueue方法。在ExecutorCallbackCall中enqueue又将网络请求委托给OkHttpCall去执行。而这个OkHttpCall正是我们在Retrofit的create方法中所创建的OkHttpCall。由于OKHttp的CallBack接口中的onResponse和onFailure是在子线程中执行的，所以在这时候又通过callbackExecutor将CallBack的onResponse和onFailure切换到主线程中执行。 总结 在这里对于Retrofit2的源码分析就结束了,在这里我们只分析了通过GET方式进行异步请求这一种情况，对于同步，以及POST请求等原理类似，在这就不在进行详细说明。在Retrofit2中我们可以发现它的代码虽然不多，但是却大量用到了Java中的设计模式。很是值得我们学习。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android视图的绘制流程(下)——View的Layout与Draw过程]]></title>
    <url>%2F2016%2F06%2F11%2Fview-draw%2F</url>
    <content type="text"><![CDATA[在上篇文章中Android视图的绘制流程(上)——View的测量对View的Measure过程进行了详细的说明。对于在View的绘制的整个过程中，在对View的大小进行测量以后，便开始确定View的位置并且将其绘制到屏幕上。也就是View的Layout与Draw过程。那么就来看一下是如何实现这两个过程的。 View的Layout过程 上文提到View的绘制流程是从ViewRoot的performTraversals方法开始，那么在View完成测量以后，在performTraversals方法中对performLayout进行调用。在performLayout中可以找到下面这行代码。1host.layout(0, 0, host.getMeasuredWidth(),host.getMeasuredHeight()) 上面这行代码中的host指的就是DecorView，对于这个DecorView我们都知道它是一个继承自FrameLayout的ViewGroup。这个layout方法也就是ViewGroup中的layout方法。下面就来看一下ViewGroup中的这个layout方法。123456789101112@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 从ViewGroup的layout方法我们可以看出它是一个final类型的，也就是说在ViewGroup中的layout方法是不能被子类重写的。ViewGroup中的layout方法中又调用父类的layout方法，也就是View的layout方法。下面就来看一下View的layout方法。12345678910111213141516171819202122@SuppressWarnings(&#123;"unchecked"&#125;)public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ...... &#125; ......&#125; 对于setOpticalFrame实质上也是调用setFrame方法，而setFrame的作用是将View的位置分别保存到mLeft，mTop，mBottom，mRight变量当中。之后在判断是否需要重新布局，如果需要重新布局的话，便调用onLayout方法。 其实在View的Layout过程当中，在View的layout方法是确定View的自身位置，而在View的onLayout方法中则是确定View子元素的位置。所以在这可以看到对于View的onLayout是一个空方法，没有完成任何事情。12protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; 而ViewGroup的onLayout方法则是一个抽象方法，通过具体的ViewGroup实现类来完成对子元素的Layout过程。12@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 下面依然通过一个具体的ViewGroup，来看一下FrameLayout的onLayout方法实现过程，对于FrameLayout的onLayout方法的实现是非常简单的，所以就以FrameLayout为例进行说明。下面来看一下FrameLayout的onLayout方法。1234@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125; 在FrameLayout的onLayout方法中只是调用了layoutChildren方法，从这个方法名便可以看出它的功能就是为FrameLayout的子元素进行布局。下面就来看一下这个layoutChildren方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) &#123; gravity = DEFAULT_CHILD_GRAVITY; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) &#123; childLeft = parentRight - width - lp.rightMargin; break; &#125; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; &#125; switch (verticalGravity) &#123; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; &#125; child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125;&#125; 对于这段代码的逻辑也很简单。通过遍历FrameLayout内所有的子元素，然后获取到View测量后的宽和高，在根据子View的Gravity属性来决定子View在父控件中四个顶点的位置。最后调用子View的layout方法来完成View的整个测量过程。 View的Draw过程 在通过ViewRoot的performTraversals方法完成对View树的整个布局以后，下面便开始将View绘制到手机屏幕上。对于View的Draw过程在ViewRoot的performTraversals方法中通过调用performDraw方法来完成的。在performDraw方法中最终会通过创建一个Canvas对象，并调用View的draw方法，来完成View的绘制。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@CallSuperpublic void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; ......&#125; 在这里从宏观上来对Draw过程进行一下分析。在注释中可以看出对于View的绘制过程分为六步进行的。其中第二步和第五步一般很少用到，可以忽略。剩下几步则为： 绘制背景 drawBackground(canvas) 绘制自身 onDraw(canvas) 绘制 children dispatchDraw(canvas) 绘制装饰 onDrawForeground(canvas) 对于子View的绘制传递是通过dispatchDraw来进行的，在View中的dispatchDraw方法是由ViewGroup来实现的，并且遍历调用所有子元素的draw方法，完成整个View树的绘制过程。 总结 对于View的绘制流程，总共分为三大步。分别是View的测量，布局与绘制。首先通过ViewRoot，对View树根节点进行操作。依次向下遍历，完成它们的Measure，Layout，Draw过程。从而使View展现在手机屏幕上。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android视图的绘制流程(上)——View的测量]]></title>
    <url>%2F2016%2F06%2F10%2Fview-measure%2F</url>
    <content type="text"><![CDATA[View的绘制流程可以分为三大步，它们分别是measure，layout和draw过程。measure表示View的测量过程，用于测量View的宽度和高度；layout用于确定View在父容器的位置；draw则是负责将View绘制到屏幕中。下面主要来看一下View的Measure过程。 测量过程 View的绘制流程是从ViewRoot的performTraversals方法开始的，ViewRoot对应ViewRootImpl类。ViewRoot在performTraversals中会调用performMeasure方法来进行对根View的测量过程。而在performMeasure方法中又会调用View的measure方法。对于View的measure方法它是一个final类型，也就是说这个measure方法不能被子类重写。但是在measure方法中调用了onMeasure方法。所以View的子类可以重写onMeasure方法来实现各自的Measure过程。在这里也就是主要对onMeasure方法进行分析。 MeasureSpec MeasureSpec是View类中的一个静态内部类。一个MeasureSpec封装了父布局传递给子布局的布局要求。每个MeasureSpec都代表着一个高度或宽度的要求。每个MesureSpec都是由specSize和specMode组成，它代表着一个32位的int值，其中高2位代表specSize，低30位代表specMode。 MeasureSpec的测量模式有三种，下面介绍一下这三种测量模式： UNSPECIFIED父容器对子View没有任何的限制，子View可以是任何的大小。 EXACTLY父容器为子View大小指定一个具体值，View的最终大小就是specSize。对应View属性match_parent和具体值。 AT_MOST子View的大小最大只能是specSize，也就是所子View的大小不能超过specSize。对应View属性的wrap_content. 在MeasureSpec中可以通过specSize和specMode并使用makeMeasureSpec方法来创建一个MeasureSpec，还可以通过getMode和getSize来获取MeasureSpec的specMode和specSize。 View的测量过程 在上面已经说到，View的Measure过程是由measure方法来完成的，而measure方法通过调用onMeasure方法来完成View的Measure过程。那么就来看一下onMeasure方法。1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 在View的onMeasure方法中只是调用了setMeasuredDimension方法，setMeasuredDimension方法的作用就是设置View的高和宽的测量值。对于View测量后宽和高的值是通过getDefaultSize方法来获取的。下面就来一下这个getDefaultSize方法。12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 对于MeasureSpec的AT_MOST和EXACTLY模式下，直接返回的就是MeasureSpec的specSize，也就是说这个specSize就是View测量后的大小。而对于在UNSPECIFIED模式下，View的测量值则为getDefaultSize方法中的第一个参数size。这个size所对应的宽和高是通过getSuggestedMinimumWidth和getSuggestedMinimumHeight两个方法获取的。下面就来看一下这两个方法。12345678protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125;protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 在这里可以看到对于View宽和高的取值是根据View是否存在背景进行设置的。在这里以View的宽度来进行说明。若是View没有背景则是View的宽度mMinWidth。对于mMinWidth值得设置可以在XML布局文件中设置minWidth属性，它的默认值为0。也可以通过调用View的setMinimumWidth()方法其赋值。若是View存在背景的话，则取View本身最小宽度mMinWidth和View背景的最小宽度它们中的最大值。 ViewGroup的测量过程 对于ViewGroup的Measure过程，ViewGroup处理Measure自己本身的大小，还需要遍历子View，并调用它们的measure方法，然后各个子元素再去递归执行Measure过程。在ViewGroup中并没有重写onMeasure方法，因为ViewGroup它是一个抽象类，对于不同的具体ViewGroup它的onMeasure方法中所实现的过程不一样。但是在ViewGroup中提供了一个measureChildren方法，对子View进行测量。下面就来看一下这个measureChildren方法。12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125;&#125; 在这里获取ViewGroup中所有的子View。然后遍历ViewGroup中子View并调用measureChild方法来完成对子View的测量。下面看一下measureChild方法。1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 在这段代码中通过getChildMeasureSpec方法获取子View宽和高的MeasureSpec。然后调用子View的measure方法开始对View进行测量。下面就来看一下是如何通过getChildMeasureSpec方法来获取View的MeasureSpec的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 在这段代码对于MeasureSpec的获取主要是根据父容器的MeasureSpec和View本身的LayoutParams。下面通过一张表格来看一下它们之间的对应关系。 layoutParams\specMode EXACTLY AT_MOST UNSPECIFIED dp/px EXACTLY&amp;childSize EXACTLY&amp;childSize EXACTLY&amp;childSize MATCH_PARENT EXACTLY&amp;parentSize AT_MOST&amp;parentSize UNSPECIFIED&amp;0 WRAP_CONTENT AT_MOST&amp;parentSize AT_MOST&amp;parentSize UNSPECIFIED&amp;0 到这里通过getChildMeasureSpec方法获取到子View的MeasureSpec以后，便调用View的Measure方法，开始对View进行测量。 正如刚才说的那样对于ViewGroup它是一个抽象类，并没有重写View的onMeasure方法。但是到具体的ViewGroup时，例如FrameLayout，LinearLayout，RelativeLayout等，它们通过重写onMeasure方法来来完成自身以及子View的Measure过程。下面以FrameLayout为例，看一下的Measure过程。在FrameLayout中，它的Measure过程也算是比较简单，下面就来看一下FrameLayout中的onMeasure方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) &#123; if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) &#123; mMatchParentChildren.add(child); &#125; &#125; &#125; &#125; // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) &#123; maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); &#125; setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) &#123; final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); &#125; else &#123; childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); &#125; final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) &#123; final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); &#125; else &#123; childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); &#125; child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; &#125;&#125; 在这部分代码中逻辑也很简单，主要完成了两件事。首先FrameLayout完成自身的测量过程，然后在遍历子View，执行View的measure方法，完成View的Measure过程。在这里代码比较简单就不在进行详细描述。 总结 最后对View和ViewGroup的Measure过程做一下总结。对于View，它的Measure很简单，在获取到View的高和宽的测量值之后，便为其设置高和宽。而对于ViewGroup来说，除了完成自身的Measure过程以外，还需要遍历子View，完成子View的测量过程。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解在Android中使用]]></title>
    <url>%2F2016%2F06%2F04%2Fannotation-runtime%2F</url>
    <content type="text"><![CDATA[注解（Annotation）也被称为元数据(Metadata)，是在Java SE 5中提供的一个新特性。Annotation可以用来修饰类，属性，方法。在Java中，除了使用系统内置的Annotation以外，用户还能够通过自定义Annotation来实现所需要的功能。下面就来看一下如何使用自定义的Annotation。 元注解 在Java中目前包含及四种元注解。元注解是专门用来负责注解其他的注解。所以自定义注解也是通过元注解来完成的。首先在这里来看一下Java中的四种元注解。 @Target@Target表示Annotation可用在什么地方。其中的ElementType取值如下：TYPE：类，接口或者是enum声明FIELD：域声明（包括enum实例）METHOD：方法声明PARAMETER：参数声明CONSTRUCTOR：构造器声明LOCAL_VARIABLE：局部变量声明ANNOTATION_TYPE：注解类型声明PACKAGE：包声明 @Retention@Retention表示在什么级别保存该注解信息。其中RetentionPolicy取值如下：SOURCE：只在源码中保留，该注解将会被编译器丢掉CLASS：注解在class文件中可用，但是会被VM丢弃RUNTIME：VM会在运行时保留注解，这时可以通过反射读取注解信息。 @Documented@Documented表示在Javadocs中包含这个注解。 @Inherited@Inherited表示允许子类继承父类中的注解。 自定义注解实现View注入 下面我们就通过一个例子来看一下如何自定义注解以及对自定义注解的使用。在Android开发中通常会在Activity中通过setContentView来为Activity指定Layout，也会经常通过findViewById来回去View控件，并且更麻烦的就是通过setOnClickListener来为其设置点击事件。我们就通过注解的方式来实现这三个功能从而简化我们的代码，增加代码的可读性。下面就来看一下具体的代码实现。 定义一个ContentView注解来为Activity指定其Layout。123456789101112package com.ljd.annotation.inject;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface ContentView &#123; int value();&#125; 定义一个InjectView注解实现Activity中View的注入。123456789101112package com.ljd.annotation.inject;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Inject &#123; int value();&#125; 定义一个OnClick注解实现View的事件注入。12345678910111213package com.ljd.annotation.inject;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface OnClick &#123; int[] value();&#125; 在这里我们采用int类型和int数组作为注解中的值。需要注意是并不是所有类型都适用于注解元素。注解元素的可用类型如下所示： 所有基本类型（int,float,boolean等） String Class enum Annotation 以上类型的数组 在上面这三个自定义注解中它们分别修饰了类、属性和方法。并且在运行时保留这些注解，所以我们便可以通过反射对这些注解进行解析。下面就开看一下是如何通过反射来解析这些注解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.ljd.annotation.inject;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ViewInject &#123; private static Class&lt;?&gt; clazz; public static void inject(Activity activity)&#123; //获取activity的Class类 clazz = activity.getClass(); injectContent(activity); injectView(activity); injectEvent(activity); &#125; public static void unInject()&#123; clazz = null; &#125; /** * 对ContentView注解进行解析 * @param activity */ private static void injectContent(Activity activity)&#123; //取的Activity中的ContentView注解 ContentView contentView = clazz.getAnnotation(ContentView.class); if (contentView != null)&#123; //取出ContentView注解中的值 int id = contentView.value(); try &#123; //获取Activity中setContentView方法,执行setContentView方法为Activity设置ContentView //在这一步中我们也可以直接使用 activity.setContentView(id) 来设置ContentView clazz.getMethod("setContentView",Integer.TYPE).invoke(activity,id); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 对InjectView注解进行解析 * @param activity */ private static void injectView(Activity activity)&#123; Field[] fields = clazz.getDeclaredFields(); for (Field field : fields)&#123; Inject inject = field.getAnnotation(Inject.class); if (inject != null)&#123; int id = inject.value(); try &#123; //这一步中同样也能够使用 Object view = activity.findViewById(id) 来获取View Object view = clazz.getMethod("findViewById",Integer.TYPE).invoke(activity,id); field.set(activity,view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 对OnClick注解进行解析 * @param activity */ private static void injectEvent(Activity activity)&#123; Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; OnClick onClick = method.getAnnotation(OnClick.class); if (onClick != null)&#123; int[] ids = onClick.value(); MyInvocationHandler handler = new MyInvocationHandler(activity,method); //通过Java中的动态代理来执行View.OnClickListener Object listenerProxy = Proxy.newProxyInstance( View.OnClickListener.class.getClassLoader(), new Class&lt;?&gt;[] &#123; View.OnClickListener.class &#125;, handler); for (int id : ids) &#123; try &#123; Object view = clazz.getMethod("findViewById",Integer.TYPE).invoke(activity,id); Method listenerMethod = view.getClass() .getMethod("setOnClickListener", View.OnClickListener.class); listenerMethod.invoke(view, listenerProxy); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; static class MyInvocationHandler implements InvocationHandler &#123; private Object target = null; private Method method = null; public MyInvocationHandler(Object target,Method method) &#123; super(); this.target = target; this.method = method; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return this.method.invoke(target,args); &#125; &#125;&#125; 在这里执行View的点击事件时是通过Java中的动态代理来执行的。对于Java动态代理的使用参见Java设计模式之代理模式这篇文章。下面就来看一下如何使用我们自定义的这些注解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ljd.annotation;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import com.ljd.annotation.inject.ContentView;import com.ljd.annotation.inject.Inject;import com.ljd.annotation.inject.OnClick;import com.ljd.annotation.inject.ViewInject;@ContentView(R.layout.activity_main)public class MainActivity extends AppCompatActivity &#123; @Inject(R.id.test_text) TextView textView; @Inject(R.id.test_btn) Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ViewInject.inject(this); textView.setText("hello word"); button.setText("test"); &#125; @OnClick(&#123;R.id.test_btn,R.id.test_text&#125;) public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.test_btn: Toast.makeText(this,"test onClick",Toast.LENGTH_SHORT).show(); break; case R.id.test_text: Toast.makeText(this,"hello word",Toast.LENGTH_SHORT).show(); break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ViewInject.unInject(); &#125;&#125; 下面是布局文件12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="@dimen/activity_vertical_margin" tools:context="com.ljd.annotation.MainActivity"&gt; &lt;TextView android:id="@+id/test_text" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;Button android:id="@+id/test_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/LinearLayout&gt; 总结 对于这个例子目的主要是为了对自定义注解以及Java反射的一个学习，对于实际应用并没有多大的意义，并且在我们的应用中应当避免对反射的使用，因为使用反射会大大降低我们应用的执行效率。对于View的注入我们可以采用JakeWharton的butterknife框架。 源码下载]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android官方MVP架构解读]]></title>
    <url>%2F2016%2F05%2F22%2Farch-mvp%2F</url>
    <content type="text"><![CDATA[对于MVP (Model View Presenter)架构是从著名的MVC(Model View Controller)架构演变而来的。而对于Android应用的开发中本身可视为一种MVC架构。通常在开发中将XML文件视为MVC中的View角色，而将Activity则视为MVC中的Controller角色。不过更多情况下在实际应用开发中Activity不能够完全充当Controller，而是Controller和View的合体。于是Activity既要负责视图的显示，又要负责对业务逻辑的处理。这样在Activity中代码达到上千行，甚至几千行都不足为其，同时这样的Activity也显得臃肿不堪。所以对于MVC架构并不很合适运用于Android的开发中。下面就来介绍一下MVP架构以及看一下google官方给出的MVP架构示例。 MVP架构简介 对于一个应用而言我们需要对它抽象出各个层面，而在MVP架构中它将UI界面和数据进行隔离，所以我们的应用也就分为三个层次。 View: 对于View层也是视图层，在View层中只负责对数据的展示，提供友好的界面与用户进行交互。在Android开发中通常将Activity或者Fragment作为View层。 Model: 对于Model层也是数据层。它区别于MVC架构中的Model，在这里不仅仅只是数据模型。在MVP架构中Model它负责对数据的存取操作，例如对数据库的读写，网络的数据的请求等。 Presenter:对于Presenter层他是连接View层与Model层的桥梁并对业务逻辑进行处理。在MVP架构中Model与View无法直接进行交互。所以在Presenter层它会从Model层获得所需要的数据，进行一些适当的处理后交由View层进行显示。这样通过Presenter将View与Model进行隔离，使得View和Model之间不存在耦合，同时也将业务逻辑从View中抽离。 下面通过MVP结构图来看一下MVP中各个层次之间的关系。 在MVP架构中将这三层分别抽象到各自的接口当中。通过接口将层次之间进行隔离，而Presenter对View和Model的相互依赖也是依赖于各自的接口。这点符合了接口隔离原则，也正是面向接口编程。在Presenter层中包含了一个View接口，并且依赖于Model接口，从而将Model层与View层联系在一起。而对于View层会持有一个Presenter成员变量并且只保留对Presenter接口的调用，具体业务逻辑全部交由Presenter接口实现类中处理。 官方MVP架构分析项目介绍 对于MVP架构有了一些的了解，而在前端时间Google给出了一些App开发架构的实现。 项目地址为：https://github.com/googlesamples/android-architecture. 在这里进入README看一下这次Google给出那些Android开发架构的实现。 对于上面五个开发架构的实现表示到目前为止是已经完成的项目，而下面两个则表示正在进行的中的项目。现在首先来介绍一下这几个架构。 todo-mvp: 基础的MVP架构。 todo-mvp-loaders:基于MVP架构的实现，在获取数据的部分采用了loaders架构。 todo-mvp-databinding: 基于MVP架构的实现，采用了数据绑定组件。 todo-mvp-clean: 基于MVP架构的clean架构的实现。 todo-mvp-dagger2: 基于MVP架构，采用了依赖注入dagger2。 dev-todo-mvp-contentproviders: 基于mvp-loaders架构，使用了ContenPproviders。 dev-todo-mvp-rxjava: 基于MVP架构，对于程序的并发处理和数据层（MVP中的Model）的抽象。 从上述的介绍中可以看出，对于官方给出所有的架构的实现最终都是基于MVP架构。所以在这里就对上面的基础的MVP架构todo-mvp进行分析。 项目结构的分析 对于这个项目，它实现的是一个备忘录的功能。对于工作中未完成的任务添加到待办任务列表中。我们能够在列表中可以对已完成的任务做出标记，能够进入任务详细页面修改任务内容，也能够对已完成的任务和未完成的任务数量做出统计。 首先在这里来看一下todo-mvp整体的项目结构 从上图中可以看出，项目整体包含了一个app src目录，四个测试目录。在src目录下面对代码的组织方式是按照功能进行划分。在这个项目中包含了四个功能，它们分别是：任务的添加编辑(addedittask),任务完成情况的统计(statistics),任务的详情(taskdetail),任务列表的显示(tasks)。对于data包它是项目中的数据源，执行数据库的读写，网络的请求操作都存放在该包内，也是MVP架构中的Model层。而util包下面则是存放一些项目中使用到的工具类。在最外层存放了两接口BasePresenter和BaseView。它们是Presenter层接口和View层接口的基类，项目中所有的Presenter接口和View层接口都继承自这两个接口。 现在进入功能模块内看下在模块内部对类是如何划分的。在每个功能模块下面将类分作xxActivity,xxFragment,xxPresenter,xxContract。也正是这些类构成了项目中的Presenter层与View层。下面就来分析在这个项目中是如何实现MVP架构。 MVP架构的实现 在这里只从宏观上关注MVP架构的实现,对于代码的内部细节在就不在具体分析。那么就以任务的添加和编辑这个功能来看一下Android官方是如何实现MVP架构。 Model层的实现 首先我们从MVP架构的最内层开始分析，也就是对应的Model层。在这个项目中对应的data包下的内容。在data下对数据库等一些数据源的封装。对于Presenter层提供了TasksDataSource接口。在这里看一下这个TasksDataSource接口。123456789101112131415161718192021222324public interface TasksDataSource &#123; interface LoadTasksCallback &#123; void onTasksLoaded(List&lt;Task&gt; tasks); void onDataNotAvailable(); &#125; interface GetTaskCallback &#123; void onTaskLoaded(Task task); void onDataNotAvailable(); &#125; void getTasks(@NonNull LoadTasksCallback callback); void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback); void saveTask(@NonNull Task task); ......&#125; TasksDataSource接口的实现是TasksLocalDataSource，在TasksDataSource中的方法也就是一些对数据库的增删改查的操作。而在TasksDataSource的两个内部接口LoadTasksCallback和GetTaskCallback是Model层的回调接口。它们的真正实现是在Presenter层。对于成功获取到数据后变或通过这个回调接口将数据传递Presenter层。同样，若是获取失败同样也会通过回调接口来通知Presenter层。下面来看一下TasksDataSource的实现类。1234567891011121314151617181920212223242526272829303132333435public class TasksLocalDataSource implements TasksDataSource &#123; ...... @Override public void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback) &#123; //根据taskId查训出相对应的task ...... if (task != null) &#123; callback.onTaskLoaded(task); &#125; else &#123; callback.onDataNotAvailable(); &#125; &#125; @Override public void saveTask(@NonNull Task task) &#123; checkNotNull(task); SQLiteDatabase db = mDbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(TaskEntry.COLUMN_NAME_ENTRY_ID, task.getId()); values.put(TaskEntry.COLUMN_NAME_TITLE, task.getTitle()); values.put(TaskEntry.COLUMN_NAME_DESCRIPTION, task.getDescription()); values.put(TaskEntry.COLUMN_NAME_COMPLETED, task.isCompleted()); db.insert(TaskEntry.TABLE_NAME, null, values); db.close(); &#125; ......&#125; 在这里我们针对任务的添加和编辑功能，所以省略很多代码。可以看出在TasksLocalDataSource中实现的getTask方法，在这个方法中传入TasksDataSource内的GetTaskCallback回调接口。在getTask方法的实现可以看出在查询到Task以后调用回调方法，若是在Presenter层中实现了这两个回调方法，便将数据传递到Presenter层。而对于查询到的Task为空的时候也是通过回调方法执行对应的操作。 同样对于通过网络请求获取到数据也是一样，对于成功请求到的数据可以通过回调方法将数据传递到Presenter层，对于网络请求失败也能够通过回调方法来执行相对应的操作。 Presenter与View层提供的接口 由于在Presenter和View层所提供的接口在一个类中，在这里就先来查看他们对外所提供了哪些接口。首先观察一下两个基类接口BasePresenter和BaseView。 BasePresenter1234567package com.example.android.architecture.blueprints.todoapp;public interface BasePresenter &#123; void start();&#125; 在BasePresenter中只存在一个start方法。这个方法一般所执行的任务是在Presenter中从Model层获取数据，并调用View接口显示。这个方法一般是在Fragment中的onResume方法中调用。 BaseView1234567package com.example.android.architecture.blueprints.todoapp;public interface BaseView&lt;T&gt; &#123; void setPresenter(T presenter);&#125; 在BaseView中只有一个setPresenter方法，对于View层会存在一个Presenter对象。而setPresenter正是对View中的Presenter进行初始化。 AddEditTaskContract 在Android官方给出的MVP架构当中对于Presenter接口和View接口提供的形式与我们平时在网上所见的有所不同。在这里将Presenter中的接口和View的接口都放在了AddEditTaskContract类里面。这样一来我们能够更清晰的看到在Presenter层和View层中有哪些功能，方便我们以后的维护。下面就来看一下这个AddEditTaskContract类。123456789101112131415161718192021222324public interface AddEditTaskContract &#123; interface View extends BaseView&lt;Presenter&gt; &#123; void showEmptyTaskError(); void showTasksList(); void setTitle(String title); void setDescription(String description); boolean isActive(); &#125; interface Presenter extends BasePresenter &#123; void createTask(String title, String description); void updateTask( String title, String description); void populateTask(); &#125;&#125; 在这里很清晰的可以看出在View层中处理了一些数据显示的操作，而在Presenter层中则是对Task保存，更新等操作。 Presenter层的实现 下面就来看一下在Presenter是如何实现的。1234567891011121314151617181920212223242526272829303132333435363738394041public class AddEditTaskPresenter implements AddEditTaskContract.Presenter, TasksDataSource.GetTaskCallback &#123; ...... public AddEditTaskPresenter(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView) &#123; mTaskId = taskId; mTasksRepository = checkNotNull(tasksRepository); mAddTaskView = checkNotNull(addTaskView); mAddTaskView.setPresenter(this); &#125; @Override public void start() &#123; if (mTaskId != null) &#123; populateTask(); &#125; &#125; ...... @Override public void populateTask() &#123; if (mTaskId == null) &#123; throw new RuntimeException("populateTask() was called but task is new."); &#125; mTasksRepository.getTask(mTaskId, this); &#125; @Override public void onTaskLoaded(Task task) &#123; // The view may not be able to handle UI updates anymore if (mAddTaskView.isActive()) &#123; mAddTaskView.setTitle(task.getTitle()); mAddTaskView.setDescription(task.getDescription()); &#125; &#125; ......&#125; 在这里可以看到在AddEditTaskPresenter中它不仅实现了自己的Presenter接口，也实现了GetTaskCallback的回调接口。并且在Presenter中包含了Model层TasksDataSource的对象mTasksRepository和View层AddEditTaskContract.View的对象mAddTaskView。于是整个业务逻辑的处理就担负在Presenter的身上。 从Presenter的业务处理中可以看出，首先调用Model层的接口getTask方法，通过TaskId来查询Task。在查询到Task以后，由于在Presenter层中实现了Model层的回调接口GetTaskCallback。这时候在Presenter层中就通过onTaskLoaded方法获取到Task对象，最后通过调用View层接口实现了数据的展示。 View层的实现 对于View的实现是在Fragment中，而在Activity中则是完成对Fragment的添加，Presenter的创建操作。下面首先来看一下AddEditTaskActivity类。12345678910111213141516171819202122232425public class AddEditTaskActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.addtask_act); ...... if (addEditTaskFragment == null) &#123; addEditTaskFragment = AddEditTaskFragment.newInstance(); ...... ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), addEditTaskFragment, R.id.contentFrame); &#125; // Create the presenter new AddEditTaskPresenter( taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment); &#125; ......&#125; 对于Activity的提供的功能也是非常的简单，首先创建Fragment对象并将其添加到Activity当中。之后创建Presenter对象，并将Fragment也就是View传递到Presenter中。 下面再来看一下View的实现，也就是Fragment。123456789101112131415161718192021222324public class AddEditTaskFragment extends Fragment implements AddEditTaskContract.View &#123; ...... @Override public void onResume() &#123; super.onResume(); mPresenter.start(); &#125; @Override public void setPresenter(@NonNull AddEditTaskContract.Presenter presenter) &#123; mPresenter = checkNotNull(presenter); &#125; ...... @Override public void setTitle(String title) &#123; mTitle.setText(title); &#125; ......&#125; 在这对于源码就不在过多贴出。在Fragment中，通过setPresenter获取到Presenter对象。并通过调用Presenter中的方法来实现业务的处理。而在Fragment中则只是对UI的一些操作。这样一来对于Fragment类型的代码减少了很多，并且逻辑更加清晰。 我们注意到View层的实现是通过Fragment来完成的。对于View的实现为什么要采用Fragment而不是Activity。来看一下官方是如何解释的。12 The separation between Activity and Fragment fits nicely with this implementation of MVP: the Activity is the overall controller that creates and connects views and presenters.Tablet layout or screens with multiple views take advantage of the Fragments framework. 在这里官方对于采用Fragment的原因给出了两种解释。 通过Activity和Fragment分离非常适合对于MVP架构的实现。在这里将Activity作为全局的控制者将Presenter于View联系在一起。 采用Fragment更有利于平板电脑的布局或者是多视图屏幕。 总结 通过MVP架构的使用可以看出对于各个层次之间的职责更加单一清晰，同时也很大程度上降低了代码的耦合度。对于官方MVP架构示例，google也明确表明对于他们所给出的这些架构示例只是作为参考，而不是一个标准。所以对于基础的MVP架构有更大的扩展空间。例如综合google给出的示例。我们可以通过在MVP架构的基础上使用dagger2，rxJava等来构建一个Clean架构。也是一个很好的选择。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0源码解读]]></title>
    <url>%2F2016%2F05%2F21%2Feventbus3.0-source%2F</url>
    <content type="text"><![CDATA[EventBus是我们在项目当中最常用的开源框架之一。对于EventBus的使用方法也是非常的简单。然而EventBus内部的实现原理也不是很复杂。在这里便针对EventBus3.0的源码进行一下详细的分析。对于EventBus的详细使用可以参考EventBus3.0使用详解这篇文章。 EventBus3.0源码解析 从下面这个图中可以看到，对于EventBus的工作过程很简单，用一句话概括为：事件被提交到EventBus后进行查找所有订阅该事件的方法并执行这些订阅方法。 获取EventBus对象无论是订阅者的注册，还是事件的发布首先必须要获得EventBus对象。那么下面就来看一下如何获取EventBus对象。可以通过EventBus.getDefault()获得EventBus对象。然后就来看一下这个getDefault方法。 12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 在这通过单例模式获取EventBus对象。下面就来看一下EventBus的构造方法。 123public EventBus() &#123; this(DEFAULT_BUILDER); &#125; 1234567891011121314151617181920212223EventBus(EventBusBuilder builder) &#123; //以事件类型作为Key，Subscription的List集合作为Value的Map集合 subscriptionsByEventType = new HashMap&lt;&gt;(); //订阅者作为Key,订阅事件作为Value的Map集合 typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); //Handler对象，用于切换到主线程中执行订阅方法 mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); //Runable对象 backgroundPoster = new BackgroundPoster(this); //Runable对象 asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 我们可以通过构造一个EventBusBuilder，来对EventBus进行配置。并且在这里注意到对于EventBus可以采用单实例模式获取，但是EventBus的构造方法为公共的。很显然也就是说明了在应用中可以存在多个EventBus，对于存在多个的EventBus情况下，它们之间相互独立，会发布和订阅各自的事件进行接收执行。 订阅者的注册 在获取到EventBus对象以后，便可以将订阅者注册到EventBus中。下面就再来看一下register方法。123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 在这里可以看到register这个方法中的代码很简短，但是在它的内容却一点也不简单。对于register中的参数，就是我们的订阅者，也就是我们经常传入的this对象。在这个方法中主要完成了两件事情。首先通过findSubscriberMethods方法来查找订阅者中所有的订阅方法。然后遍历订阅者的订阅方法来完成订阅者的订阅操作。下面来详细的分析这两步的实现过程。 订阅方法的查找过程 首先在这里来看一下findSubscriberMethods这个方法是如何查找订阅者的订阅方法。在这先描述一下SubscriberMethod类。对于SubscriberMethod类中，主要就是用保存订阅方法的Method对象，线程模式，事件类型，优先级，是否粘性事件等属性。下面就来看一下findSubscriberMethods方法。1234567891011121314151617181920212223List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //从缓存中获取SubscriberMethod集合 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //ignoreGeneratedIndex是否忽略注解器生成的MyEventBusIndex if (ignoreGeneratedIndex) &#123; //通过反射获取subscriberMethods subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //通过注解器生成的MyEventBusIndex信息获取subscriberMethods, //如果没有配置MyEventBusIndex，依然通过通过反射获取subscriberMethods subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; 在这个方法里面的逻辑依然也是十分的清晰。首先会从缓存中查找是否有订阅方法的集合，若是存在则直接返回缓存中的该订阅者的订阅方发集合。若是不存在，便从订阅者中找出全部的订阅方法。对于ignoreGeneratedIndex属性表示是否忽略注解器生成的MyEventBusIndex（在项目重新rebuild以后，会自动生成在build文件夹下，类名也可以自己定义）。如何生成MyEventBusIndex类以及他的使用，可以参考官方文档。ignoreGeneratedIndex的默认值为false，可以通过EventBusBuilder来设置它的值。在这里会根具ignoreGeneratedIndex的值来采用不同的方式获取订阅方法的集合subscriberMethods。在获得subscriberMethods以后，如果订阅者中不存在@Subscribe注解且为public的订阅方法，则会抛出异常。这也就是说对于订阅者若是要成功注册到EventBus中，在订阅者中必须存在通过@Subscribe注解且为public类型的订阅方法。在成功获取到订阅方法集合以后，便将订阅方法集合添加到缓存中。对于这个缓存它是以订阅者的类作为key，订阅方法集合作为value的Map类型。 由于在我们的项目中经常通过EventBus单例模式来获取默认的EventBus对象。所以就针对ignoreGeneratedIndex为false的情况下看一下EventBus是如何获得订阅方法集合的。在这里调用了findUsingInfo方法。下面就来看一下findUsingInfo这个方法。 123456789101112131415161718192021222324private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; //创建和初始化FindState对象 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //获取订阅者信息，没有配置MyEventBusIndex返回null findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //通过反射来查找订阅方法 findUsingReflectionInSingleClass(findState); &#125; //进入父类查找订阅方法 findState.moveToSuperclass(); &#125; //回收处理findState，并返回订阅方法的List集合 return getMethodsAndRelease(findState);&#125; 在FindState里面，它保存了一些订阅者的方法以及对订阅方法的校验。通过initForSubscriber初始化了FindState的clazz属性。于是下面便进入while循环当中。通过getSubscriberInfo方法来获取订阅者信息。在我们开始查找订阅方法的时候并没有忽略注解器为我们生成的索引MyEventBusIndex，如果我们通过EventBusBuilder配置了MyEventBusIndex，便会获取到subscriberInfo。而在MyEventBusIndex中会将订阅方法相关的信息存放在SubscriberMethodInfo类中，这个时候就不在需要通过注解进行获取订阅方法。如果没有配置MyEventBusIndex，便会执行findUsingReflectionInSingleClass方法，将订阅方法保存到findState中。最后再通过getMethodsAndRelease方法对findState做回收处理并反回订阅方法的List集合。对于MyEventBusIndex的配置它是一个可选项。它的执行过程在这里就不在进行详细的介绍，下面就来看一下如何通过反射来查找订阅方法，也就是看一下findUsingReflectionInSingleClass的执行过程。 12345678910111213141516171819202122232425262728293031323334353637383940private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; //对订阅方法的类型进行过滤 int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //定于方法中只能有一个参数 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; //查找包含Subscribe的注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //保存到findState对象当中 Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125;&#125; 这段代码的执行过程其实并不是很复杂。在这里主要是使用了Java的反射和对注解的解析。首先通过反射来获取订阅者中所有的方法。并根据方法的类型，参数和注解来找到订阅方法。找到订阅方法后将订阅方法相关信息保存到FindState当中。到这里便完成对订阅者中所有订阅方法的查找。 订阅者的注册过程 在查找完所有的订阅方法以后便开始对所有的订阅方法进行注册，下面就开看一下这个订阅方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //获取订阅方法中的订阅事件 Class&lt;?&gt; eventType = subscriberMethod.eventType; //创建一个Subscription来保存订阅者和订阅方法 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //获取当前订阅事件中Subscription的List集合 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; //该事件对应的Subscription的List集合不存在，则重新创建并保存在subscriptionsByEventType中 subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //判断是订阅者是否已经被注册 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventType); &#125; &#125; //将newSubscription按照订阅方法的优先级插入到subscriptions中 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //通过订阅者获取该订阅者所订阅事件的集合 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; //将当前的订阅事件添加到subscribedEvents中 subscribedEvents.add(eventType); //粘性事件的处理，在这里不做详细分析 if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 在这个方法中便是订阅者真正的注册过程。首先会根据subscriber和subscriberMethod来创建一个Subscription对象。之后根据事件类型获取或创建一个Subscription集合subscriptions并添加到typesBySubscriber对象中。最后将刚才创建的Subscription对象添加到subscriptions之中。于是这样就完成了一次订阅者的注册操作。 事件的发送 现在来看一下事件的整个发送过程。在获取到EventBus对象以后，通过post方法来进行对事件的提交，下面就来看一下整个post方法是如何对事件进行提交的。12345678910111213141516171819202122232425public void post(Object event) &#123; //PostingThreadState保存着事件队列和线程状态信息 PostingThreadState postingState = currentPostingThreadState.get(); //获取事件队列，并将当前事插入到事件队列中 List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; //当前线程是否为主线程 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; //处理队列中的所有事件 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 在PostingThreadState中保存了事件队列，以及线程的一些状态信息。首先从PostingThreadState对象中取出事件队列，然后再将当前的事件插入到事件队列当中。最后将队列中的事件依次交由postSingleEvent方法进行处理，并移除该事件。下面就在进入postSingleEvent方法中看一下。1234567891011121314151617181920212223242526private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; //获取所有事件并存放在List中，这里表示事件存在继承关系，向上查找事件的父类 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); //处理事件 int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //找不到该事件时的异常处理 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; 对于eventInheritance表示是否向上查找事件的父类。它的默认值为true，可以通过在EventBusBuilder中来进行配置。当eventInheritance为true时，则通过lookupAllEventTypes找到所有的父类事件并存发在List中，然后通过postSingleEventForEventType方法对事件逐一处理。下面就跟进到postSingleEventForEventType方法中查看一下。12345678910111213141516171819202122232425262728private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; //同步取出该事件对应的Subscription集合 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; //对事件进行处理 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; 还记得在订阅者进行注册时候，以订阅事件作为Key，将Subscription的List集合作为Value保存到了一个Map集合当中。而就在这个方法中通过事件类型取出Subscription的List集合，然后调用了postToSubscription方法来处理事件并执行订阅方法。下面再来看一下postToSubscription方法。1234567891011121314151617181920212223242526private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125;&#125; 这一路对订阅事件的分发，总算差不多要到头了。在这里取出订阅方法的线程模式，之后根据订阅方法所设置的线程模式来选择线程来执行订阅方法的线程。订阅方法的线程模式为MAIN的时候。提交事件的线程是主线程则直接执行invokeSubscriber方法。否则加入到mainThreadPoster对象的队列中，而mainThreadPoster对象他是HandlerPoster对象。HandlerPoster继承自Handler，也即是通过Handler将订阅方法切换到主线程执行。 当执行订阅方法需要在子线程中的时候。EventBus是通过Java中的newCachedThreadPool线程池来创建线程并执行的任务。对于Java中的线程池可以参考Java中的线程池这篇文章。而BackgroundPoster和AsyncPoster它们都是一个Runable对象。而执行它们们run方法也是在enqueue方法中。 总结 从整个EventBus的执行过程来它，他实际上就是一个典型的观察者模式。通过对事件的发布与订阅，实现了一种一对多的依赖关系，并有效的为我们事件的发送者与接收者之间进行了解耦。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之代理模式]]></title>
    <url>%2F2016%2F05%2F17%2Fdesign-pattern-proxy%2F</url>
    <content type="text"><![CDATA[代理模式(Proxy Pattern)也称作为委托模式。在生活中我们也是处处可见，例如通过设置代理进行上网，委托律师来打官司，又或者是代理某个品牌来创业等等。而在开发中也是被经常被使用到的一种设计模式。对于代理模式的定义为:为其他对象提供一种代理以控制对这个对象的访问。对于代理模式可以分为两大类，分别是静态代理和动态代理。下面就开始对这两种类型的代理模式进行详细介绍。 静态代理 在这里通过一个场景来展开描述代理模式。现在我想按照自己想要的配置来组装一台电脑。于是我将主板，内存条，显卡，机箱，显示器等所有的配件都买回来了。可是这个时候遇到了一个难题，我不会组装呀。于是我带着这些配件去找专业人士为我组装电脑。对于电脑的组装内部细节部分步骤比较多。在这里作为举例说明，将组装电脑的过程主要分为三个步骤。这三个步骤分别是安装主机，设置显示器，安装操作系统。 简单实现 那么就针对上述场景，来实现代理模式。首先来看一下它的UML类图。 对于这个类图可以看出，对于上述场景代理模式的实现也是非常的简单。在这里定义了一个组装电脑的接口。在这个接口里面是一些电脑组装的实现步骤。而后又定义了一个客户类和一个专业人士的代理类，分别实现这个接口。之后组装电脑的这些事情全部都交由这个专业人士代理类来实现。下面就来看一下具体的代码实现。 这里定义一个组装电脑的接口,在接口里面分别定义了对主机的安装，显示屏的设置和操作系统的安装。12345public interface IHomebuiltComputer &#123; void installHost(); void setDisplay(); void installOS();&#125; 下面这个是客户类，实现了IHomebuiltComputer接口。是一些对电脑安装的具体操作步骤。123456789101112131415161718public class Customer implements IHomebuiltComputer&#123; @Override public void installHost() &#123; System.out.println("安装主机"); &#125; @Override public void setDisplay() &#123; System.out.println("安装显示器"); &#125; @Override public void installOS() &#123; System.out.println("安装操作系统"); &#125;&#125; 最后看一下这个代理类。这个代理类同样也继承自IHomebuiltComputer接口。在这个代理类中还持有被代理的引用，也就是Customer类。通过调用被代理类Customer的方法，来实现代理功能。123456789101112131415161718192021222324public class ProfessionalProxy implements IHomebuiltComputer&#123; private IHomebuiltComputer customer; public ProfessionalProxy(IHomebuiltComputer customer) &#123; this.customer = customer; &#125; @Override public void installHost() &#123; this.customer.installHost(); &#125; @Override public void setDisplay() &#123; this.customer.setDisplay(); &#125; @Override public void installOS() &#123; this.customer.installOS(); &#125;&#125; 下面就通过一个Client类，来看一下具体的调用执行关系。1234567891011public class Client &#123; public static void main(String[] args) &#123; IHomebuiltComputer customer = new Customer(); IHomebuiltComputer proxy = new ProfessionalProxy(customer); proxy.installHost(); proxy.setDisplay(); proxy.installOS(); &#125;&#125; 在这个Client类中，可以看到，所有的事情都交由代理类处理了。然后在看一下运行结果。 对于这个代理类中，也能够实现不同的接口来完成不同功能的整合。在这里就不在详细赘述。下面就来看一下代理模式的通用代码。 静态代理通用模板 在这里首先来看一下代理模式的通用类图。 ISubject（抽象主题类）:在这个类中，主要声明真实主题类和代理类的共同方法。它既可以是一个接口也可以是一个抽象类。 RealSubject（真实主题类）:这是被代理类，具体的业务实现都在这个类中。 Proxy（代理类）:这是一个代理类，在这个代理类中它持有真实主题类的对象。通过调用真实主题类的方法来实现代理。 下面来看一下通用代码： 抽象主题类123public interface ISubject &#123; public void request();&#125; 实现抽象主题的真实主题类1234567public class RealSubject implements ISubject&#123; @Override public void request() &#123; System.out.println("我是真实对象"); &#125;&#125; 代理类1234567891011121314public class Proxy implements ISubject&#123; private ISubject subject; public Proxy(ISubject subject) &#123; this.subject = subject; &#125; @Override public void request() &#123; this.subject.request(); &#125;&#125; 客户类1234567public class Client &#123; public static void main(String[] args) &#123; ISubject subject = new RealSubject(); Proxy proxy = new Proxy(subject); proxy.request(); &#125;&#125; 以上就是静态代理类的实现。在前面的一系列有关Android的IPC机制文章中，在分析AIDL的实现原理的时，系统根据用户写的AIDL接口自动创建了Java接口，而在这个Java接口中通过Binder与Service建立连接的过程中使用的就是静态代理模式。详细内容见Android的IPC机制（二）——AIDL实现原理简析这篇文章。 从上面的分析出可以看出，对静态代理模式，代理者的代码都是通过程序员或者是通过一些自动化的工具生成的固定代码(例如刚才所提到的AIDL的实现)然后再对他们进行编译。这样也就意味着在我们的代码运行之前代理类的Class文件就已经存在了。 动态代理 在这里再来看一下动态代理。对于动态代理，在程序运行时，动态的创建一个代理类以及代理类的对象，当然也能够创建一个实现多个接口的代理类。在动态代理类中使用了Java中的反射机制，来生成了代理类的对象。并且Java也为我们提供了一个动态代理接口InvocationHandler，对被代理类的方法进行代理。在使用动态代理类时，必须实现InvocationHandler接口。 对于InvocationHandler接口，我们必须手动实现的它的invoke方法，正是在InvocationHandler中的invoke方法中完成了对真实方法的调用。也就是说所有被代理的方法都是交由这个InvocationHandler进行处理。在这里首先看一下这个InvocationHandler接口。 12345package java.lang.reflect;public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 从上面接口中我们可以看出在InvocationHandler接口中只有一个invoke方法。在invoke方法中，其中proxy参数表示代理类的实例；method参数表示被调用的方法对象;args参数表示被调用方法对象的参数。 下面就以上面的情形通过动态代理来实现。在这里需要添加一个InvocationHandler接口，以及它的实现类。于是在这里对上面的类图进行一下修改。 下面就来看一下具体的代码实现。对于上面的IHomebuiltComputer接口和Customer不需要改变。所以在这里只需要一个实现InvocationHandler接口的CustomerHandler类。然后在对Client做一次修改即可。在这里看一下CustomerHandler类。123456789101112131415161718import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class CustomerHandler implements InvocationHandler&#123; private Object obj = null; public CustomerHandler(Object object) &#123; this.obj = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // TODO Auto-generated method stub return method.invoke(this.obj, args); &#125;&#125; 再看一下Client类。1234567891011121314151617import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class Client &#123; public static void main(String[] args) &#123; IHomebuiltComputer homebuiltComputer = new Customer(); InvocationHandler handler = new CustomerHandler(homebuiltComputer); IHomebuiltComputer proxy = (IHomebuiltComputer)Proxy.newProxyInstance(homebuiltComputer.getClass().getClassLoader(), new Class[]&#123;IHomebuiltComputer.class&#125;, handler); proxy.installHost(); proxy.setDisplay(); proxy.installOS(); &#125;&#125; 这样就通过动态代理模式实现了上述的情形。对于运行结果与上面一样，在这里就不在贴出。下面来看一下动态代理的通用模板。 通过DynamicProxy，RealSubject可以在运行时动态改变，需要控制的接口Subject也可以在运行时改变，控制的方式DynamicSubject类也可以动态改变，从而实现了非常灵活的动态代理关系。 动态代理通用模板 在这里再看一下动态代理的通用类图。 在这里通过DynamicProxy来创建一个Proxy对象。并且它依赖于InvocationHandler。并且是InvocationHandler来进行实际的业务处理。下面就来看一下动态代理的通用代码。 抽象主题类123public interface ISubject &#123; void request();&#125; 真实主题类1234567public class RealSubject implements ISubject&#123; @Override public void request() &#123; //业务处理 &#125;&#125; InvocationHandler的实现类1234567891011121314151617import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler&#123; private Object target = null; public MyInvocationHandler(Object object) &#123; this.target = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(this.target, args); &#125;&#125; DynamicProxy类1234567891011import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;public class DynamicProxy&lt;T&gt; &#123; @SuppressWarnings("unchecked") public static &lt;T&gt; T newProxyInstance(ClassLoader classLoader, Class&lt;?&gt;[] interfaces,InvocationHandler handler)&#123; return (T)Proxy.newProxyInstance(classLoader, interfaces, handler); &#125;&#125; Client类12345678910public class Client &#123; public static void main(String[] args) &#123; ISubject subject = new RealSubject(); InvocationHandler handler = new MyInvocationHandler(subject); ISubject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), handler); proxy.request(); &#125;&#125; 总结 在这里对代理模式做一下总结。对于代理模式来说，代理的存在对于调用者来说是透明的，而调用者看到的只是接口。对于代理对象来说，可以封装一些内部的逻辑处理，如访问控制、远程通信、日志、缓存等等。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制(下)—View的事件处理]]></title>
    <url>%2F2016%2F05%2F15%2Fview-event-dispatch%2F</url>
    <content type="text"><![CDATA[在上篇文章Android中的事件分发机制(上)——ViewGroup的事件分发中，对ViewGroup的事件分发进行了详细的分析。在文章的最后ViewGroup的dispatchTouchEvent方法调用dispatchTransformedTouchEvent方法成功将事件传递给ViewGroup的子View。并交由子View进行处理。那么现在就来分析一下子View接收到事件以后是如何处理的。 View的事件处理 对于这里描述的View，它是ViewGroup的父类，并不包含任何的子元素。这也就意味着View无法再次向下对事件进行分发操作，因此在View中并不存在onInterceptTouchEvent方法，也不会对事件做出拦截操作。它所做的事情就是对所接收的事件进行处理。下面就开看一下View如何对事件进行处理的。 既然ViewGroup将事件交由View的dispatchTouchEvent方。那么首先在这里就来看一下dispatchTouchEvent里面做了什么事情。12345678910111213141516171819202122public boolean dispatchTouchEvent(MotionEvent event) &#123; ...... if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ...... return result;&#125; 在View的dispatchTouchEvent方法中对事件处理的核心部分体现在上述代码中。onFilterTouchEventForSecurity方法表示当前接收事件的view是否处于被遮盖状态，View处于被遮盖状态表示当前View不位于顶部，该view被其它View所覆盖。如果当前View被遮盖，那么该View不会对事件进行处理。123456789101112131415public interface OnTouchListener &#123; boolean onTouch(View v, MotionEvent event);&#125;public void setOnTouchListener(OnTouchListener l) &#123; getListenerInfo().mOnTouchListener = l;&#125;ListenerInfo getListenerInfo() &#123; if (mListenerInfo != null) &#123; return mListenerInfo; &#125; mListenerInfo = new ListenerInfo(); return mListenerInfo;&#125; 在结合上述一段代码可以看到，通过setOnTouchListener方法设置OnTouchListener以后，若是当前View处于可用状态，那么条件li != null &amp;&amp; li.mOnTouchListener !=null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED必然为true。这时候程序便会回调OnTouchListener中的onTouch方法，若是在onTouch方法中返回true，便不会在执行View的onTouchEvent方法。从这里我们能够看到，一旦设置了OnTouchListener，那么OnTouchListener的优先级要高于onTouchEvent。 有一点需要注意，在程序中设置了OnTouchListener以后，对于OnTouchListener中的onTouch的返回值并不代表View中的dispatchTouchEvent方法所返回的值。在onTouch方法返回true的时候，表示事件成功被当前View所消耗，这时候result被置为true并且不再执行onTouchEvent，所以dispatchTouchEvent也就返回true。可是一旦在onTouch方法中返回false。这时候便会调用onTouchEvent方法，如果事件被onTouchEvent成功处理，并返回true，result依然会被置为true，dispatchTouchEvent自然而然的也就返回true。 下面在进入View的onTouchEvent方法一探究竟。对于onTouchEvent方法里的内容比较多，在这里分段查看。12345678910if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);&#125; 在这里可以看出对于不可用的View，如果他们的一些点击事件可用的话，依然能够成功的消费事件，只是它不会为该事件做出响应。对于View的这些点击之间默认为不可用，但是对于不同的的View他们的默认值不一样。例如在ImageView中点击事件依然为不可用，但是在Button中点击事件为可用。当然如果手动为它们设置监听事件，那么这些监听事件都将会自动被设为可用状态。从如下源码中可以看出。1234567891011121314151617181920public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125;public void setOnLongClickListener(@Nullable OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l;&#125;public void setOnContextClickListener(@Nullable OnContextClickListener l) &#123; if (!isContextClickable()) &#123; setContextClickable(true); &#125; getListenerInfo().mOnContextClickListener = l;&#125; 下面接着看OnTouchEvent里面代码。12345if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125;&#125; 这里首先判断是否对事件设置了代理，如果对事件设置了代理，便会执行TouchDelegate的onTouchEvent方法。mTouchDelegate默认值为null，可以通过View的setTouchDelegate方法来设置代理。对于TouchDelegate在后续的文章中在进行详细分析，在这里就不在过多描述。 最后看一下View是如何处理事件的，对于接收的事件整个处理过程比较复杂，在这里就从宏观上来整体看一下它的处理机制。123456789101112131415161718192021222324252627282930313233343536if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ...... if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; ...... break; ...... &#125; return true;&#125; 如果View的点击事件处于可用状态的话，便会对于这些事件进行处理，并且返回true。当一个事件序列完成以后调用performClick方法,下面看下这个performClick方法。1234567891011121314public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; 从上面代码中可以看出，如果我们设置了OnClickListener，便会调用它的onClick方法。从这一路下来我们可以看出对于View的onClick事件，在最后才会被调用，可见onClick的优先级是最低的。 总结 在这里对View的事件处理做一下总结。在ViewGroup将事件分发到View以后。在View里面通过OnTouchListener的onTouch和View中的onTouchEvent这两个方法对事件进行处理。对于onTouch方法是View提供给用户的，方便用户自己处理触摸事件，而onTouchEvent是Android系统自己实现的接口。若是用户设置了OnTouchListener，Android系统会首先调用OnTouchListener的onTouch方法。若是在onTouch方法中返回true，就不在执行View的onTouchEvent方法。只有在onTouch中返回了false才会执行onTouchEvent。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制(上)—ViewGroup的事件分发]]></title>
    <url>%2F2016%2F05%2F13%2Fviewgroup-event-dispatch%2F</url>
    <content type="text"><![CDATA[Android中的事件分发机制也就是View与ViewGroup的对事件的分发与处理。在ViewGroup的内部包含了许多View，而ViewGroup继承自View，所以ViewGroup本身也是一个View。对于事件可以通过ViewGroup下发到它的子View并交由子View进行处理，而ViewGroup本身也能够对事件做出处理。下面就来详细分析一下ViewGroup对时间的分发处理。 MotionEvent 当手指接触到屏幕以后，所产生的一系列的事件中，都是由以下三种事件类型组成。 1. ACTION_DOWN: 手指按下屏幕 2. ACTION_MOVE: 手指在屏幕上移动 3. ACTION_UP: 手指从屏幕上抬起 例如一个简单的屏幕触摸动作触发了一系列Touch事件:ACTION_DOWN-&gt;ACTION_MOVE-&gt;…-&gt;ACTION_MOVE-&gt;ACTION_UP 对于Android中的这个事件分发机制，其中的这个事件指的就是MotionEvent。而View的对事件的分发也是对MotionEvent的分发操作。可以通过getRawX和getRawY来获取事件相对于屏幕左上角的横纵坐标。通过getX()和getY()来获取事件相对于当前View左上角的横纵坐标。 三个重要方法public boolean dispatchTouchEvent(MotionEvent ev) 这是一个对事件分发的方法。如果一个事件传递给了当前的View，那么当前View一定会调用该方法。对于dispatchTouchEvent的返回类型是boolean类型的，返回结果表示是否消耗了这个事件，如果返回的是true，就表明了这个View已经被消耗，不会再继续向下传递。 public boolean onInterceptTouchEvent(MotionEvent ev) 该方法存在于ViewGroup类中，对于View类并无此方法。表示是否拦截某个事件，ViewGroup如果成功拦截某个事件，那么这个事件就不在向下进行传递。对于同一个事件序列当中，当前View若是成功拦截该事件，那么对于后面的一系列事件不会再次调用该方法。返回的结果表示是否拦截当前事件，默认返回false。由于一个View它已经处于最底层，它不会存在子控件，所以无该方法。 public boolean onTouchEvent(MotionEvent event) 这个方法被dispatchTouchEvent调用，用来处理事件，对于返回的结果用来表示是否消耗掉当前事件。如果不消耗当前事件的话，那么对于在同一个事件序列当中，当前View就不会再次接收到事件。 View事件分发流程图 对于事件的分发，在这里先通过一个流程图来看一下整个分发过程。 ViewGroup事件分发源码分析 根据上面的流程图现在就详细的来分析一下ViewGroup事件分发的整个过程。 手指在触摸屏上滑动所产生的一系列事件，当Activity接收到这些事件通过调用Activity的dispatchTouchEvent方法来进行对事件的分发操作。下面就来看一下Activity的dispatchTouchEvent方法。123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 通过getWindow().superDispatchTouchEvent(ev)这个方法可以看出来，这个时候Activity又会将事件交由Window处理。Window它是一个抽象类，它的具体实现只有一个PhoneWindow，也就是说这个时候，Activity将事件交由PhoneWindow中的superDispatchTouchEvent方法。现在跟踪进去看一下这个superDispatchTouchEvent代码。123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; 这里面的mDecor它是一个DecorView，DecorView它是一个Activity的顶级View。它是PhoneWindow的一个内部类，继承自FrameLayout。于是在这个时候事件又交由DecorView的superDispatchTouchEvent方法来处理。下面就来看一下这个superDispatchTouchEvent方法。123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; 在这个时候就能够很清晰的看到DecorView它调用了父类的dispatchTouchEvent方法。在上面说到DecorView它继承了FrameLayout，而这个FrameLayout又继承自ViewGroup。所以在这个时候事件就开始交给了ViewGroup进行处理了。下面就开始详细看下这个ViewGroup的dispatchTouchEvent方法。由于dispatchTouchEvent代码比较长，在这里就摘取部分代码进行说明。12345678// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125; 从上面代码可以看出，在dispatchTouchEvent中，会对接收的事件进行判断，当接收到的是ACTION_DOWN事件时，便会清空事件分发的目标和状态。然后执行resetTouchState方法重置了触摸状态。下面就来看一下这两个方法。 1. cancelAndClearTouchTargets(ev)1234567891011121314151617181920212223242526private TouchTarget mFirstTouchTarget;......private void cancelAndClearTouchTargets(MotionEvent event) &#123; if (mFirstTouchTarget != null) &#123; boolean syntheticEvent = false; if (event == null) &#123; final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; &#125; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; resetCancelNextUpFlag(target.child); dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); &#125; clearTouchTargets(); if (syntheticEvent) &#123; event.recycle(); &#125; &#125;&#125; 在这里先介绍一下mFirstTouchTarget，它是TouchTarget对象，TouchTarget是ViewGroup的一个内部类，TouchTarget采用链表数据结构进行存储View。而在这个方法中主要的作用就是清空mFirstTouchTarget链表并将mFirstTouchTarget设为空。 2. resetTouchState()123456private void resetTouchState() &#123; clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE;&#125; 在这里介绍一下FLAG_DISALLOW_INTERCEPT标记，这是禁止ViewGroup拦截事件的标记，可以通过requestDisallowInterceptTouchEvent方法来设置这个标记，当设置了这个标记以后，ViewGroup便无法拦截除了ACTION_DOWN以外的其它事件。因为在上面代码中可以看出，当事件为ACTION_DOWN时，会重置FLAG_DISALLOW_INTERCEPT标记。 那么下面就再次回到dispatchTouchEvent方法中继续看它的源代码。12345678910111213141516// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 这段代码主要就是ViewGroup对事件是否需要拦截进行的判断。下面先对mFirstTouchTarget是否为null这两种情况进行说明。当事件没有被拦截时，ViewGroup的子元素成功处理事件后，mFirstTouchTarget会被赋值并且指向其子元素。也就是说这个时候mFirstTouchTarget!=null。可是一旦事件被拦截，mFirstTouchTarget不会被赋值，mFirstTouchTarget也就为null。 在上面代码中可以看到根据actionMasked==MotionEvent.ACTION_DOWN||mFirstTouchTarget!=null这两个情况进行判断事件是否需要拦截。对于actionMasked==MotionEvent.ACTION_DOWN这个条件很好理解，对于mFirstTouchTarget!=null的两种情况上面已经说明。那么对于一个事件序列，当事件为MotionEvent.ACTION_DOWN时，会重置FLAG_DISALLOW_INTERCEPT，也就是说!disallowIntercept一定为true，必然会执行onInterceptTouchEvent方法，对于onInterceptTouchEvent方法默认返回为false，所以需要ViewGroup拦截事件时，必须重写onInterceptTouchEvent方法，并返回true。这里有一点需要注意，对于一个事件序列，一旦序列中的某一个事件被成功拦截，执行了onInterceptTouchEvent方法，也就是说onInterceptTouchEvent返回值为true，那么该事件之后一系列事件对于条件actionMasked==MotionEvent.ACTION_DOWN||mFirstTouchTarget!=null必然为false，那么这个时候该事件序列剩下的一系列事件将会被拦截，并且不会执行onInterceptTouchEvent方法。于是在这里得出一个结论：对于一个事件序列，当其中某一个事件成功拦截时，那么对于剩下的一系列事件也会被拦截，并且不会再次执行onInterceptTouchEvent方法 下面再来看一下对于ViewGroup并没有拦截事件是如何进行处理的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970final int childrenCount = mChildrenCount;if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear();&#125; 对于这段代码虽然说比较长，但是在这里面的逻辑去不是很复杂。首先获取当前ViewGroup中的子View和ViewGroup的数量。然后对该ViewGroup中的元素进行逐步遍历。在获取到ViewGroup中的子元素后，判断该元素是否能够接收触摸事件。子元素若是能够接收触摸事件，并且该触摸坐标在子元素的可视范围内的话，便继续向下执行。否则就continue。对于衡量子元素能否接收到触摸事件的标准有两个：子元素是否在播放动画和点击事件的坐标是否在子元素的区域内。 一旦子View接收到了触摸事件，然后便开始调用dispatchTransformedTouchEvent方法对事件进行分发处理。对于dispatchTransformedTouchEvent方法代码比较多，现在只关注下面这五行代码。从下面5行代码中可以看出，这时候会调用子View的dispatchTouchEvent，也就是在这个时候ViewGroup已经完成了事件分发的整个过程。12345if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; 当子元素的dispatchTouchEvent返回为true的时候，也就是子View对事件处理成功。这时候便会通过addTouchTarget方法对mFirstTouchTarget进行赋值。 如果dispatchTouchEvent返回了false，或者说当前的ViewGroup没有子元素的话，那么这个时候便会调用如下代码。12345if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 在这里调用dispatchTransformedTouchEvent方法，并将child参数设为null。也就是执行了super.dispatchTouchEvent(event)方法。由于ViewGroup继承自View，所以这个时候又将事件交由父类的dispatchTouchEvent进行处理。对于父类View是如何通过dispatchTouchEvent对事件进行处理的，在下篇文章中会进行详细说明。 到这里对于ViewGroup的事件分发已经讲完了，在这一路下来，不难发现对于dispatchTouchEvent有一个boolean类型返回值。对于这个返回值，当返回true的时候表示当前事件处理成功，若是返回false，一般来说是因为在事件处理onTouchEvent返回了false，这时候变会交由它的父控件进行处理，以此类推，若是一直处理失败，则最终会交由Activity的onTouchEvent方法进行处理。 总结 在这里从宏观上再看一下这个ViewGroup对事件的分发，当ViewGroup接收一个事件序列以后，首先会判断是否拦截该事件，若是拦截该事件，则通过调用父类View的dispatchTouchEvent来处理这个事件。若是不去拦截这一事件，便将该事件下发到子View当中。若果说ViewGroup没有子View，或者说子View对事件处理失败，则将该事件有交由该ViewGroup处理，若是该ViewGroup对事件依然处理失败，最终则会将事件交由Activity进行处理。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProGuard详解]]></title>
    <url>%2F2016%2F05%2F03%2Fproguard%2F</url>
    <content type="text"><![CDATA[对于ProGuard工具想必我们都不陌生，它能够通过移除无用代码，使用简短无意义的名称来重命名类，字段和方法。从而能够达到压缩、优化和混淆代码的目的。最终我们会获取一个较小的apk文件，并且我们这个通过ProGuard处理的apk文件更难于进行逆向工程。 ProGuard工作原理简介 ProGuard能够对Java类中的代码进行压缩（Shrink）,优化（Optimize）,混淆（Obfuscate）,预检（Preveirfy）。 1. 压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性。 2. 优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令。 3. 混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名。 4. 预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检。 对于ProGuard执行流程图如下图所示。 对于ProGuard的原理更详细的介绍可以参考Proguard手册，在这里就不在进行更详细的介绍。 ProGuard使用 ProGuard已集成到Android构建系统中，所以我们不用手动调用这个工具。我们可以选择在只发布模式下构建系统的时候再去运行ProGuard。 在AndroidStudio中我们需要将Proguard添加到gradle.build文件的构建类型当中。不过在我们创建一个Android工程的时候，系统已经自动为我们添加到了gradle.build中。123456buildTypes &#123; release &#123; minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125;&#125; minifyEnabled:开启混淆,我们新建的工程默认为false，因此，如果我们需要开启混淆的话就需要手动设为true。proguardFiles:这部分有两段，前一段代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，免去了我们很多事，这个文件的目录在/tools/proguard/proguard-android.txt , 后一部分是我们项目里的自定义的混淆文件，目录就在 app/proguard-rules.pro,在这个文件里我们可以声明一些我们所需要的定制的混淆规则。 下面我们就来看一下这个默认的android程序混淆文件proguard-android.txt。对于下面一些指令与代码的含义在后面会进行说明。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# This is a configuration file for ProGuard.# http://proguard.sourceforge.net/index.html#manual/usage.html-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-verbose# Optimization is turned off by default. Dex does not like code run# through the ProGuard optimize and preverify steps (and performs some# of these optimizations on its own).-dontoptimize-dontpreverify# Note that if you want to enable optimization, you cannot just# include optimization flags in your own project configuration file;# instead you will need to point to the# "proguard-android-optimize.txt" file instead of this one from your# project.properties file.-keepattributes *Annotation*-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# For native methods, see http://proguard.sourceforge.net/manual/examples.html#native-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;# keep setters in Views so that animations can still work.# see http://proguard.sourceforge.net/manual/examples.html#beans-keepclassmembers public class * extends android.view.View &#123; void set*(***); *** get*();&#125;# We want to keep methods in Activity that could be used in the XML attribute onClick-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125;# For enumeration classes, see http://proguard.sourceforge.net/manual/examples.html#enumerations-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keepclassmembers class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator CREATOR;&#125;-keepclassmembers class **.R$* &#123; public static &lt;fields&gt;;&#125;# The support library contains references to newer platform versions.# Don't warn about those in case this app is linking against an older# platform version. We know about them, and they are safe.-dontwarn android.support.**# Understand the @Keep support annotation.-keep class android.support.annotation.Keep-keep @android.support.annotation.Keep class * &#123;*;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;methods&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;fields&gt;;&#125;-keepclasseswithmembers class * &#123; @android.support.annotation.Keep &lt;init&gt;(...);&#125; proguard-rules.pro配置ProGuard基本指令 下面列举了我们开发中需要使用的一些指令。12345678910111213141516171819202122232425262728293031#代码混淆压缩比，在0~7之间，默认为5，一般不做修改-optimizationpasses 5#混合时不使用大小写混合，混合后的类名为小写-dontusemixedcaseclassnames#指定不去忽略非公共库的类-dontskipnonpubliclibraryclasses#这句话能够使我们的项目混淆后产生映射文件#包含有类名-&gt;混淆后类名的映射关系-verbose#指定不去忽略非公共库的类-dontskipnonpubliclibraryclassmembers#不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。-dontpreverify#保留Annotation不混淆-keepattributes *Annotation*,InnerClasses#避免混淆泛型-keepattributes Signature#抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable#指定混淆是采用的算法，后面的参数是一个过滤器#这个过滤器是谷歌推荐的算法，一般不做更改-optimizations !code/simplification/cast,!field/*,!class/merging/* 需要保留的代码 下面列举了一些在我们的app开发中需要保留的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#保留我们使用的四大组件，自定义的Application等等这些类不被混淆#因为这些子类都有可能被外部调用-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService#保留support下的所有类及其内部类-keep class android.support.** &#123;*;&#125;#保留R下面的资源-keep class **.R$* &#123;*;&#125;#保留本地native方法不被混淆-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;#保留在Activity中的方法参数是view的方法，#这样以来我们在layout中写的onClick就不会被影响-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;#保留枚举类不被混淆-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;#保留我们自定义控件（继承自View）不被混淆-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;#保留Parcelable序列化类不被混淆-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;#保留Serializable序列化的类不被混淆-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;#对于带有回调函数的onXXEvent的，不能被混淆-keepclassmembers class * &#123; void *(**On*Event);&#125; 针对我们的App进行配置1. 对于实体类我们不能混淆 对于实力类我们不能进行混淆，我们需要保留他们的set和get方法。对于boolean类型的get方法为isXXX,不能够遗漏。在开发的时候我们可以将所有的实体类放在一个包内，这样我们写一次混淆就行了。12345-keep public class com.ljd.example.entity.** &#123; public void set*(***); public *** get*(); public *** is*();&#125; 2. 在我们的app中使用了webView需要进行特殊处理 在我们的项目中经常会嵌入一些webview做一些复杂的操作，这时候我们能够添加如下代码。12345678910-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125; 3. 在app中与HTML5的JavaScript的交互进行特殊处理 在我们的App中有时候需要与Html5中的JavaScript进行交互。例如：12345678package com.ljd.example;public class JSInterface &#123; @JavascriptInterface public void callAndroidMethod()&#123; // do something &#125;&#125; 我们需要确保这些js要调用的原生方法不能够被混淆，于是我们需要做如下处理：123-keepclassmembers class com.ljd.example.JSInterface &#123; &lt;methods&gt;;&#125; 4. 对含有反射类的处理1-keep class 类所在的包.** &#123; *; &#125; 5.对于第三方依赖库的处理 这个取决于第三方的混淆策略。下面列举一些第三方依赖库的混淆策略。具体还以官方给出的为准。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#支付宝-libraryjars libs/alipaysdk.jar-dontwarn com.alipay.android.app.**-keep public class com.alipay.** &#123; *; &#125;# Retrolambda-dontwarn java.lang.invoke.*#realm-keep class io.realm.annotations.RealmModule-keep @io.realm.annotations.RealmModule class *-keep class io.realm.internal.Keep-keep @io.realm.internal.Keep class * &#123; *; &#125;-dontwarn javax.**-dontwarn io.realm.**# OrmLite-keep class com.j256.**-keepclassmembers class com.j256.** &#123; *; &#125;-keep enum com.j256.**-keepclassmembers enum com.j256.** &#123; *; &#125;-keep interface com.j256.**-keepclassmembers interface com.j256.** &#123; *; &#125;#极光推送-dontoptimize-dontpreverify-dontwarn cn.jpush.**-keep class cn.jpush.** &#123; *; &#125;#EventBus-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;#retroift-dontwarn retrofit2.**-keep class retrofit2.** &#123; *; &#125;-keepattributes Signature-keepattributes Exceptions#ButterKnife-keep class butterknife.** &#123; *; &#125;-dontwarn butterknife.internal.**-keep class **$$ViewBinder &#123; *; &#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;fields&gt;;&#125;-keepclasseswithmembernames class * &#123; @butterknife.* &lt;methods&gt;;&#125;#fastjson-dontwarn com.alibaba.fastjson.**-keep class com.alibaba.fastjson.** &#123; *; &#125;#rxjava-dontwarn sun.misc.**-keepclassmembers class rx.internal.util.unsafe.*ArrayQueue*Field* &#123; long producerIndex; long consumerIndex;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueProducerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode producerNode;&#125;-keepclassmembers class rx.internal.util.unsafe.BaseLinkedQueueConsumerNodeRef &#123; rx.internal.util.atomic.LinkedQueueNode consumerNode;&#125;#jackson-dontwarn org.codehaus.jackson.**-dontwarn com.fasterxml.jackson.databind.**-keep class org.codehaus.jackson.** &#123; *;&#125;-keep class com.fasterxml.jackson.** &#123; *; &#125;#Facebook-keep class com.facebook.** &#123;*;&#125;-keep interface com.facebook.** &#123;*;&#125;-keep enum com.facebook.** &#123;*;&#125;#Fresco-keep class com.facebook.fresco.** &#123;*;&#125;-keep interface com.facebook.fresco.** &#123;*;&#125;-keep enum com.facebook.fresco.** &#123;*;&#125; 在Android中配置ProGuard模板代码 对于ProGuard的配置在下面给出代码的通用部分，在使用的时候直接复制即可，之后根据自己的项目进行添加一些自己项目中所需要保留的内容，以及所依赖第三方库的处理即可。在下面代码中对于在proguard-android.txt中已经添加过得代码在这里可以选择忽略。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899############################################### 对于一些基本指令的添加##############################################-optimizationpasses 5-dontusemixedcaseclassnames-dontskipnonpubliclibraryclasses-verbose-dontskipnonpubliclibraryclassmembers-dontpreverify-keepattributes *Annotation*,InnerClasses-keepattributes Signature-keepattributes SourceFile,LineNumberTable-optimizations !code/simplification/cast,!field/*,!class/merging/*############################################### Android开发中一些需要保留的公共部分##############################################-keep public class * extends android.app.Activity-keep public class * extends android.app.Appliction-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class * extends android.view.View-keep public class com.android.vending.licensing.ILicensingService-keep class android.support.** &#123;*;&#125;-keep class **.R$* &#123;*;&#125;-keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125;-keepclassmembers class * extends android.app.Activity&#123; public void *(android.view.View);&#125;-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String);&#125;-keep public class * extends android.view.View&#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);&#125;-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125;-keepclassmembers class * implements java.io.Serializable &#123; static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125;-keepclassmembers class * &#123; void *(**On*Event);&#125;#webView处理，项目中没有使用到webView忽略即可-keepclassmembers class fqcn.of.javascript.interface.for.webview &#123; public *;&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String);&#125;-keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView, jav.lang.String);&#125;############################################### 项目中特殊处理部分###############################################-----------处理反射类---------------......#-----------处理js交互---------------......#-----------处理实体类---------------......#-----------处理第三方依赖库---------...... 注意事项1. 确保混淆不会对项目产生影响 对于我们的Android项目最好是能够在一开始就是用ProGuard进行处理。并且在debug模式下也进行ProGuard处理，这样就能够在我们的开发中进行处理ProGuard所造成的影响。2. 打包时忽略警告 在我们打包的时候，会发现很多could not reference class之类的warning信息。如果我们能够确认App在运行中和那些引用没有什么关系，可以添加-dontwarn标签。如-dontwarn org.apache.harmony.**。 我们不要使用-ignorewarnings语句，这个会忽略所有警告，会有很多潜在的风险。 总结 对于ProGuard的使用不是很复杂，但是在我们的项目中使用ProGuard是必不可少的，它不仅仅能够对代码进行混淆，还能够优化我们的代码，减少我们apk文件的体积。从而优化我们的代码 附录Proguard手册ProGuard ReTrace 手册]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>ProGuard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的线程池]]></title>
    <url>%2F2016%2F04%2F28%2Fthreadpool%2F</url>
    <content type="text"><![CDATA[在我们的开发中经常会使用到多线程。例如在Android中，由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中运行。我们往往会通过new Thread来开启一个子线程，待子线程操作完成以后通过Handler切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者OOM。所以在Java中为我们提供了线程池来管理我们所创建的线程。 线程池的使用采用线程池的好处 在这里我们首先来说一下采用线程池的好处。 1. 重用线程池中已经存在的线程，减少了线程的创建和消亡多造成的性能开销。 2. 能够有效控制最大的并发线程数，提高了系统资源的使用率，并且还能够避免大量线程之间因为相互抢占系统资源而导致阻塞。 3. 能够对线程进行简单管理，并提供定时执行、定期执行、单线程、并发数控制等功能。 ThreadPoolExecutor 我们可以通过ThreadPoolExecutor来创建一个线程池。下面我们就来看一下ThreadPoolExecutor中的一个构造方法。1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor参数含义1. corePoolSize 线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。2. maximumPoolSize 线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。3. keepAliveTime 非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。4. unit 用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒);5. workQueue 线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。 ArrayBlockingQueue:基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 LinkedBlockingQueue:基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 SynchronousQueue:内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。 PriorityBlockingQueue:具有优先级的无限阻塞队列。 我们还能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。 6. threadFactory 线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。7. handler 他是RejectedExecutionHandler对象，而RejectedExecutionHandler是一个接口，里面只有一个rejectedExecution方法。当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。在ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler接口。在线程池中它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常。下面是在ThreadPoolExecutor中提供的四个可选值。 CallerRunsPolicy:只用调用者所在线程来运行任务。 AbortPolicy:直接抛出RejectedExecutionException异常。 DiscardPolicy:丢弃掉该任务，不进行处理 DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。 ThreadPoolExecutor执行规则 如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。 如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。 由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。 如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。 ThreadPoolExecutor的使用 上面说了那么多，我们现在就来看一下到底是如何使用这个ThreadPoolExecutor。首先我们通过ThreadPoolExecutor创建一个一个线程池。1ExecutorService executorService = new ThreadPoolExecutor(5,10,10,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;&gt;()); 对于ThreadPoolExecutor有多个构造方法，对于上面的构造方法中的其他参数都采用默认值。我们创建完一个线程池以后，下面就再来看一下如何向线程池提交一个任务。我们可以通过execute和submit两种方式来向线程池提交一个任务。execute 当我们使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。12345678executorService.execute(new Runnable() &#123; @Override public void run() &#123; // doSomething &#125;&#125;); submit 当我们使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。1234567891011121314151617Future&lt;Object&gt; future = executorService.submit(new Callable&lt;Object&gt;() &#123; @Override public String call() throws Exception &#123; // TODO Auto-generated method stub return null; &#125;&#125;);try &#123; Object object = future.get();&#125; catch (InterruptedException e) &#123; // 处理中断异常 e.printStackTrace();&#125; catch (ExecutionException e) &#123; // 处理无法执行异常 e.printStackTrace();&#125; 关闭线程池 我们可以通过shutdown方法或者shutdownNow方法来关闭线程池。对于这两种关闭线程池的方式他们都是通过遍历线程池中所有的线程，然后依次调用线程的interrupt方法来中断线程。当然对于这两种关闭线程池的方法也是有一定区别的（具体区别见下面注释）。 当我们调用了下面任何一个关闭方法时，isShutdown方法就会返回true。而当线程池关闭成功以后isTerminaed方法会返回true。对于线程池中的正在执行的任务如果我们希望他们执行完成以后再去关闭线程池则调用shutdown方法；而我们希望在关闭线程池的时候中断线程池内正在执行的任务，则调用shutdownNow方法。1234567891011/*** 首先将线程池的状态设置成SHUTDOWN状态，然后中断所* 有没有正在执行任务的线程。*/executorService.shutdown();/*** 首先将线程池的状态设置为STOP，然后开始尝试停止所有的正在* 工作或暂停任务的线程*/executorService.shutdownNow(); Java线程池Java中的线程池分类 在这里我们介绍一下Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置ThreadPoolExecutor来实现他们各自的功能。这四种线程池分别是newFixedThreadPool,newCachedThreadPool,newScheduledThreadPool和newSingleThreadExecutor。这四个线程池可以通过Executors类获取。下面分别介绍这四种线程池。 1. newFixedThreadPool 我们可以通过Executors中的newFixedThreadPool方法来创建，该线程池是一种线程数量固定的线程池。在这个线程池中所容纳最大的线程数就是我们设置的核心线程数。如果线程池的线程处于空闲状态的话，它们并不会被回收，除非是这个线程池被关闭。如果所有的线程都处于活动状态的话，新任务就回处于等待状态，直到有线程空闲出来。由于newFixedThreadPool只有核心线程，并且这些线程都不会被回收，也就是它能够更快速的响应外界请求。从下面的newFixedThreadPool方法的实现可以看出，newFixedThreadPool只有核心线程，并且不存在超时机制，采用LinkedBlockingQueue，所以对于任务队列的大小也是没有限制的。12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 2. newCachedThreadPool 我们可以通过Executors中的newCachedThreadPool方法来创建，通过下面的newCachedThreadPoolfan’f在这里我们可以看出它的核心线程数为0，线程池的最大线程数Integer.MAX_VALUE。而Integer.MAX_VALUE是一个很大的数，也差不多可以说这个线程池中的最大线程数可以任意大。当线程池中的线程都处于活动状态的时候，线程池就会创建一个新的线程来处理任务。该线程池中的线程超时时长为60秒，所以当线程处于闲置状态超过60秒的时候便会被回收。这也就意味着若是整个线程池的线程都处于闲置状态超过60秒以后，在newCachedThreadPool线程池中是不存在任何线程的，所以这时候它几乎不占用任何的系统资源。对于newCachedThreadPool他的任务队列采用的是SynchronousQueue，上面说到在SynchronousQueue内部没有任何容量的阻塞队列。SynchronousQueue内部相当于一个空集合，我们无法将一个任务插入到SynchronousQueue中。所以说在线程池中如果现有线程无法接收任务,将会创建新的线程来执行任务。12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 3. newScheduledThreadPool 我们可以通过Executors中的newScheduledThreadPool方法来创建，它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。1234567public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 4. newSingleThreadExecutor 我们可以通过Executors中的newSingleThreadExecutor方法来创建，在这个线程池中只有一个核心线程，对于任务队列没有大小限制，也就意味着这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行。newSingleThreadExecutor将所有的外界任务统一到一个线程中支持，所以在这个任务执行之间我们不需要处理线程同步的问题。123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 四种线程池的使用 下面我们就来看一下对于上面四种线程池是如何使用的。1234567891011121314151617181920Runnable command = new Runnable() &#123; public void run() &#123; //doSomething &#125;&#125;; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);fixedThreadPool.execute(command);ExecutorService cachedThreadPool= Executors.newCachedThreadPool();cachedThreadPool.equals(command);ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(10);//1000毫秒后执行coommandscheduledThreadPool.schedule(command, 1000, TimeUnit.MILLISECONDS);//延时5毫秒后，每隔100毫秒执行一次commandscheduledThreadPool.scheduleAtFixedRate(command, 5, 100, TimeUnit.MILLISECONDS);ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();singleThreadExecutor.execute(command); 总结 对于Java中的线程池概念同样适用于Android，例如在我们开发一个app时，我们可以创建一个线程池，将所有的子线程任务交由线程池来处理，于是我们便可以通过这个线程池来管理维护我们的子线程。减少了应用的开销。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之观察者模式]]></title>
    <url>%2F2016%2F04%2F27%2Fdesign-pattern-observer%2F</url>
    <content type="text"><![CDATA[观察者模式（Observer Pattern）也叫做发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式。这个模式的一个最重要的作用就是解耦。也就是将被观察者和观察者进行解耦，使得他们之间的依赖性更小，甚至做到毫无依赖。在观察者模式中它定义了一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。下面就来看一下观察者模式的具体实现。 观察者模式实现 在这里我们假定一个场景，在一个图书管理系统中，现在有这么一个需求，部分读者希望在图书馆添加新书的时候能够收到通知。于是这些读者就订阅该功能。而当图书馆添加新书的时候，系统会自动将新书的信息发送给订阅的读者。 上面这个场景就是典型的观察者模式。对于读者我们可以称为观察者，而图书管理系统则可以作为被观察者。在图书管理系统（被观察者）中去添加注册需要接收通知的读者（观察者）。这时候在系统中添加新书后，系统便会通知在系统注册该功能的读者。下面看一下代码实现。 既然是观察者模式，首先我们需要创建一个观察者接口。12345package com.ljd.example.observer;public interface Observer &#123; public void update(Object object);&#125; 紧接着我们在创建一个被观察者，对于被观察者中，里面的功能必然有添加一个观察者，删除观察者，通知更新观察者这三个公共方法，于是我们可以写一个抽象类。1234567891011121314151617181920212223242526package com.ljd.example.observer;import java.util.Vector;public abstract class Observable &#123; //定义一个观察这数组 private Vector&lt;Observer&gt; obVector = new Vector&lt;&gt;(); //添加一个观察者 public void addObserver(Observer observer) &#123; this.obVector.add(observer); &#125; //删除一个观察者 public void delObserver(Observer observer) &#123; this.obVector.remove(observer); &#125; //通知所有观察者 public void notifyObservers(Book book) &#123; for (Observer observer : obVector) &#123; observer.update(book); &#125; &#125;&#125; 下面我们就来实现上述场景。既然是图书管理系统，我们首先需要创建一个Book类。12345678910111213141516171819package com.ljd.example.observer;public class Book &#123; //书名 public String bookName; //作者 public String author; public Book(String bookName, String author) &#123; this.bookName = bookName; this.author = author; &#125; @Override public String toString() &#123; return "Book [bookName=" + bookName + ", author=" + author + "]"; &#125;&#125; 下面创建一个Library类，由于这个Library作为被观察者，我们使其继承自抽象类Observable。1234567891011121314151617181920212223242526272829package com.ljd.example.observer;import java.util.ArrayList;import java.util.List;public class Library extends Observable&#123; //使用list用于存放图书 private List&lt;Book&gt; bookList; public Library() &#123; // TODO Auto-generated constructor stub this.bookList = new ArrayList&lt;&gt;(); //添加两本书 Book android = new Book("Android","李江东"); Book HongLou = new Book("红楼梦", "曹雪芹"); this.bookList.add(android); this.bookList.add(HongLou); &#125; public void addBook(Book book) &#123; this.bookList.add(book); super.notifyObservers(book); &#125; public void delBook(Book book) &#123; this.bookList.remove(book); &#125;&#125; 下面再创建两个读者类ReaderA，ReaderB。它们作为观察者，就叫他们实现Observer接口。 ReaderA1234567891011121314package com.ljd.example.observer;public class ReaderA implements Observer&#123; public ReaderA() &#123; // TODO Auto-generated constructor stub &#125; @Override public void update(Object object) &#123; // TODO Auto-generated method stub System.out.println("我是读者A,收到了新书:" + object.toString()); &#125;&#125; ReaderB12345678910111213package com.ljd.example.observer;public class ReaderB implements Observer&#123; public ReaderB() &#123; // TODO Auto-generated constructor stub &#125; @Override public void update(Object object) &#123; // TODO Auto-generated method stub System.out.println("我是读者B,收到了新书:"+object.toString()); &#125;&#125; 下面我们就来测试一下结果。123456789101112131415161718package com.ljd.example.observer;public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Library library = new Library(); Observer readerAObserver = new ReaderA(); Observer readerBObserver = new ReaderB(); //添加读者A library.addObserver(readerAObserver); //添加读者B library.addObserver(readerBObserver); //添加一本新书 Book book = new Book("朝花夕拾", "鲁迅"); library.addBook(book); &#125;&#125; 最后我们看一下运行结果。 观察者模式通用代码 首先我们看一下观察者模式的通用类图 在这里对上面类图中的角色进行一下详细介绍 Subject:抽象主题，也就是上面的被观察者(Observable)角色。Subject把所有观察者对象的引用保存在一个集合里，并且能够动态的增加、取消观察者。 Observer:抽象观察者，他是观察者的抽象类，在这里定义个一个更新的接口，目的就是为了在接收到被观察者的更改通知是更新自己。 ConcreteSubject:具体主题，也就是具体的被观察者，在上面对应于Library类。在ConcreteSubject里面定义一些被观察者自己的业务逻辑，当ConcreteSubject内部状态发生改变时，给所有注册过的观察者发送通知。 ConcreteObserver:具体观察者，ConcreteObserver实现了抽象观察者所定义的更新接口，再被观察者通知改变是更新自身状态。 下面我们就来看一下观察者模式的通用代码。 Sunject（被观察者类）1234567891011121314151617181920212223242526package com.ljd.designpatterns.observer;import java.util.Vector;public abstract class Subject &#123; //定义一个观察这数组 private Vector&lt;Observer&gt; obVector = new Vector&lt;&gt;(); //添加一个观察者 public void addObserver(Observer observer) &#123; this.obVector.add(observer); &#125; //删除一个观察者 public void delObserver(Observer observer) &#123; this.obVector.remove(observer); &#125; //通知所有观察者 public void notifyObservers() &#123; for (Observer observer : obVector) &#123; observer.update(); &#125; &#125;&#125; ConcreteSubject（具体被观察者）123456789package com.ljd.designpatterns.observer;public class ConcreteSubject extends Subject&#123; // 具体业务 public void doSomething() &#123; super.notifyObservers(); &#125;&#125; Observer（观察者类）12345package com.ljd.designpatterns.observer;public interface Observer &#123; public void update();&#125; Observer（具体观察者）1234567891011121314package com.ljd.designpatterns.observer;public class ConcreteObserver implements Observer&#123; public ConcreteObserver() &#123; // TODO Auto-generated constructor stub &#125; //实现更新方法 @Override public void update() &#123; // TODO Auto-generated method stub System.out.println("我已接收到消息"); &#125;&#125; Client（场景类）12345678910public class Client &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ConcreteSubject subject = new ConcreteSubject(); Observer observer = new ConcreteObserver(); subject.addObserver(observer); subject.doSomething(); &#125;&#125; Java对观察者模式提供的支持 在java.util库里面，提供了一个Observable类和一个Observer接口。下面我们就来看一下这个Observable类和Observer接口。 Observer接口 在Observer接口中只提供了一个update方法，在被观察者发生变化时通过notifyObservers方法通知观察者做出改变，也就是执行了update方法。12345package java.util;public interface Observer &#123; void update(Observable o, Object arg);&#125; Observable类 下面被观察者类也是为我们提供了对于观察者添加，删除，通知观察者改变等方法。当我们的需要通知观察者并且需要调用观察者update方法，我们需要调用setChanged方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package java.util;public class Observable &#123; private boolean changed = false; //标记此 Observable对象为已改变的对象 private Vector&lt;Observer&gt; obs; public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; /** * 添加观察者 */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * 删除观察者 */ public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; public void notifyObservers() &#123; notifyObservers(null); &#125; /** * 如果当前Observable对象有变化（那时hasChanged 方法会返回true） * 调用这个方法通知所有登记的观察者，即调用它们的update()方法 * 传入Observer和arg作为参数 */ public void notifyObservers(Object arg) &#123; Object[] arrLocal; synchronized (this) &#123; if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; /** * 删除所有的观察者 */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** *将此Observable对象标记为已改变 */ protected synchronized void setChanged() &#123; changed = true; &#125; /** *将此Observable对象标记为未改变 */ protected synchronized void clearChanged() &#123; changed = false; &#125; /** *检测当前的Observable是否发生改变 */ public synchronized boolean hasChanged() &#123; return changed; &#125; /** * 观察者的数量 */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 下面我们就用Java为我们提供的接口来实现我们文章开始所假定的场景。 Library类123456789101112131415161718192021222324252627282930package com.ljd.example.observer;import java.util.ArrayList;import java.util.List;import java.util.Observable;public class Library extends Observable&#123; private List&lt;Book&gt; bookList; public Library() &#123; // TODO Auto-generated constructor stub this.bookList = new ArrayList&lt;&gt;(); //添加两本书 Book android = new Book("Android","李江东"); Book HongLou = new Book("红楼梦", "曹雪芹"); this.bookList.add(android); this.bookList.add(HongLou); &#125; public void addBook(Book book) &#123; super.setChanged(); this.bookList.add(book); super.notifyObservers(book); &#125; public void delBook(Book book) &#123; this.bookList.remove(book); &#125;&#125; 当我们添加一本书的时候，也就是addBook方法内，我们调用了父类setChanged方法，这样才能够执行观察者的update方法。对于与观察者Reader我们只需要实现java.util中的Observer接口即可。1234567891011121314151617package com.ljd.example.observer;import java.util.Observable;import java.util.Observer;public class ReaderA implements Observer&#123; public ReaderA() &#123; // TODO Auto-generated constructor stub &#125; @Override public void update(Observable o, Object arg) &#123; // TODO Auto-generated method stub System.out.println("我是读者A,收到了新书:" + arg.toString()); &#125;&#125; ReaderB与ReaderA一样，就不在重复粘贴。下面测试一下上述程序。12345678910111213141516171819202122package com.ljd.example.observer;import java.util.Observer;public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Library library = new Library(); Observer readerAObserver = new ReaderA(); Observer readerBObserver = new ReaderB(); //添加读者A library.addObserver(readerAObserver); //添加读者B library.addObserver(readerBObserver); //添加一本新书 Book book = new Book("朝花夕拾", "鲁迅"); library.addBook(book); System.out.println("asdsdsd"); &#125;&#125; 运行结果 总结 对于观察者模式在Java的设计模式当中也是非常常用的，在Android中对于观察者模式使用的场景也有很多。例如BroadcastReceiver，Eventbus，RxJava等等都采用了观察者模式。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Retrofit文件下载进度显示问题]]></title>
    <url>%2F2016%2F04%2F19%2Fretrofit-download%2F</url>
    <content type="text"><![CDATA[在Retrofit2.0使用详解这篇文章中详细介绍了retrofit的用法。并且在retrofit中我们可以通过ResponseBody进行对文件的下载。但是在retrofit中并没有为我们提供显示下载进度的接口。在项目中，若是用户下载一个文件，无法实时给用户显示下载进度，这样用户的体验也是非常差的。那么下面就介绍一下在retrofit用于文件的下载如何实时跟踪下载进度。 演示 Retrofit文件下载进度更新的实现 在retrofit2.0中他依赖于Okhttp，所以如果我们需要解决这个问题还需要从这个OKhttp来入手。在Okhttp中有一个依赖包Okio。Okio也是有square公司所开发，它是java.io和java.nio的补充，使用它更容易访问、存储和处理数据。在这里需要使用Okio中的Source类。在这里Source可以看做InputStream。对于Okio的详细使用在这里就不在介绍。下面来看一下具体实现。 在这里我们首先写一个接口，用于监听下载的进度。对于文件的下载，我们需要知道下载的进度，文件的总大小，以及是否操作完成。于是有了下面这样一个接口。12345678910111213package com.ljd.retrofit.progress;/** * Created by ljd on 3/29/16. */public interface ProgressListener &#123; /** * @param progress 已经下载或上传字节数 * @param total 总字节数 * @param done 是否完成 */ void onProgress(long progress, long total, boolean done);&#125; 对于文件的下载我们需要重写ResponseBody类中的一些方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ljd.retrofit.progress;import java.io.IOException;import okhttp3.MediaType;import okhttp3.ResponseBody;import okio.Buffer;import okio.BufferedSource;import okio.ForwardingSource;import okio.Okio;import okio.Source;/** * Created by ljd on 3/29/16. */public class ProgressResponseBody extends ResponseBody &#123; private final ResponseBody responseBody; private final ProgressListener progressListener; private BufferedSource bufferedSource; public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) &#123; this.responseBody = responseBody; this.progressListener = progressListener; &#125; @Override public MediaType contentType() &#123; return responseBody.contentType(); &#125; @Override public long contentLength() &#123; return responseBody.contentLength(); &#125; @Override public BufferedSource source() &#123; if (bufferedSource == null) &#123; bufferedSource = Okio.buffer(source(responseBody.source())); &#125; return bufferedSource; &#125; private Source source(Source source) &#123; return new ForwardingSource(source) &#123; long totalBytesRead = 0L; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; long bytesRead = super.read(sink, byteCount); totalBytesRead += bytesRead != -1 ? bytesRead : 0; progressListener.onProgress(totalBytesRead, responseBody.contentLength(), bytesRead == -1); return bytesRead; &#125; &#125;; &#125;&#125; 在上面ProgressResponseBody类中，我们计算已经读取文件的字节数，并且调用了ProgressListener接口。所以这个ProgressListener接口是在子线程中运行的。 下面就来看一下是如何使用这个ProgressResponseBody。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.ljd.retrofit.progress;import android.util.Log;import java.io.IOException;import okhttp3.Interceptor;import okhttp3.OkHttpClient;/** * Created by ljd on 4/12/16. */public class ProgressHelper &#123; private static ProgressBean progressBean = new ProgressBean(); private static ProgressHandler mProgressHandler; public static OkHttpClient.Builder addProgress(OkHttpClient.Builder builder)&#123; if (builder == null)&#123; builder = new OkHttpClient.Builder(); &#125; final ProgressListener progressListener = new ProgressListener() &#123; //该方法在子线程中运行 @Override public void onProgress(long progress, long total, boolean done) &#123; Log.d("progress:",String.format("%d%% done\n",(100 * progress) / total)); if (mProgressHandler == null)&#123; return; &#125; progressBean.setBytesRead(progress); progressBean.setContentLength(total); progressBean.setDone(done); mProgressHandler.sendMessage(progressBean); &#125; &#125;; //添加拦截器，自定义ResponseBody，添加下载进度 builder.networkInterceptors().add(new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; okhttp3.Response originalResponse = chain.proceed(chain.request()); return originalResponse.newBuilder().body( new ProgressResponseBody(originalResponse.body(), progressListener)) .build(); &#125; &#125;); return builder; &#125; public static void setProgressHandler(ProgressHandler progressHandler)&#123; mProgressHandler = progressHandler; &#125;&#125; 我们通过为OkhttpClient添加一个拦截器来使用我们自定义的ProgressResponseBody。并且在这里我们可以通过实现ProgressListener接口。来获取下载进度了。但是在这里依然存在一个问题，刚才说到这个ProgressListener接口运行在子线程中。也就是说在ProgressListener这个接口中我们无法进行ui操作。而我们获取文件下载的进度往往则是需要一个进度条进行ui显示。显然这并不是我们想要的结果。 在这个时候我们就需要使用Handler了。我们可以通过Handler将子线程中的ProgressListener的数据发送到ui线程中进行处理。也就是说我们在ProgressListener接口中的操作只是将其参数通过Handler发送出去。很显然在上面的代码中我们通过ProgressHandler来发送消息。那么就来看一下具体操作。 这里我们创建一个对象，用于存放ProgressListener中的参数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.ljd.retrofit.pojo;import java.util.ArrayList;import java.util.List;/** * Created by ljd on 3/29/16. */public class RetrofitBean &#123; private Integer total_count; private Boolean incompleteResults; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); /** * * @return * The totalCount */ public Integer getTotalCount() &#123; return total_count; &#125; /** * * @param totalCount * The total_count */ public void setTotalCount(Integer totalCount) &#123; this.total_count = totalCount; &#125; /** * * @return * The incompleteResults */ public Boolean getIncompleteResults() &#123; return incompleteResults; &#125; /** * * @param incompleteResults * The incomplete_results */ public void setIncompleteResults(Boolean incompleteResults) &#123; this.incompleteResults = incompleteResults; &#125; /** * * @return * The items */ public List&lt;Item&gt; getItems() &#123; return items; &#125;&#125; 然后我们在创建一个ProgressHandler类。1234567891011121314151617181920212223242526272829303132package com.ljd.retrofit.progress;import android.os.Handler;import android.os.Looper;import android.os.Message;/** * Created by ljd on 4/12/16. */public abstract class ProgressHandler &#123; protected abstract void sendMessage(ProgressBean progressBean); protected abstract void handleMessage(Message message); protected abstract void onProgress(long progress, long total, boolean done); protected static class ResponseHandler extends Handler&#123; private ProgressHandler mProgressHandler; public ResponseHandler(ProgressHandler mProgressHandler, Looper looper) &#123; super(looper); this.mProgressHandler = mProgressHandler; &#125; @Override public void handleMessage(Message msg) &#123; mProgressHandler.handleMessage(msg); &#125; &#125;&#125; 上面的ProgressHandler他是一个抽象类。在这里我们需要通过Handler对象进行发送和处理消息。于是定义了两个抽象方法sendMessage和handleMessage。之后又定义了一个抽象方法onProgress来处理下载进度的显示，而这个onProgress则是我们需要在ui线程进行调用。最后创建了一个继承自Handler的ResponseHandler内部类。为了避免内存泄露我们使用static关键字。 下面来创建一个DownloadProgressHandler类，他继承于ProgressHandler，用来发送和处理消息。1234567891011121314151617181920212223242526272829package com.ljd.retrofit.progress;import android.os.Looper;import android.os.Message;/** * Created by ljd on 4/12/16. */public abstract class DownloadProgressHandler extends ProgressHandler&#123; private static final int DOWNLOAD_PROGRESS = 1; protected ResponseHandler mHandler = new ResponseHandler(this, Looper.getMainLooper()); @Override protected void sendMessage(ProgressBean progressBean) &#123; mHandler.obtainMessage(DOWNLOAD_PROGRESS,progressBean).sendToTarget(); &#125; @Override protected void handleMessage(Message message)&#123; switch (message.what)&#123; case DOWNLOAD_PROGRESS: ProgressBean progressBean = (ProgressBean)message.obj; onProgress(progressBean.getBytesRead(),progressBean.getContentLength(),progressBean.isDone()); &#125; &#125;&#125; 在这里我们接收到消息以后调用抽象方法onProgress，这样一来我们只需要创建一个DownloadProgressHandler对象，实现onProgress即可。 对于上面的分析，下面我们就来看一下是如何使用的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.example.ljd.retrofit.download;import android.app.ProgressDialog;import android.os.Environment;import android.os.Looper;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import com.example.ljd.retrofit.R;import com.ljd.retrofit.progress.DownloadProgressHandler;import com.ljd.retrofit.progress.ProgressHelper;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import butterknife.ButterKnife;import butterknife.OnClick;import okhttp3.OkHttpClient;import okhttp3.ResponseBody;import retrofit2.Call;import retrofit2.Callback;import retrofit2.Response;import retrofit2.Retrofit;import retrofit2.adapter.rxjava.RxJavaCallAdapterFactory;import retrofit2.converter.gson.GsonConverterFactory;public class DownloadActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_download); ButterKnife.bind(this); &#125; @Override protected void onDestroy() &#123; ButterKnife.unbind(this); super.onDestroy(); &#125; @OnClick(R.id.start_download_btn) public void onClickButton()&#123; retrofitDownload(); &#125; private void retrofitDownload()&#123; //监听下载进度 final ProgressDialog dialog = new ProgressDialog(this); dialog.setProgressNumberFormat("%1d KB/%2d KB"); dialog.setTitle("下载"); dialog.setMessage("正在下载，请稍后..."); dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); dialog.setCancelable(false); dialog.show(); Retrofit.Builder retrofitBuilder = new Retrofit.Builder() .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl("http://msoftdl.360.cn"); OkHttpClient.Builder builder = ProgressHelper.addProgress(null); DownloadApi retrofit = retrofitBuilder .client(builder.build()) .build().create(DownloadApi.class); ProgressHelper.setProgressHandler(new DownloadProgressHandler() &#123; @Override protected void onProgress(long bytesRead, long contentLength, boolean done) &#123; Log.e("是否在主线程中运行", String.valueOf(Looper.getMainLooper() == Looper.myLooper())); Log.e("onProgress",String.format("%d%% done\n",(100 * bytesRead) / contentLength)); Log.e("done","---&gt;" + String.valueOf(done)); dialog.setMax((int) (contentLength/1024)); dialog.setProgress((int) (bytesRead/1024)); if(done)&#123; dialog.dismiss(); &#125; &#125; &#125;); Call&lt;ResponseBody&gt; call = retrofit.retrofitDownload(); call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; InputStream is = response.body().byteStream(); File file = new File(Environment.getExternalStorageDirectory(), "12345.apk"); FileOutputStream fos = new FileOutputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); fos.flush(); &#125; fos.close(); bis.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125; &#125;); &#125;&#125; 总结 对于上面的实现我们可以看出是通过OkhttpClient实现的。也正是由于在retrofit2.0中它依赖于OkHttp，因此对于OkHttp的功能retrofit也都具备。利用这一特性，我们可以通过定制OkhttpClient来配置我们的retrofit。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2.0使用详解]]></title>
    <url>%2F2016%2F04%2F03%2Fretrofit2.0-use%2F</url>
    <content type="text"><![CDATA[retrofit是由square公司开发的。square在github上发布了很多优秀的Android开源项目。例如:otto(事件总线),leakcanary(排查内存泄露),android-times-square(日历控件),dagger(依赖注入),picasso(异步加载图片),okhttp(网络请求),retrofit(网络请求)等等。更多square上的开源项目我们可以去square的GitHub进行查看。这次就来介绍一下retrofit的一些基本用法。retrofit是REST安卓客户端请求库。使用retrofit可以进行GET，POST，PUT，DELETE等请求方式。下面就来看一下retrofit的基本用法。 Retrofit使用方法 由于retrofit2.0与先前版本的差别还是比较大，对于不同版本之间的差异在这里就不在进行详细区别。下面的例子也是针对于retrofit2.0进行介绍的。retrofit2.0它依赖于OkHttp,而且这部分也不再支持替换。在这里我们也不需要显示的导入okHttp,在retrofit中已经导入okhttp3。12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;mockwebserver&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 在下面的例子当中采用与GitHub一些相关api进行演示。在这里首先需要添加访问网络的权限。1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 简单示例添加Gradle依赖项 在这里我们最好查看一下retrofit的官网添加最新依赖。1compile 'com.squareup.retrofit2:retrofit:2.0.1' 创建API接口 在retrofit中通过一个Java接口作为http请求的api接口。12345public interface GitHubApi &#123; @GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors") Call&lt;ResponseBody&gt; contributorsBySimpleGetCall(@Path("owner") String owner, @Path("repo") String repo);&#125; 创建retrofit实例 在这里baseUrl是在创建retrofit实力的时候定义的，我们也可以在API接口中定义完整的url。在这里建议在创建baseUrl中以”/“结尾，在API中不以”/“开头和结尾。123Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build(); 调用API接口 在调用API接口请求后，获得一个json字符串，通过Gson进行解析，获得login以及contributions。1234567891011121314151617181920212223GitHubApi repo = retrofit.create(GitHubApi.class); Call&lt;ResponseBody&gt; call = repo.contributorsBySimpleGetCall(mUserName, mRepo);call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; Gson gson = new Gson(); ArrayList&lt;Contributor&gt; contributorsList = gson.fromJson(response.body().string(), new TypeToken&lt;List&lt;Contributor&gt;&gt;()&#123;&#125;.getType()); for (Contributor contributor : contributorsList)&#123; Log.d("login",contributor.getLogin()); Log.d("contributions",contributor.getContributions()+""); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125;&#125;); 效果展示 这样就完成了一个http请求，上面请求的完整地址为：https://api.github.com/repos/square/retrofit/contributors 然后我们看一下运行结果: 取消请求 我们可以终止一个请求。终止操作是对底层的httpclient执行cancel操作。即使是正在执行的请求，也能够立即终止。1call.cancel(); 转换器 在上面的例子中通过获取ResponseBody后，我们自己使用Gson来解析接收到的Json格式数据。在Retrofit中当创建一个Retrofit实例的时候可以为其添加一个Json转换器，这样就会自动将Json格式的响应体转换为所需要的Java对象。那么先来看一下如何根据已有的Json格式数据如何生成Java对象。当然我们可以根据已知的数据手动创建Java对象，也可以通过工具更具Json格式为我们自动生成Java对象。 自动生成Java对象 在这里介绍两种根据Json数据自动生成Java对象的工具。 jsonschema2pojo 可以通过访问jsonschema2pojo网站。先来看一下它的使用方法。 上面配置中所选注解若是使用的Gson解析，可以选择Gson，当然没有也是可以的。对于@Generated注解若是需要保留的话添加如下依赖，也可以直接删除@Generated注解，没有任何影响。1compile 'org.glassfish:javax.annotation:10.0-b28' GsonFormat GsonFormat是AndroidStudio中的一个插件，在AndroidStudio的插件选项中直接搜索安装这个插件即可。在这里看一下是如何使用这个插件的。 添加转换器 在这里我们需要为retrofit添加gson转换器的依赖。添加过converter-gson后不用再添加gson库。在converter-gson中已经包含gson。1compile 'com.squareup.retrofit2:converter-gson:2.0.1' 在这里先创建一个Java类Contributor，用来保存接收到的数据。1234567891011121314151617181920public class Contributor &#123; private String login; private Integer contributions; public String getLogin() &#123; return login; &#125; public void setLogin(String login) &#123; this.login = login; &#125; public Integer getContributions() &#123; return contributions; &#125; public void setContributions(Integer contributions) &#123; this.contributions = contributions; &#125;&#125; 这时候修改我们的API接口。12@GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Call&lt;List&lt;Contributor&gt;&gt; contributorsByAddConverterGetCall(@Path("owner") String owner, @Path("repo") String repo); 创建retrofit实例，我们通过addConverterFactory指定一个factory来对响应反序列化，在这里converters被添加的顺序将是它们被Retrofit尝试的顺序。1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); 调用上面所修改的API接口。1234567891011121314151617GitHubApi repo = retrofit.create(GitHubApi.class);Call&lt;List&lt;Contributor&gt;&gt; call = repo.contributorsByAddConverterGetCall(mUserName, mRepo);call.enqueue(new Callback&lt;List&lt;Contributor&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Contributor&gt;&gt; call, Response&lt;List&lt;Contributor&gt;&gt; response) &#123; List&lt;Contributor&gt; contributorList = response.body(); for (Contributor contributor : contributorList)&#123; Log.d("login", contributor.getLogin()); Log.d("contributions", contributor.getContributions() + ""); &#125; &#125; @Override public void onFailure(Call&lt;List&lt;Contributor&gt;&gt; call, Throwable t) &#123; &#125;&#125;); 最后在来看一下运行结果。 retrofit不仅仅只支持gson，还支持其他许多json解析库。以下版本号需要与retrofit版本号保持一致，并且以retrofit官网给出的版本号为准。 Gson: compile ‘com.squareup.retrofit2:converter-gson:2.0.1’Jackson: compile ‘com.squareup.retrofit2:converter-jackson:2.0.1’Moshi: compile ‘com.squareup.retrofit2:converter-moshi:2.0.1’Protobuf: compile ‘com.squareup.retrofit2:converter-protobuf:2.0.1’Wire: compile ‘com.squareup.retrofit2:converter-wire:2.0.1’Simple XML: compile ‘com.squareup.retrofit2:converter-simplexml:2.0.1’ 增加日志信息 在retrofit2.0中是没有日志功能的。但是retrofit2.0中依赖OkHttp，所以也就能够通过OkHttp中的interceptor来实现实际的底层的请求和响应日志。在这里我们需要修改上一个retrofit实例，为其自定自定义的OkHttpClient。代码如下：1234567891011HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor();httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);OkHttpClient okHttpClient = new OkHttpClient.Builder() .addInterceptor(httpLoggingInterceptor) .build();Retrofit retrofit = new Retrofit.Builder().addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .client(okHttpClient) .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); 还需要添加如下依赖。1compile 'com.squareup.okhttp3:logging-interceptor:3.1.2' 其他代码没有任何变化，我们来看一下运行结果。 添加请求头 我们可以通过@Headers来添加请求头。1234567@Headers(&#123; "Accept: application/vnd.github.v3.full+json", "User-Agent: RetrofitBean-Sample-App", "name:ljd"&#125;)@GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Call&lt;List&lt;Contributor&gt;&gt; contributorsAndAddHeader(@Path("owner") String owner,@Path("repo") String repo); 运行结果。 同步请求 在这里我们可以直接通过call.execute()执行一个同步请求，由于不允许在主线程中进行网络请求操作，所以我们需要再子线程中进行执行。12345678910111213141516new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Response&lt;List&lt;Contributor&gt;&gt; response = call.execute(); List&lt;Contributor&gt; contributorsList = response.body(); for (Contributor contributor : contributorsList)&#123; Log.d("login",contributor.getLogin()); Log.d("contributions",contributor.getContributions()+""); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); 在这里看一下运行结果。 clone 在这里无论是同步操作还是异步操作每一个call对象实例只能被执行一次。多次执行抛出如下异常。 在这里如果我们的request和respone都是一一对应的。我们通过Clone方法创建一个一模一样的实例，并且它的开销也是很小的。12Call&lt;List&lt;Contributor&gt;&gt; cloneCall = call.clone();cloneCall.execute(); get请求 在前面的一些例子当中我们都是采用get请求。当然我们也可以为URL指定查询参数。使用@Query即可。12345@GET("search/repositories")Call&lt;RetrofitBean&gt; queryRetrofitByGetCall(@Query("q")String owner, @Query("since")String time, @Query("page")int page, @Query("per_page")int per_Page); 当我们的参数过多的时候我们可以通过@QueryMap注解和map对象参数来指定每个表单项的Key，value的值。12@GET("search/repositories")Call&lt;RetrofitBean&gt; queryRetrofitByGetCallMap(@QueryMap Map&lt;String,String&gt; map); 下面的call对象实例为上面api中所返回call对象。更具所返回的json数据所创建的实体类在这里就不在贴出代码，下载源码详细查看。1234567891011121314151617181920212223242526call.enqueue(new Callback&lt;RetrofitBean&gt;() &#123; @Override public void onResponse(Call&lt;RetrofitBean&gt; call, Response&lt;RetrofitBean&gt; response) &#123; RetrofitBean retrofit = response.body(); List&lt;Item&gt; list = retrofit.getItems(); if (list == null) return; Log.d(TAG, "total:" + retrofit.getTotalCount()); Log.d(TAG, "incompleteResults:" + retrofit.getIncompleteResults()); Log.d(TAG, "----------------------"); for (Item item : list) &#123; Log.d(TAG, "name:" + item.getName()); Log.d(TAG, "full_name:" + item.getFull_name()); Log.d(TAG, "description:" + item.getDescription()); Owner owner = item.getOwner(); Log.d(TAG, "login:" + owner.getLogin()); Log.d(TAG, "type:" + owner.getType()); &#125; &#125; @Override public void onFailure(Call&lt;RetrofitBean&gt; call, Throwable t) &#123; &#125;&#125;); 上面请求中的完整连接为: https://api.github.com/search/repositories?q=retrofit&amp;since=2016-03-29&amp;page=1&amp;per_page=3 在Retrofit 2.0添加了一个新的注解：@Url，它允许我们直接传入一个请求的URL。这样以来我们可以将上一个请求的获得的url直接传入进来。方便了我们的操作。12@GETCall&lt;List&lt;Contributor&gt;&gt; repoContributorsPaginate(@Url String url); Form encoded和MultipartForm encoded 我们可以使用@FormUrlEncoded注解来发送表单数据。使用 @Field注解和参数来指定每个表单项的Key，value为参数的值。123@FormUrlEncoded@POST("user/edit")Call&lt;User&gt; updateUser(@Field("first_name") String first, @Field("last_name") String last); 当我们有很多个表单参数时可以通过@FieldMap注解和Map对象参数来指定每个表单项的Key，value的值。123@FormUrlEncoded@POST("user/edit")Call&lt;User&gt; updateUser(@FieldMap Map&lt;String,String&gt; fieldMap); Multipart 我们还可以通过@Multipart注解来发送Multipart数据。通过@Part注解来定义需要发送的文件。123@Multipart@PUT("/user/photo")User updateUser(@Part("photo") TypedFile photo, @Part("description") TypedString description); Retrofit与RxJava结合 Retrofit能够与RxJava进行完美结合。下面就来看一下Retrofit与RxJava是如何结合在一起的。对于RxJava在这就不在进行详细介绍，对于RXJava的使用可以参考附录里面给出链接。 首先我们需要添加如下依赖。12compile 'com.squareup.retrofit2:adapter-rxjava:2.0.1'compile 'io.reactivex:rxandroid:1.1.0' 创建retrofit对象实例时，通过addCallAdapterFactory来添加对RxJava的支持。1234567891011HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor();httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);OkHttpClient okHttpClient = new OkHttpClient.Builder() .addInterceptor(httpLoggingInterceptor) .build();Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .baseUrl("https://api.github.com/") .build(); 使用Observable创建一个API接口。12@GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Observable&lt;List&lt;Contributor&gt;&gt; contributorsByRxJava(@Path("owner") String owner,@Path("repo") String repo); 下面来调用这个API接口。1private CompositeSubscription mSubscriptions = new CompositeSubscription(); 1234567891011121314151617181920mSubscriptions.add( mGitHubService.contributorsByRxJava(mUserName, mRepo) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;List&lt;Contributor&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(List&lt;Contributor&gt; contributors) &#123; for (Contributor c : contributors) &#123; Log.d("TAG", "login:" + c.getLogin() + " contributions:" + c.getContributions()); &#125; &#125; &#125;)); 下面来看一下运行结果。 如果我们想要查看所有contributor的信息，首先我们需要向gitHub请求获取到所有contributor，然后再通过获得contributor进行依次向github请求获取contributor的信息，在这时候我们使用RxJava也就非常方便了。下面看一下如何操作的。 首先再添加一个API接口。123@GET("repos/&#123;owner&#125;/&#123;repo&#125;/contributors")Observable&lt;List&lt;Contributor&gt;&gt; contributorsByRxJava(@Path("owner") String owner, @Path("repo") String repo); 下面在看一下是如何进行根据获得的contributor来查看contributor的信息。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mSubscriptions.add(mGitHubService.contributorsByRxJava(mUserName, mRepo) .flatMap(new Func1&lt;List&lt;Contributor&gt;, Observable&lt;Contributor&gt;&gt;() &#123; @Override public Observable&lt;Contributor&gt; call(List&lt;Contributor&gt; contributors) &#123; return Observable.from(contributors); &#125; &#125;) .flatMap(new Func1&lt;Contributor, Observable&lt;Pair&lt;User, Contributor&gt;&gt;&gt;() &#123; @Override public Observable&lt;Pair&lt;User, Contributor&gt;&gt; call(Contributor contributor) &#123; Observable&lt;User&gt; userObservable = mGitHubService.userByRxJava(contributor.getLogin()) .filter(new Func1&lt;User, Boolean&gt;() &#123; @Override public Boolean call(User user) &#123; return !isEmpty(user.getName()) &amp;&amp; !isEmpty(user.getEmail()); &#125; &#125;); return Observable.zip(userObservable, Observable.just(contributor), new Func2&lt;User, Contributor, Pair&lt;User, Contributor&gt;&gt;() &#123; @Override public Pair&lt;User, Contributor&gt; call(User user, Contributor contributor) &#123; return new Pair&lt;&gt;(user, contributor); &#125; &#125;); &#125; &#125;) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Pair&lt;User, Contributor&gt;&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Pair&lt;User, Contributor&gt; pair) &#123; User user = pair.first; Contributor contributor = pair.second; Log.d(TAG, "name:" + user.getName()); Log.d(TAG, "contributions:" + contributor.getContributions()); Log.d(TAG, "email:" + user.getEmail()); &#125; &#125;)); 最后在来看下运行结果。 Retrofit设置缓存对Retrofit设置缓存，由于Retrofit是对OkHttp的封装，所以我们可以直接通过OkHttpClient着手。也就是为OkHttp设置缓存。设置缓存代码如下所示。123456789101112131415161718192021222324252627282930313233343536373839private OkHttpClient getCacheOkHttpClient(Context context)&#123; final File baseDir = context.getCacheDir(); final File cacheDir = new File(baseDir, "HttpResponseCache"); Timber.e(cacheDir.getAbsolutePath()); Cache cache = new Cache(cacheDir, 10 * 1024 * 1024); //缓存可用大小为10M Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = chain -&gt; &#123; Request request = chain.request(); if(!NetWorkUtils.isNetWorkAvailable(context))&#123; request = request.newBuilder() .cacheControl(CacheControl.FORCE_CACHE) .build(); &#125; Response originalResponse = chain.proceed(request); if (NetWorkUtils.isNetWorkAvailable(context)) &#123; int maxAge = 60; //在线缓存一分钟 return originalResponse.newBuilder() .removeHeader("Pragma") .removeHeader("Cache-Control") .header("Cache-Control", "public, max-age=" + maxAge) .build(); &#125; else &#123; int maxStale = 60 * 60 * 24 * 4 * 7; //离线缓存4周 return originalResponse.newBuilder() .removeHeader("Pragma") .removeHeader("Cache-Control") .header("Cache-Control", "public, only-if-cached, max-stale=" + maxStale) .build(); &#125; &#125;; return new OkHttpClient.Builder() .addNetworkInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR) .addInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR) .cache(cache) .build();&#125; 总结 在retrofit的使用中，对于文件你上传与下载，并没有为我们提供进度更新的接口，在这里就需要我们自己处理了。在下面的例子中给出一个文件下载的例子，并且对下载进度更新通过logcat打印出来。可以下载进行查看。到这里retrofit的基本用法也就介绍完了，对于retrofit更多的好处在使用中我们可以慢慢体会。 源码下载附录 Retrofit官方文档 用 Retrofit 2 简化 HTTP 请求 给 Android 开发者的 RxJava 详解 RxJava Essentials 中文翻译版]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask使用以及源码分析]]></title>
    <url>%2F2016%2F03%2F19%2Fasynctask%2F</url>
    <content type="text"><![CDATA[在Android中，我们需要进行一些耗时的操作，会将这个操作放在子线程中进行。在子线程操作完成以后我们可以通过Handler进行发送消息，通知UI进行一些更新操作（具体使用及其原理可以查看Android的消息机制——Handler的工作过程这篇文章）。当然为了简化我们的操作，在Android1.5以后为我们提供了AsyncTask类，它能够将子线程处理完成后的结果返回到UI线程中，之后我们便可以根据这些结果进行一列的UI操作了。 AsyncTask的使用方法 实际上AsyncTask内部也就是对Handler和线程池进行了一次封装。它是一个轻量级的异步任务类，它的后台任务在线程池中进行。之后我们可以将任务执行的结果传递给主线程，这时候我们就可以在主线程中操作UI了。 AsyncTask他是一个抽象的泛型类，所以我们创建一个子类，来实现AsyncTask中的抽象方法。AsyncTask中提供了三个泛型参数，下面我们就来看一下这三个泛型参数. 1. Params:在执行AsyncTask时所传递的参数，该参数在后台线程中使用。 2. Progress:后台任务执行进度的类型 3. Result:后台任务执行完成后返回的结果类型。 对于以上三个泛型参数我们不需要使用的时候，可以使用Void来代替。与Activity生命周期类似，在AsyncTask中也为我们提供了一些方法，我们通过重写这几个方法来完成整个异步任务。我们主要使用的方法有一下四个: 1. onPreExecute():该方法在异步任务工作之前执行，主要用于一些参数或者UI的初始化操作。 2. doInBackground(Params… params):该方法在线程池中执行，params参数表示异步任务时输入的参数。在这个方法中我们通过publishProgress来通知任务进度。 3. onProgressUpdate(Progress… values):当后台任务的进度发生改变的时候会调用该方法，我们可以再这个方法中进行UI的进度展示。values参数表示任务进度。 4. postResult(Result result):在异步任务完成之后执行，result参数为异步任务执行完以后所返回的结果。 在上面四个方法中只有doInBackground在子线程中运行，其余都三个方法都是在主线程中运行的。其中的…表示参数的数量不定，是一种数组类型的参数。 下面我们就来写一个例子来看一下AsyncTask的用法，在这里我们就一个下载的功能，从网络上下载两个文件。我们先来看一下效果演示。 效果演示 代码分析 由于我们做的下载任务，首先我们就得添加访问网络权限以及一些sd卡相关的权限。123456&lt;!-- 在SD卡中创建与删除文件权限 --&gt;&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt;&lt;!-- 向SD卡写入数据权限 --&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;!-- 授权访问网络 --&gt;&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 下面我们来看一下Activity代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.example.ljd.asynctask;import android.app.ProgressDialog;import android.os.AsyncTask;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;import java.io.BufferedInputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private DownloadAsyncTask mDownloadAsyncTask; private Button mButton; private String[] path = &#123; "http://msoftdl.360.cn/mobilesafe/shouji360/360safesis/360MobileSafe_6.2.3.1060.apk", "http://dlsw.baidu.com/sw-search-sp/soft/7b/33461/freeime.1406862029.exe", &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button)findViewById(R.id.button); mButton.setOnClickListener(this); &#125; @Override protected void onDestroy() &#123; if (mDownloadAsyncTask != null)&#123; mDownloadAsyncTask.cancel(true); &#125; super.onDestroy(); &#125; @Override public void onClick(View v) &#123; mDownloadAsyncTask = new DownloadAsyncTask(); mDownloadAsyncTask.execute(path); &#125; class DownloadAsyncTask extends AsyncTask&lt;String,Integer,Boolean&gt;&#123; private ProgressDialog mPBar; private int fileSize; //下载的文件大小 @Override protected void onPreExecute() &#123; super.onPreExecute(); mPBar = new ProgressDialog(MainActivity.this); mPBar.setProgressNumberFormat("%1d KB/%2d KB"); mPBar.setTitle("下载"); mPBar.setMessage("正在下载，请稍后..."); mPBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); mPBar.setCancelable(false); mPBar.show(); &#125; @Override protected Boolean doInBackground(String... params) &#123; //下载图片 for (int i=0;i&lt;params.length;i++)&#123; try&#123; if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; URL url = new URL(params[i]); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //设置超时时间 conn.setConnectTimeout(5000); //获取下载文件的大小 fileSize = conn.getContentLength(); InputStream is = conn.getInputStream(); //获取文件名称 String fileName = path[i].substring(path[i].lastIndexOf("/") + 1); File file = new File(Environment.getExternalStorageDirectory(), fileName); FileOutputStream fos = new FileOutputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] buffer = new byte[1024]; int len ; int total = 0; while((len =bis.read(buffer))!=-1)&#123; fos.write(buffer, 0, len); total += len; publishProgress(total); fos.flush(); &#125; fos.close(); bis.close(); is.close(); &#125; else&#123; return false; &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); return false; &#125; &#125; return true; &#125; @Override protected void onPostExecute(Boolean aBoolean) &#123; super.onPostExecute(aBoolean); mPBar.dismiss(); if (aBoolean)&#123; Toast.makeText(MainActivity.this,"下载完成",Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(MainActivity.this,"下载失败",Toast.LENGTH_SHORT).show(); &#125; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); mPBar.setMax(fileSize / 1024); mPBar.setProgress(values[0]/1024); &#125; &#125;&#125; 在以上代码中有几点我们需要注意一下。 1. AsyncTask中的execute方法必须在主线程中执行。 2. 每个AsyncTask对象只能执行一次execute方法。 3. 当我们的Activity销毁的时候需要进行取消操作，其中boolean型的参数mayInterruptIfRunning表示是否中断后台任务。 最后的布局代码就很简单了，只有一个Button而已。123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="@dimen/activity_vertical_margin" android:orientation="vertical" tools:context="com.example.ljd.asynctask.MainActivity"&gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="download"/&gt;&lt;/LinearLayout&gt; 这里还有一点需要说明一下，由于在不同的Android版本中对AsyncTask进行了多次修改，所以当我们通过多个AsyncTask对象执行多次execute方法的时候，它们执行顺序是串行还是并行根据系统不同的版本而出现差异，这里就不再具体分析。 AsyncTask源码分析 在这里我们采用Android6.0中的AsyncTask源码进行分析，对于不同系统的AsyncTask代码会有一定的差异。当创建一个AsyncTask对象以后我们便可以通过execute方法来执行整个任务。那就在这里首先看一下execute方法中的代码。1234@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 可以看到这个execute方法中的代码是如此的简单，只是执行了executeOnExecutor方法并返回AsyncTask对象。下面我们就来看一下executeOnExecutor这个方法。123456789101112131415161718192021222324@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 在这个方法内我们首先对AsyncTask所执行的状态进行判断。如果AsyncTask正在执行任务或者任务已经知己完成就会给我们抛出异常，也就解释上面所说的每个AsyncTask对象只能执行一次execute方法。紧接着将当前任务状态修改为正在运行以后便开始执行onPreExecute方法。这也说明了在上面我们重写的四个方法中onPreExecute方法最先指向的。下面我们在看一下mWorker和mFuture这两个全局变量。 mFuture是FutureTask对象，而mWorker是WorkerRunnable对象，WorkerRunnable是AsyncTask中的一个实现Callable接口的抽象内部类，在WorkerRunnable中只定义了一个Params[]。12345678private final WorkerRunnable&lt;Params, Result&gt; mWorker;private final FutureTask&lt;Result&gt; mFuture;......private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125; mFuture和mWorker是在AsyncTask的构造方法中初始化的。我们看一下AsyncTask的构造方法。1234567891011121314151617181920212223242526272829public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException("An error occurred while executing doInBackground()", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 在这里首先创建一个WorkerRunnable对象mWorker，并且实现了Callable接口的call方法，对于这个call方面里面的内容在后面会进行详细说明。然后我们再通过mWorker，创建一个FutureTask对象mFuture，并且重写里面的done方法，当我们调用AsyncTask里面的cancel方法时，在FutureTask中会调用这个done方法。在这里介绍完mWorker和mFuture后我们再回过头来看executeOnExecutor方法。在这里通过我们传入的params参数初始化了mWorker中的mParams。而下面的exec则是在execute里面传入的sDefaultExecutor，并且执行sDefaultExecutor的execute方法。下面我们再来看一下这个sDefaultExecutor对象。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); public static final Executor SERIAL_EXECUTOR = new SerialExecutor();......private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;......private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 在这里首先整体介绍一下这段代码。这段代码的主要功能就是创建了两个线程池SerialExecutor和THREAD_POOL_EXECUTOR。SerialExecutor线程池用于对任务的排队，而THREAD_POOL_EXECUTOR则是用来执行任务。而sDefaultExecutor就是SerialExecutor线程池。 我们进入SerialExecutor代码中看一下里面的内容。SerialExecutor中的execute方法内的参数Runnable就是我们传入的mFuture。在execute方法中创建了一个Runnable对象，并将该队列插入对象尾部。这个时候如果是第一次执行任务。mActive必然为null，这时候便调用scheduleNext方法从队列中取出Runnable对象，并且通过THREAD_POOL_EXECUTOR线程池执行任务。我们可以看到在队列中的Runnable的run方法中首先执行mFuture中的run方法，执行完之后又会调用scheduleNext方法，从队列中取出Runnable执行，直到所有的Runnable执行完为止。下面就来看一下在线城池中是如何执行这个Runnable的。从上面代码可以看出，在线城池中执行Runnable其实最核心的部分还是执行mFuture的run方法。那就来看一下这个mFuture中的run方法。12345678910111213141516171819202122232425262728293031public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 在这个方法中的callable对象就是我们AsyncTask中的mWorker对象。在这里面也正是执行mWorker中的call方法来完成一些耗时任务，于是我们就能想到我重写的doInBackground应该就在这个call方法中执行了。现在再回到AsyncTask的构造方法中看一下这个mWorker中的call方法。123456789public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result);&#125; 这里我们很清楚的看到它执行我们重写的doInBackground方法，并且将返回的结果传到postResult方法中。下面就在看一下这个postResult方法。1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 对与这个postResult方法里面也就是在我们子线程的任务处理完成之后通过一个Handler对象将Message发送到主线程中，并且交由主线程处理。AsyncTaskResult对象中存放的是子线程返回的结果以及当前AsyncTask对象。下面再看一下这和Handler中所处理了哪些事情。1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 可以看到在这个Handler的handleMessage中会接受到两种Message。在MESSAGE_POST_PROGRESS这个消息中主要是通过publishProgress方法将子线程执行的进度发送到主线程中并且通过onProgressUpdate方法来更新进度条的显示。在MESSAGE_POST_RESULT这个消息中通过当前的AsyncTask对象调用了finish方法，那么就来看一下这个finish方法。12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 这时候就可以看出若是我们取消了AsyncTask的话就不在执行onPostExecute方法，而是执行onCancelled方法，所以我们可以通过重写onCancelled方法来执行取消时我们需要处理的一些操作。当然若是AsyncTask没有被取消，这时候就回执行onPostExecute方法。到这里整个AsyncTask任务也就完成了。 总结 在上面的SerialExecutor线程池中可以看出，当有多个异步任务同时执行的时候，它们执行的顺序是串行的，会按照任务创建的先后顺序进行一次执行。如果我们希望多个任务并发执行则可以通过AsyncTask中的setDefaultExecutor方法将线程池设为THREAD_POOL_EXECUTOR即可。 对于AsyncTask的在不同版本之间的差异不得不提一下。在Android1.6，AsyncTask采用的是串行执行任务，在Android1.6的时候采用线程池处理并行任务，而在3.0以后才通过SerialExecutor线程池串行处理任务。在Android4.1之前AsyncTask类必须在主线程中，但是在之后的版本中就被系统自动完成。而在Android5.0的版本中会在ActivityThread的main方法中执行AsyncTask的init方法，而在Android6.0中又将init方法删除。所以在使用这个AsyncTask的时候若是适配更多的系统的版本的话，使用的时候就要注意了。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AsyncTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService—Handler与Service的结合]]></title>
    <url>%2F2016%2F03%2F18%2Fintentservice%2F</url>
    <content type="text"><![CDATA[我们都知道Service是作为后台服务运行再程序中的。但是Service他依然是运行在主线程中的，所以我们依然不能在Service中进行耗时的操作。所以当我们在Service处理时，我们需要在Service中开启一个子线程，并且在子线程中运行。当然为了简化我们的操作，在Android中为我们提供了IntentService来进行这一处理，下面我们就来看一下这个IntentService用法以及它的工作原理。 用法简介 IntentService它继承自Service，一来说我们开启一个Service可以通过startService和bindService两个方式进行开启一个服务，但是对于IntentService我们采用startService方法进行开启服务，对于为什么要这么做，在后面会进行分析讲解。下面我们来看一下如何使用这个IntentService的。 效果演示 在这里我们做一个倒计时的程序，以毫秒为单位。这里先看一下效果演示。 代码分析 在这里我们使用到了开源框架EventBus，对于EventBus的使用可以参考 EventBus3.0使用详解这篇文章。由于我们用到这EventBus,首先我们创建一个实体类，在EventBus中进行发送，接收处理。12345678910111213package com.example.ljd.intentservice;public class Counter &#123; public Counter(int progress,int tag) &#123; this.progress = progress; this.tag = tag; &#125; public int progress; //进度显示 public int tag; //TextView的Tag&#125; 下面我们看一下IntentService中的代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.ljd.intentservice;import android.app.IntentService;import android.content.Intent;import android.content.Context;import org.greenrobot.eventbus.EventBus;public class MyIntentService extends IntentService &#123; private static final String ACTION_COUNTER = "com.example.ljd.intentservice.action.COUNTER"; private static final String EXTRA_SEC = "com.example.ljd.intentservice.extra.SECOND"; private static final String EXTRA_TAG = "com.example.ljd.intentservice.extra.TAG"; private static final int SLEEP_TIME = 1; public MyIntentService() &#123; super("MyIntentService"); &#125; public static void startDownload(Context context, int second,int tag) &#123; Intent intent = new Intent(context, MyIntentService.class); intent.setAction(ACTION_COUNTER); intent.putExtra(EXTRA_SEC, second); intent.putExtra(EXTRA_TAG,tag); context.startService(intent); &#125; @Override protected void onHandleIntent(Intent intent) &#123; if (intent != null) &#123; final String action = intent.getAction(); if (ACTION_COUNTER.equals(action)) &#123; final int second = intent.getIntExtra(EXTRA_SEC, 0); final int tag = intent.getIntExtra(EXTRA_TAG,0); handleActionFoo(second,tag); &#125; &#125; &#125; private void handleActionFoo(int sec,int tag) &#123; int millis = sec * 1000; Counter counter = new Counter(0,tag); for (int i = millis;i &gt;= 0; i-=SLEEP_TIME)&#123; counter.progress = i; EventBus.getDefault().post(counter); try &#123; Thread.sleep(SLEEP_TIME); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 在上面的handleActionFoo方法中进行我们的耗时任务。然后我们在看一下Activity中的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.example.ljd.intentservice;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.LinearLayout;import android.widget.TextView;import org.greenrobot.eventbus.EventBus;import org.greenrobot.eventbus.Subscribe;import org.greenrobot.eventbus.ThreadMode;import java.util.Random;public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private int mTextViewTag; private Button mAddButton; private LinearLayout mContainerLinear; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this); mTextViewTag = 0; mAddButton = (Button) findViewById(R.id.add_btn); mContainerLinear = (LinearLayout) findViewById(R.id.linear_container); mAddButton.setOnClickListener(this); &#125; @Subscribe(threadMode = ThreadMode.MAIN) public void OnEventProgress(Counter counter)&#123; TextView textView = (TextView)mContainerLinear.findViewWithTag(counter.tag); textView.setText(counter.progress + "ms"); &#125; @Override protected void onDestroy() &#123; EventBus.getDefault().unregister(this); super.onDestroy(); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.add_btn: //生成1~3之间的随机数 Random random = new Random(); int num = random.nextInt(3)%(3) + 1; TextView textView = new TextView(this); textView.setTag(mTextViewTag); textView.setText(num * 1000 + "ms"); mContainerLinear.addView(textView); MyIntentService.startDownload(this,num,mTextViewTag); mTextViewTag++; break; default: break; &#125; &#125;&#125; 最后是布局代码。123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.example.ljd.intentservice.MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/add_btn" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:text="add"/&gt; &lt;/LinearLayout&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/linear_container" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 对于上面代码实现起来都是非常的简单，在这里就不在进行详细介绍。 IntentService工作原理分析 其实对于IntentService的工作原理也不复杂，既然在IntentService中能够进行耗时操作，也就是说在这个IntentService中必然也创建了一个子线程，在Android中我们称为工作者线程。然后在这个工作者线程中进行我们的任务。在分析IntentService之前，我们先看一下HandlerThread。 HandlerThread 其实HandlerThread就是一个工作者线程，在这里看一下HandlerThread的源码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package android.os;public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; return mTid; &#125;&#125; 看过上篇文章 Android的消息机制——Handler的工作过程就很容易理解这个HandlerThread了。还记的我们在上篇文章的最后，新建了一个包含Looper的子线程。而这个HandlerThread也就是一个包含Looper的子线程。所以当我们需要创建一个包含Looper的线程时直接使用HandlerThread即可。对于HandlerThread有以下几点需要说明一下。 1. 在构造方法中设置线程优先级的时候，使用的Process是android.os包中的而不是java.lang包内的。 2. 如果在Looper开启消息循环之前我们进行一些设置，我们可以继承HandlerThread并且重写onLooperPrepared方法。 3. 通过getLooper方法我们获取HandlerThread的Looper对象时，有可能Looper还未创建完成。所以在getLooper中未创建Looper是进行了线程等待操作，在创建完Looper以后在返回Looper对象。 IntentService 下面我们再看一下IntentService。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package android.app;import android.annotation.WorkerThread;import android.content.Intent;import android.os.Handler;import android.os.HandlerThread;import android.os.IBinder;import android.os.Looper;import android.os.Message;public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(Intent intent);&#125; 我们看一下这个IntentService的构造是不是很简单。在这里主要看一下onCreate和onStart方法即可。在onCreate中，我们开启了一个HandlerThread线程，之后获取HandlerThread线程中的Looper，并通过这个Looper创建了一个Handler。然后在onStart方法中通过这个Handler将intent与startId作为Message的参数进行发送到消息队列中，然后交由Handler中的handleMessage中进行处理。由于在onStart方法是在主线程内运行的，而Handler是通过工作者线程HandlerThread中的Looper创建的。所以也就是在主线程中发送消息，在工作者接收到消息后便可以进行一些耗时的操作。 我们在看一下handleMessage中的操作，在handleMessage中调用onHandleIntent方法，他是一个抽象方法，所以在我们的Service中复写onHandleIntent方法并且将耗时的操作写在onHandleIntent方法内即可。当执行完onHandleIntent后通过stopSelf来停止服务，这样就不用我们手动停止服务了。所以也就回答了我们上面那个为什么要使用startService而不用onBind来开启一个IntentService。 总结 从我们的示例和源码分析中可以看出来。对于通过IntentService来执行任务，他是串行的。也就是说只有在上一个任务执行完以后才会执行下一个任务。因为Handler中将消息插入消息队列，而队列又是先进先出的数据结构。所以只有在上个任务执行完成以后才能够获取到下一个任务进行操作。在这里也就说明了对于高并发的任务同过IntentService是不合适。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的消息机制—Handler的工作过程]]></title>
    <url>%2F2016%2F03%2F14%2Fhandler%2F</url>
    <content type="text"><![CDATA[在Android系统中，出于对性能优化的考虑，对于Android的UI操作并不是线程安全的。也就是说若是有多个线程来操作UI组件，就会有可能导致线程安全问题。所以在Android中规定只能在UI线程中对UI进行操作。这个UI线程是在应用第一次启动时开启的，也称之为主线程（Main Thread），该线程专门用来操作UI组件，在这个UI线程中我们不能进行耗时操作，否则就会出现ANR(Application Not Responding)现象。如果我们在子线程中去操作UI，那么程序就回给我们抛出异常。这是因为在ViewRootImpl中对操作UI的线程进行检查。如果操作UI的线程不是主线程则抛出异常（对于在检查线程之前在非UI线程已经操作UI组件的情况除外）。所以这时候我们若是在子线程中更新UI的话可以通过Handler来完成这一操作。 Handler用法简介 在开发中，我们对Handler的使用也基本上算是家常便饭了。在这里我们就简单的说一下Handler的几种用法示例，就不在具体给出Demo进行演示。在这里我们只针对后面这一种情形来看一下Handler的使用：在子线程完成任务后通过Handler发送消息，然后在主线程中去操作UI。 一般来说我们会在主线程中创建一个Handler的匿名内部类，然后重写它的handleMessage方法来处理我们的UI操作。代码如下所示。1234567891011121314private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; //根据msg.what的值来处理不同的UI操作 case WHAT: break; default: super.handleMessage(msg); break; &#125; &#125;&#125;; 我们还可以不去创建一个Handler的子类对象，直接去实现Handler里的CallBack接口，Handler通过回调CallBack接口里的handleMessage方法从而实现对UI的操作。1234567private Handler mHandler = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; return false; &#125;&#125;); 然后我们就可以在子线程中发送消息了。123456789101112131415new Thread(new Runnable() &#123; @Override public void run() &#123; //子线程任务 ... //发送方式一 直接发送一个空的Message mHandler.sendEmptyMessage(WHAT); //发送方式二 通过sendToTarget发送 mHandler.obtainMessage(WHAT,arg1,arg2,obj).sendToTarget(); //发送方式三 创建一个Message 通过sendMessage发送 Message message = mHandler.obtainMessage(); message.what = WHAT; mHandler.sendMessage(message); &#125;&#125;).start(); 在上面我们给出了三种不同的发送方式，当然对于我们还可以通过sendMessageDelayed进行延时发送等等。如果我们的Handler只需要处理一条消息的时候，我们可以通过post一系列方法进行处理。1234567891011121314private Handler mHandler = new Handler();new Thread(new Runnable() &#123; @Override public void run() &#123; mHandler.post(new Runnable() &#123; @Override public void run() &#123; //UI操作 ... &#125; &#125;); &#125;&#125;).start(); 在Handler中处理UI操作时，上面的Handler对象必须是在主线程创建的。如果我们想在子线程中去new一个Handler对象的话，就需要为Handler指定Looper。12345678910111213141516private Handler mHandler；new Thread(new Runnable() &#123; @Override public void run() &#123; mHandler = new Handler(Looper.getMainLooper())&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //UI操作 ... &#125; &#125;; &#125;&#125;).start(); 对于这个Looper是什么，下面我们会详细介绍。对于Handler的使用依然存在一个问题，由于我们创建的Handler是一个匿名内部类，他会隐式的持有外部类的一个对象（当然内部类也是一样的），而往往在子线程中是一个耗时的操作，而这个线程也持有Handler的引用，所以这个子线程间接的持有这个外部类的对象。我们假设这个外部类是一个Activity，而有一种情况就是我们的Activity已经销毁，而子线程仍在运行。由于这个线程持有Activity的对象，所以，在Handler中消息处理完之前，这个Activity就一直得不到回收，从而导致了内存泄露。如果内存泄露过多，则会导致OOM（OutOfMemory），也就是内存溢出。那么有没有什么好的解决办法呢？ 我们可以通过两种方案来解决，第一种方法我们在Activity销毁的同时也杀死这个子线程，并且将相对应的Message从消息队列中移除；第二种方案则是我们创建一个继承自Handler的静态内部类。因为静态内部类不会持有外部类的对象。可是这时候我们无法去访问外部类的非静态的成员变量，也就无法对UI进行操作。这时候我们就需要在这个静态内部类中使用弱引用的方式去指向这个Activity对象。下面我们看一下示例代码。12345678910111213141516static class MyHandler extends Handler&#123; private final WeakReference&lt;MyActivity&gt; mActivity; public MyHandler(MyActivity activity)&#123; super(); mActivity = new WeakReference&lt;MyActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MyActivity myActivity = mActivity.get(); if (myActivity!=null)&#123; myActivity.textView.setText("123456789"); &#125; &#125;&#125; Handler工作过程 在上面我们简单的说明了Handler是如何使用的。那么现在我们就来看一下这个Handler是如何工作的。在Android的消息机制中主要是由Handler,Looper,MessageQueue,Message等组成。而Handler得运行依赖后三者。那么我们就来看一下它们是如何联系在一起的。 Looper 在一个Android应用启动的时候，会创建一个主线程，也就是UI线程。而这个主线程也就是ActivityThread。在ActivityThread中有一个静态的main方法。这个main方法也就是我们应用程序的入口点。我们来看一下这个main方法。123456789101112131415public static void main(String[] args) &#123; ...... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); ...... Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在上面代码中通过prepareMainLooper方法为主线程创建一个Looper,而loop则是开启消息循环。从上面代码我们可以猜想到在loop方法中应该存在一个死循环，否则给我们抛出RuntimeException。也就是说主线程的消息循环是不允许被退出的。下面我们就来看一下这个Looper类。 首先我们看一下Looper的构造方法。1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 在这个构造方法中创建了一个消息队列。并且保存当前线程的对象。其中quitAllowed参数表示是否允许退出消息循环。但是我们注意到这个构造方法是private，也就是说我们自己不能手动new一个Looper对象。那么我们就来看一下如何创建一个Looper对象。之后在Looper类中我们找到下面这个方法。123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 在这里新建了一个Looper对象，然后将这个对象保存在ThreadLocal中，当我们下次需要用到Looper的之后直接从这个sThreadLocal中取出即可。在这里简单说明一下ThreadLocal这个类，ThreadLocal它实现了本地变量存储，我们将当前线程的数据存放在ThreadLocal中，若是有多个变量共用一个ThreadLocal对象，这时候在当前线程只能获取该线程所存储的变量，而无法获取其他线程的数据。在Looper这个类中为我们提供了myLooper来获取当前线程的Looper对象。从上面的方法还能够看出，一个线程只能创建一次Looper对象。然后我们在看一下这个prepare在哪里被使用的。12345678910111213public static void prepare() &#123; prepare(true);&#125;public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; prepare方法：这个是用于在子线程中创建一个Looper对象，在子线程中是可以退出消息循环的。 prepareMainLooper方法：这个方法在上面的ActivityThread中的main方法中我们就已经见到过了。它是为主线程创建一个Looper，在主线程创建Looper对象中，就设置了不允许退出消息循环。并且将主线程的Looper保存在sMainLooper中，我们可以通过getMainLooper方法来获取主线程的Looper。 在ActivityThread中的main方法中除了创建一个Looper对象外，还做了另外一件事，那就是通过loop方法开启消息循环。那么我们就来看一下这个loop方法做了什么事情。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 第2~6行：获取当前线程中的Looper，并从Looper中获得消息队列。 第10~11行：确保当前线程属于当前进程，并且记录真实的token。clearCallingIdentity的实现是在native层，对于具体是如何实现的就不在进行分析。 第14~18行：从消息队列中取出消息，并且只有当取出的消息为空的时候才会跳出循环。 第27行：将消息重新交由Handler处理。 第35~42行：确保调用过程中线程没有被销毁。 第44行：对消息进行回收处理。 和我们刚才猜想的一样，在loop中确实存在一个死循环，而唯一退出该循环的方式就是消息队列返回的消息为空。然后我们通过消息队列的next()方法获得消息。msg.target是发送消息的Handler，通过Handler中的dispatchMessage方法又将消息交由Handler处理。消息处理完成之后便对消息进行回收处理。在这里我们也能够通过quit和quitSafely退出消息循环。1234567public void quit() &#123; mQueue.quit(false);&#125;public void quitSafely() &#123; mQueue.quit(true);&#125; 我们可以看出对于消息循环的退出，实际上就是调用消息队列的quit方法。这时候从MessageQueue的next方法中取出的消息也就是null了。下面我们来看一下这个MessageQueue。 MessageQueue MessageQueue翻译为消息队里，在这个消息队列中是采用单链表的方式实现的，提高插入删除的效率。对于MessageQueue在这里我们也只看一下它的入队和出队操作。 MessageQueue入队方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; ...... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 在这里我们简单说一下这个入队的方法。消息的插入过程是在第13~36行完成了。在这里首先判断首先判断消息队列里有没有消息，没有的话则将当前插入的消息作为队头，并且这时消息队列如果处于等待状态的话则将其唤醒。若是在中间插入，则根据Message创建的时间进行插入。 MessageQueue出队方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Message next() &#123; ...... int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; ...... &#125; ..... &#125;&#125; 第11行：nativePollOnce方法在native层，若是nextPollTimeoutMillis为-1，这时候消息队列处于等待状态。 第25~42行：按照我们设置的时间取出消息。 第43~45行：这时候消息队列中没有消息，将nextPollTimeoutMillis设为-1，下次循环消息队列则处于等待状态。 第48~52行：退出消息队列，返回null，这时候Looper中的消息循环也会终止。 最后我们在看一下退出消息队列的方法：123456789101112131415161718192021void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit."); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 从上面我们可以看到主线程的消息队列是不允许被退出的。并且在这里通过将mQuitting设为true从而退出消息队列。也使得消息循环被退出。到这里我们介绍了Looper和MessageQueue，就来看一下二者在Handler中的作用。 Handler 在这里我们首先看一下Handler的构造方法。12345678910111213public Handler(Callback callback, boolean async) &#123; ...... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 从这个构造方法中我们可以看出在一个没有创建Looper的线程中是无法创建一个Handler对象的。所以说我们在子线程中创建一个Handler时首先需要创建Looper，并且开启消息循环才能够使用这个Handler。但是在上面的例子中我们确实在子线程中new了一个Handler对象。我们再来看一下上面那个例子的构造方法。123456public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 在这个构造方法中我们为Handler指定了一个Looper对象。也就说在上面的例子中我们在子线程创建的Handler中为其指定了主线程的Looper，也就等价于在主线程中创建Handler对象。下面我们就来看一下Handler是如何发送消息的。 对于Handler的发送方式可以分为post和send两种方式。我们先来看一下这个post的发送方式。1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 在这里很明显可以看出来，将post参数中的Runnable转换成了Message对象，然后还是通过send方式发出消息。我们就来看一下这个getPostMessage方法。12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 在这里也是将我们实现的Runnable交给了Message对象的callback属性。并返回该Message对象。 既然post发送也是由send发送方式进行的，那么我们一路找下去，最终消息的发送交由sendMessageAtTime方法进行处理。我们就来看一下这个sendMessageAtTime方法。12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 然后再来看一下enqueueMessage方法。1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 到这里我们可以看出来了所谓通过Handler发送消息只不过是在Looper创建的消息队列中插入一条消息而已。而在Looper中只不过通过loop取出消息，然后交由Handler中的dispatchMessage方发进行消息分发处理。下面我们来看一下dispatchMessage方法。123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 这里面的逻辑也是非常的简单，msg.callback就是我们通过post里的Runnable对象。而handleCallback也就是去执行Runnable中的run方法。123private static void handleCallback(Message message) &#123; message.callback.run();&#125; mCallback就是我们所实现的回调接口。最后才是对我们继承Handler类中重写的handleMessage进行执行。可见其中的优先级顺序为post&gt;CallBack&gt;send; 到这里我们对整个Handler的工作过程也就分析完了。现在我们想要通过主线程发送消息给子线程，然后由子线程接收消息并进行处理。这样一种操作也就很容易实现了。我们来看一下怎么实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.ljd.myapplication;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.util.Log;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;public class MyActivity extends AppCompatActivity &#123; private final String TAG = "MyActivity"; public Handler mHandler; public Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.send_btn); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (mHandler != null)&#123; mHandler.obtainMessage(0,"你好，我是从主线程过来的").sendToTarget(); &#125; &#125; &#125;); new Thread(new Runnable() &#123; @Override public void run() &#123; //在子线程中创建一个Looper对象 Looper.prepare(); mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == 0)&#123; Log.d(TAG,(String)msg.obj); &#125; &#125; &#125;; //开启消息循环 Looper.loop(); &#125; &#125;).start(); &#125;&#125; 点击按钮我们看一下运行结果。 总结 在这里我们重新整理一下我们的思路，看一下这个Handler的整个工作流程。在主线程创建的时候为主线程创建一个Looper,创建Looper的同时在Looper内部创建一个消息队列。而在创键Handler的时候取出当前线程的Looper，并通过该Looper对象获得消息队列，然后Handler在子线程中发送消息也就是在该消息队列中添加一条Message。最后通过Looper中的消息循环取得这条Message并且交由Handler处理。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus3.0使用详解]]></title>
    <url>%2F2016%2F03%2F12%2Feventbus3.0-use%2F</url>
    <content type="text"><![CDATA[这里所介绍的EventBus指的是greenrobot的EventBus，它是一款针对Android的发布/订阅事件总线。它能够让我们很轻松的实现在Android的各个组件以及线程之间进行传递消息。并且将事件的发送者与接收者之间进行解耦。而且他还是轻量级的Android类库。对于EventBus3.0中相对于先前的版本中用法有所改变，那么下面我们就来看一下如何使用这个EventBus; 使用方法 对于EventBus的使用也是非常简单的，事件的发送方将事件发出，通过EventBus将事件传递给改事件的订阅者进行使用。 基本用法 首先我们需要将EventBus添加到我们的项目中。在AndroidStudio中我们可以在gradle里面直接配置即可。1compile &apos;org.greenrobot:eventbus:3.0.0&apos; 当然我们也可以下载EventBus的jar包导入我们的项目里面。在这里我们写一个小例子来看一下EventBus最基本的用法。在这里为了方便我们的观察，我们就将一个Activity分为左右两个部分，分别在里面添加一个Fragment，左边的Fragment用于事件的发送，右边的Fragment用于接收事件。 在这里我们先看一下效果演示。 我们需要创建一个实体类作为EventBus中的事件12345678910package com.ljd.example.eventbus;public class MessageEvent &#123; public final String message; public MessageEvent(String message) &#123; this.message = message; &#125;&#125; 然后我们在创建一个Activity。12345678910111213package com.ljd.example.eventbus;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 在这里我们可以看到在Activity当中只是加载一下布局文件，之后什么也没有做，其实所有的事情都交给了Fragment来处理。下面我们看一下Activity的布局。 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal" tools:context="com.ljd.example.eventbus.MainActivity"&gt; &lt;Fragment android:id="@+id/left_Fragment" android:name="com.ljd.example.eventbus.LeftFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt;&lt;/Fragment&gt; &lt;TextView android:layout_width="1dp" android:layout_height="match_parent" android:background="@color/gray"/&gt; &lt;Fragment android:id="@+id/right_Fragment" android:name="com.ljd.example.eventbus.RightFragment" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"&gt;&lt;/Fragment&gt;&lt;/LinearLayout&gt; 在这里我们将Fragment当做一个View，直接写入布局文件中。下面看一下左边的Fragment。12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ljd.example.eventbus;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.LinearLayout;import org.greenrobot.eventbus.EventBus;/** * A simple &#123;@link Fragment&#125; subclass. */public class LeftFragment extends Fragment &#123; private LinearLayout buttonLinear; public LeftFragment() &#123; // Required empty public constructor &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.Fragment_left, container, false); buttonLinear = (LinearLayout)view.findViewById(R.id.left_Fragment_linear); sendEvent(); return view; &#125; private void sendEvent()&#123; Button button = new Button(getActivity()); button.setText("SEND"); buttonLinear.addView(button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; EventBus.getDefault().post(new MessageEvent("Hello everyone!")); &#125; &#125;); &#125;&#125; 这里我们注意到我们通过EventBus.getDefault()去获取一个EventBus对象，然后通过post方法进行发送事件。这时候就完成了事件的发布过程。下面我们再看一下右边的Fragment是如何接收事件的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ljd.example.eventbus;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import android.widget.TextView;import org.greenrobot.eventbus.EventBus;import org.greenrobot.eventbus.Subscribe;/** * A simple &#123;@link Fragment&#125; subclass. */public class RightFragment extends Fragment &#123; private LinearLayout mTextViewLinear; public RightFragment() &#123; // Required empty public constructor &#125; @Override public void onStart() &#123; super.onStart(); EventBus.getDefault().register(this); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.Fragment_right, container, false); mTextViewLinear = (LinearLayout)view.findViewById(R.id.right_Fragment_linear); return view; &#125; @Override public void onStop() &#123; EventBus.getDefault().unregister(this); super.onStop(); &#125; @Subscribe public void onMessage(MessageEvent event) &#123; TextView textView = new TextView(getActivity()); textView.setText(event.message); mTextViewLinear.addView(textView); &#125;&#125; 对于这两个Fragment的布局非常简单，里面只包含一个垂直方向的线性布局。在这里就不在贴出。下面我们就来看一下EventBus是如何来接收事件的。 如果我们需要接收某个事件并进行处理的话，首先我们需要通过EventBus.getDefault().register(this)将订阅者的对象注册到EventBus中，当我们不在使用这个事件时还需要通过EventBus.getDefault().unregister(this)解除注册。这时候我们就可以再写一个方法，参数为所要接收事件的对象，并且在该方法上需要添加@Subscribe来标示这个方法为接收事件的方法。这时候我们就可以接收事件并且对事件进行处理。 在这里有一点需要注意，在EventBus3.0中接收事件的方法是通过@Subscribe来标识的，方法名可以随意写。而在EventBus先前的版本中接收事件的方法必须是以onEvent开头的四个方法。它们分别是onEvent，onEventMainThread，onEventBackground，onEventAsync。 EventBus中的线程模式 在上面的例子中我们可以看到，我们是在主线程（也称为UI线程）中去提交事件，然后订阅者也是在主线程中对事件进行的处理。但是在Android开发中我们都知道无法在主线程中去执行一个耗时的任务，并且子线程中我们也无法进行更新UI的操作。那么这时候问题就来了，这里再上一个例子的基础上假设一种情形，我们在左边的Fragment中从网络中获取到数据，然后将从网络获取到的数据在右边的Fragment中显示。可是在Android4.0以后我们无法在主线程中去请求网络，也就是说我们只能在子线程中请求数据，然后在子线程中去提交事件。那么这时候订阅者的方法是在主线程中执行还是在子线程中执行的呢？这里就要来看一下EventBus中的ThreadMode了。EventBus的ThreadMode总共有四种，并且都是在订阅者中的@Subscribe里进行制定的。下面我们就来看一下这四种ThreadMode。 1. ThreadMode: POSTING 这时候订阅者执行的线程与事件的发布者所在的线程为同一个线程。也就是说事件由哪个线程发布的，订阅者就在哪个线程中执行。这个也是EventBus默认的线程模式，也就是说在上面的例子中用的就是这种ThreadMode。由于没有线程的切换，也就意味消耗的资源也是最小的。如果一个任务不需要多线程的，也是推荐使用这种ThreadMode的。在EventBus以前的版本中对应onEvent方法。使用例子：12345//与事件的提交者运行在同一个线程（默认的ThreadMode）@Subscribe(threadMode = ThreadMode.POSTING) // 这里的threadMode可以省略不写public void onMessage(MessageEvent event) &#123; log(event.message);&#125; 2. ThreadMode: MAIN 从它的名字就很容易可以看出，他是在Android的主线程中运行的。如果提交的线程也是主线程，那么他就和ThreadMode.POSTING一样了。当然在这里由于是在主线程中运行的，所以在这里就不能执行一些耗时的任务。在EventBus以前的版本中对应onEventMainThread方法。使用例子：12345// 在Android的主线程中运行@Subscribe(threadMode = ThreadMode.MAIN)public void onMessage(MessageEvent event) &#123; textField.setText(event.message);&#125; 3. ThreadMode: BACKGROUND 这种模式下，我们的订阅者将会在后台线程中执行。如果发布者是在主线程中进行的事件发布，那么订阅者将会重新开启一个子线程运行，若是发布者在不是在主线程中进行的事件发布，那么这时候订阅者就在发布者所在的线程中执行任务。在EventBus以前的版本中对应onEventBackground方法。使用例子：12345// 在后台线程中执行@Subscribe(threadMode = ThreadMode.BACKGROUND)public void onMessage(MessageEvent event)&#123; saveToDisk(event.message);&#125; 4. ThreadMode: ASYNC 在这种模式下，订阅者将会独立运行在一个线程中。不管发布者是在主线程还是在子线程中进行事件的发布，订阅者都是在重新开启一个线程来执行任务。在EventBus以前的版本中对应onEventAsync方法。使用例子：12345// 在独立的线程中执行@Subscribe(threadMode = ThreadMode.ASYNC)public void onMessage(MessageEvent event)&#123; backend.send(event.message);&#125; 对于EventBus的线程模式讲了这么多，下面我们来写一个例子验证一下上面对应的四种ThreadMode。我们就在上面的例子中添加一些内容。首先在左边的Fragment中添加一个发送按钮，用来提交事件。并且这个发布者发送事件是在子线程中运行的。我们看一下关键代码。12345678910111213141516171819202122private void testThreadMode()&#123; Button button = new Button(getActivity()); button.setText("TEST THREAD MODE"); mButtonLinear.addView(button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Log.d(TAG,"订阅者线程ID:"+Thread.currentThread().getId()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; EventBus.getDefault().post(new MessageEvent("Hello everyone!")); &#125; &#125;).start(); &#125; &#125;);&#125; 在上面发布事件过程中我们使线程休眠5秒钟时间，用来模拟耗时操作。下面我们在右边的Fragment中添加如下代码进行测试。 123456789101112131415161718192021222324252627282930313233343536@Subscribe(threadMode = ThreadMode.POSTING)public void onPostingModeMessage(MessageEvent event)&#123; Log.d(TAG, getResultString("ThreadMode:POSTING",event.message));&#125;@Subscribe(threadMode = ThreadMode.MAIN)public void onMainModeMessage(MessageEvent event)&#123; Log.d(TAG, getResultString("ThreadMode:MAIN",event.message));&#125;@Subscribe(threadMode = ThreadMode.BACKGROUND)public void onBackgroundModeMessage(MessageEvent event)&#123; Log.d(TAG, getResultString("ThreadMode:BACKGROUND",event.message));&#125;@Subscribe(threadMode = ThreadMode.ASYNC)public void onAsyncModeMessage(MessageEvent event)&#123; Log.d(TAG, getResultString("ThreadMode:ASYNC",event.message));&#125;private String getResultString(String threadMode,String msg)&#123; StringBuilder sb = new StringBuilder(""); sb.append(threadMode) .append("\n接收到的消息：") .append(msg) .append("\n线程id:") .append(Thread.currentThread().getId()) .append("\n是否是主线程：") .append(Looper.getMainLooper() == Looper.myLooper()) .append("\n"); return sb.toString();&#125; 在这里只贴出了关键代码，具体源码可以通过下面链接进行下载。在这里我们点击这个Button发送一个事件，然后我们从logcat中看一下输出的信息。 从上面的结果我们可以看出来由于事件的发布者是在子线程中，所以BACKGROUND与POSTING模式下订阅者与事件的发布者运行在同一个线层。而ASYNC模式下又重新开起一个线程来执行任务。Main模式则是在主线程中运行。 优先级与事件的取消 在订阅者中我们也可以为其设置优先级，优先级高的将会首先接收到发布者所发布的事件。并且我们还能在高优先中取消事件，这时候的优先级的订阅者将接收不到事件。这类似于BroadcastReceiver中的取消广播。不过这里有一点我们要注意，对于订阅者的优先级只是针对于相同的ThreadMode中。默认的优先级为0。下面我们来做一个测试。 在上面的例子中我们添加一下代码。12345678910111213141516171819202122232425@Subscribe(priority = 1)public void onPriority1Message(MessageEvent event)&#123; Log.d(TAG, "priority = 1:" + event.message);&#125;@Subscribe(priority = 2)public void onPriority2Message(MessageEvent event)&#123; Log.d(TAG, "priority = 2:" + event.message); EventBus.getDefault().cancelEventDelivery(event) ;&#125;@Subscribe(priority = 4)public void onPriority4Message(MessageEvent event)&#123; Log.d(TAG, "priority = 4:" + event.message);&#125;@Subscribe(priority = 3)public void onPriority3Message(MessageEvent event)&#123; Log.d(TAG, "priority = 3:" + event.message);&#125; 在这里我们将优先级为2的接收事件的方法中取消事件，这么一来优先级为1的将接收不到该事件。下面我们来看一下运行结果。 在这里我们可以清楚的看到优先级高的首先接收到事件，并且成功取消该事件。 订阅者索引 对于上面所描述的EventBus的功能，是通过Java反射来获取订阅方法，这样以来大大降低了EventBus的效率，同时也影响了我们应用程序的效率。其实对于反射的处理解析不仅仅只能够通过Java反射的方式来进行，还能够通过apt(Annotation Processing Tool)来处理。为了提高效率，EventBus提供这中方式来完成EventBus的执行过程。下面就来看一下对于EventBus的另一种使用方式。 在Project的build.gradle中添加如下代码：12345buildscript &#123; dependencies &#123; classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125;&#125; 然后在app的build.gradle中添加如下代码。1234567891011apply plugin: 'com.neenbedankt.android-apt'dependencies &#123; compile 'org.greenrobot:eventbus:3.0.0' apt 'org.greenrobot:eventbus-annotation-processor:3.0.1'&#125;apt &#123; arguments &#123; eventBusIndex "com.example.myapp.MyEventBusIndex" &#125;&#125; 在当我们使用EventBus以后，在我们的项目没有错误的情况下重新rebuild之后会在build目录下面生成MyEventBusIndex文件，文件名可以自定义。下面就来看一下如何使用这个MyEventBusIndex。 我们可以自定义设置自己的EventBus来为其添加MyEventBusIndex对象。代码如下所示：1EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build(); 我们也能够将MyEventBusIndex对象安装在默认的EventBus对象当中。代码如下所示：123EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();// Now the default instance uses the given index. Use it like this:EventBus eventBus = EventBus.getDefault(); 剩下对于EventBus的用法则是一模一样。当然也建议通过添加订阅者索引这种方式来使用EventBus，这样会比通过反射的方式来解析注解效率更高。 ProGuard 当我们使用ProGuard混淆时，我们还需要在我们的ProGuard的配置文件中添加如下代码。12345678910-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125; 总结 对于EventBus的使用我们就说到这里，对于EventBus想要有更深入的了解，我们可以去github上下载EventBus源码进行研究。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(七)—Socket的原理简析与使用]]></title>
    <url>%2F2016%2F03%2F06%2Fipc-07%2F</url>
    <content type="text"><![CDATA[在前面的几篇文章中，我们介绍了许多在Android中有关进程间通信的方式，但都是在一个设备上进行的进程间通信，而这时候我们两个应用在不同的设备上的时候，在这个时候我们就不能通过前方介绍的那些方法来解决了。但是我们通过网络进行通信来处理这个问题。今天就来介绍一下Android中网络通信的其中一种方式——Socket。Socket翻译为中文为套接字，而现在套接字也成为了操作系统中的一部分。下面我们就来看一下如何使用这个套接字的。 TCP/IP介绍 这里有一点需要说明一下，在Internet所使用的各种协议中，最重要的和最著名的就是TCP和IP两个协议。而我们现在经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示Internet所使用的整个TCP/IP协议族。 TCP/IP的体系结构 TCP/IP协议可以为各式各样的应用提供服务，同时TCP/IP协议也允许IP协议在各式各样的网络构成的互联网上运行。TCP/IP协议是一个四层的体系结构，它包含应用层、传输层、网络层、网络接口层。在传输层中主要使用的有两种协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）。下面是TCP/IP体系结构示意图。 传输控制协议TCP TCP是TCP/IP体系中非常复杂的一个协议，在这里我们简单看一下TCP协议的特点，对于TCP协议的详细内容，可以查看一些计算机网络的相关书籍。 TCP是面向连接传输协议，也就是说在我们的应用程序在使用TCP协议之前，必须先建立起TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。就像我们打电话一样，打电话之前首先需要拨号进行建立连接，等通话结束后再挂断释放连接。 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。 TCP提供了一个可靠交付的服务，也就是说通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。 TCP提供全双工通信，它允许通信双方的应用进程在任何时候都能够发送数据。 TCP通信中是面向字节流的，其中的“流”指的是流入到进程或从进程流出的字节序列。用户数据报协议UDP 用户数据报协议UDP只是在IP的数据服务上增加了很少的一点功能（复用、分用的功能以及差错检测的功能）。在这里简单说一下UDP的特点。 UDP是无连接，也就是在发送数据之前是不需要建立连接的，也就减少了开销和发送数据之间的延时。 UDP它只能是尽最大努力地交付，也就是不能够保证可靠交付。 UDP它是面向报文的。发送方的UDP对应用程序交下来的报文，再添加首部后就向下交付给IP层。 UDP它没有拥塞控制，也就是说在网络出现拥塞的情况下不会使源主机的发送速率降低。 UDP支持一对一，一对多，多对一和多对多的交互通信。Socket在TCP/IP中的作用 Socket是工作于TCP/IP协议中应用层和传输层之间的一种抽象（不属于应用层也不属于传输层）。在Android系统中，它可以分为流套接字（streamsocket）和数据报套接字(datagramsocket)。而Socket中的流套接字将TCP协议作为其端对端协议，提供了一个可信赖的字节流服务；数据报套接字使用UDP协议，提供数据打包发送服务。 在网络编程的时候，我们经常把Socket作为应用进程和传输层协议之间的接口。在下面图中表示了这样一个概念。在图中我们假定了运输层使用的是TCP协议（如果使用的是UDP协议，情况也是类似的，只是UDP是无连接的通信的两端依然可以用两个套接字来标志）。并且现在套接字已经成为操作系统内核的一部分。 不过有一点我们要注意，在套接字以上的进程是受应用程序控制的，而在套接字以下的的传输层协议软件则是由计算机操作系统控制。因此，只要我们的应用程序使用TCP/IP协议进行通信，它就必须通过Socket与操作系统交互并请求服务。从这里可以看出来，我们对Socket以上的应用进程具有完全的控制，但对Socket以下的传输层却只有很少的控制。例如，我们可以选择传输层协议（TCP或UDP）和一些传输层的参数（如最大缓存空间和最大报文长度）。Socket使用案例 在这里我们选择传输层协议为TCP协议，也就是我们将使用流套接字作为例子进行举例说明。现在我们现在做一个聊天室功能。在这里我们创建两个应用程序，分别运行在两个不同的设备上。首先看一下效果图。演示 &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187package com.example.ljd.socketclient;import android.annotation.SuppressLint;import android.os.Handler;import android.os.Message;import android.os.SystemClock;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.EditText;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.Socket;import java.sql.Date;import java.text.SimpleDateFormat;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity&#123; private static final int RECEIVE_NEW_MESSAGE = 1; private static final int SOCKET_CONNECT_SUCCESS = 2; private static final int SOCKET_CONNECT_FAIL = 3; @Bind(R.id.msg_edit_text) EditText mMessageEditText; @Bind(R.id.show_linear) LinearLayout mShowLinear; private PrintWriter mPrintWriter; private Socket mClientSocket; private boolean mIsConnectServer = false; @SuppressLint("HandlerLeak") private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case RECEIVE_NEW_MESSAGE: TextView textView = new TextView(MainActivity.this); textView.setText((String)msg.obj); mShowLinear.addView(textView); break; case SOCKET_CONNECT_SUCCESS: Toast.makeText(MainActivity.this,"连接服务端成功",Toast.LENGTH_SHORT).show(); break; case SOCKET_CONNECT_FAIL: Toast.makeText(MainActivity.this,"连接服务端失败，请重新尝试",Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; @Override protected void onDestroy() &#123; ButterKnife.unbind(this); disConnectServer(); super.onDestroy(); &#125; @OnClick(&#123;R.id.send_btn,R.id.connect_btn,R.id.disconnect_btn&#125;) public void onClickButton(View v) &#123; switch (v.getId())&#123; case R.id.send_btn: sendMessageToServer(); break; case R.id.connect_btn: new Thread() &#123; @Override public void run() &#123; connectServer(); &#125; &#125;.start(); break; case R.id.disconnect_btn: Toast.makeText(MainActivity.this,"已经断开连接",Toast.LENGTH_SHORT).show(); disConnectServer(); break; &#125; &#125; private String getTime(long time) &#123; return new SimpleDateFormat("(HH:mm:ss)").format(new Date(time)); &#125; private void connectServer() &#123; if (mIsConnectServer) return; int count = 0; while (mClientSocket == null) &#123; try &#123; mClientSocket = new Socket("10.10.14.160", 8088); mPrintWriter = new PrintWriter(new BufferedWriter( new OutputStreamWriter(mClientSocket.getOutputStream())), true); mIsConnectServer = true; mHandler.obtainMessage(SOCKET_CONNECT_SUCCESS).sendToTarget(); &#125; catch (IOException e) &#123; SystemClock.sleep(1000); count++; if (count == 5)&#123; mHandler.obtainMessage(SOCKET_CONNECT_FAIL).sendToTarget(); return; &#125; &#125; &#125; try &#123; // 接收服务器端的消息 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader( mClientSocket.getInputStream())); while (!MainActivity.this.isFinishing()) &#123; String msg = bufferedReader.readLine(); if (msg != null) &#123; String time = getTime(System.currentTimeMillis()); final String showedMsg = "server " + time + ":" + msg; mHandler.obtainMessage(RECEIVE_NEW_MESSAGE, showedMsg) .sendToTarget(); &#125; &#125; mPrintWriter.close(); bufferedReader.close(); mClientSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void disConnectServer()&#123; mIsConnectServer = false; if (mClientSocket != null) &#123; try &#123; mClientSocket.shutdownInput(); mClientSocket.close(); mClientSocket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void sendMessageToServer()&#123; if (!mIsConnectServer)&#123; Toast.makeText(this,"没有连接上服务端，请重新连接",Toast.LENGTH_SHORT).show(); return; &#125; final String msg = mMessageEditText.getText().toString(); if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter != null) &#123; mPrintWriter.println(msg); mMessageEditText.setText(""); String time = getTime(System.currentTimeMillis()); final String showedMsg = "client " + time + ":" + msg; TextView textView = new TextView(this); textView.setText(showedMsg); mShowLinear.addView(textView); &#125; &#125;&#125; 客户端布局代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="5dp" &gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" &gt; &lt;LinearLayout android:id="@+id/show_linear" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/msg_edit_text" android:layout_width="0dp" android:layout_gravity="bottom" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;Button android:id="@+id/send_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="发送" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/connect_btn" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="连接"/&gt; &lt;Button android:id="@+id/disconnect_btn" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="断开连接"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 服务端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.example.ljd.socketserver;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.text.TextUtils;import android.widget.EditText;import android.widget.LinearLayout;import android.widget.TextView;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.sql.Date;import java.text.SimpleDateFormat;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity&#123; @Bind(R.id.show_linear) LinearLayout mShowLinear; @Bind(R.id.msg_edit_text) EditText mMessageEditText; private ServerSocket mServerSocket; private PrintWriter mPrintWriter; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if (msg.what == 0)&#123; TextView textView = new TextView(MainActivity.this); textView.setText((String)msg.obj); mShowLinear.addView(textView); &#125; super.handleMessage(msg); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); try &#123; mServerSocket = new ServerSocket(8088); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; new Thread(new AcceptClient()).start(); &#125; @Override public void onDestroy() &#123; ButterKnife.unbind(this); if (mServerSocket != null)&#123; try &#123; mServerSocket.close(); mServerSocket = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; super.onDestroy(); &#125; @OnClick(R.id.send_btn) public void onClickButton() &#123; final String msg = mMessageEditText.getText().toString(); if (!TextUtils.isEmpty(msg) &amp;&amp; mPrintWriter != null) &#123; //将消息写入到流中 mPrintWriter.println(msg); mMessageEditText.setText(""); String time = getTime(System.currentTimeMillis()); final String showedMsg = "server " + time + ":" + msg; TextView textView = new TextView(this); textView.setText(showedMsg); mShowLinear.addView(textView); &#125; &#125; private String getTime(long time) &#123; return new SimpleDateFormat("(HH:mm:ss)").format(new Date(time)); &#125; class AcceptClient implements Runnable&#123; @Override public void run() &#123; try &#123; Socket clientSocket = null; while (clientSocket == null)&#123; clientSocket = mServerSocket.accept(); mPrintWriter = new PrintWriter(new BufferedWriter( new OutputStreamWriter(clientSocket.getOutputStream())), true); &#125; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader( clientSocket.getInputStream())); while (!MainActivity.this.isFinishing()) &#123; //读取客户端发来的消息 String msg = bufferedReader.readLine(); if (msg != null) &#123; String time = getTime(System.currentTimeMillis()); final String showedMsg = "client " + time + ":" + msg; mHandler.obtainMessage(0, showedMsg) .sendToTarget(); &#125; &#125; bufferedReader.close(); clientSocket.close(); mPrintWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 服务端布局代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="5dp" &gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" &gt; &lt;LinearLayout android:id="@+id/show_linear" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;EditText android:id="@+id/msg_edit_text" android:layout_width="0dp" android:layout_gravity="bottom" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;Button android:id="@+id/send_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="发送" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 添加权限 在客户端与服务端应用中我们还需要添加一些权限12&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 总结 在网络通信中我们除了socket我们最常用的还有一种方式那就是http通信，而http连接采用的是”请求—响应方式“，也就是说只有当客户端发出请求时，服务端才能够向客户端返回数据。在这里我们就不在详细介绍。对于Android的IPC机制就说到这里了，当然还有其他方式可以进行跨进程通信，我们可以自行研究了。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(六)—BroadcastReceiver的使用]]></title>
    <url>%2F2016%2F02%2F29%2Fipc-06%2F</url>
    <content type="text"><![CDATA[在Android的四大组件中除了ContentProvider能够用于进程间的通信外，还有一个也能够用于进程间的通信，那就是BroadcastReceiver。BroadcastReceiver翻译成中文为广播接收器，既然作为广播接收器，那么必然就有Broadcast。在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver则是对发送出来的 Broadcast进行过滤接受并响应的一类组件。在 Android 里面有各种各样的广播，比如电池的使用状态，电话的接收和短信的接收都会产生一个广播，应用程序开发者也可以监听这些广播并做出程序逻辑的处理。 生命周期 对于BroadcastReceiver的生命周期也是非常的简单。它的生命周期只存在于onReceive方法中。对于这个onReceive方法它也是运行在主线程中。所以在onReceive方法中不能进行的耗时的操作。否则就会出现ANR(Application Not Responding)。由于这个ANR的限制对于onReceive方法最多可执行的时间为10秒左右。并且由于BroadcastReceiver的生命周期随着onReceive方法的结束而结束。所以我们不能再onReceive方法中去创建一个线程来执行任务。因为onReceive方法执行完毕，这时候这个BroadcastReceiver 也就结束了。也就无法处理异步的结果。如果这个BroadcastReceiver在独立的进程中，它所在进程也很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 那么正在工作的子线程也会被杀死 。若是我们需要完成一个比较耗时任务的话，我们可以通过发送Intent给Service，并且由这个Service来完成这项任务。 使用方法注册方式 对于BroadcastReceiver有两种注册方式，一种是动态注册，一种是静态注册。静态注册就是在AndroidManifest文件中进行注册。而动态注册则是在程序中通过registerReceiver方法注册。对于这两种注册方法的优先级来说，动态注册的优先级要高于静态注册的优先级。那么下面我们来看一下这两种注册方式。 1. 静态注册1234567&lt;receiver android:name=".MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.ljd.BROADCASTRECEIVER" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 2. 动态注册123IntentFilter intentFilter = new IntentFilter();intentFilter.addAction("com.example.ljd.BROADCASTRECEIVER");registerReceiver(myReceiver,intentFilter); 对于动态注册，当我们不在使用的这个broadcastreceiver的时候我们还需要对它解除注册。1unregisterReceiver(myReceiver); 广播类型 在这里我们介绍一下其中最常用的两种广播：普通广播和有序广播。它们分别是通过sendBroadcast和sendOrderedBroadcast进行发送。那么现在我们就来看一下这两种方式的用法与区别。 普通广播（Normal Broadcast） 我们可以通过sendBroadcast方法发送一个普通广播。对于普通广播来说，BroadcastReceiver的优先级一样的话它们接收广播先后顺序是随机的，并且在广播的传输过程中我们无法截断广播。 下面我们做一个实验。我们创建三个BroadcastReceiver，使其运行在三个不同的进程内。并且我们采用静态注册方式。 第一个BroadcastReceiver1234567891011121314151617181920package com.example.ljd.broadcastreceiver;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class MyReceiver1 extends BroadcastReceiver &#123; private final String TAG = "MyReceiver1"; public MyReceiver1() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (Constant.BROADCAST_ACTION.equals(intent.getAction()))&#123; Log.d(TAG,intent.getStringExtra(Constant.CONFERENCE_KEY)); &#125; &#125;&#125; 第二个BroadcastReceiver12345678910111213141516171819package com.example.ljd.broadcastreceiver;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class MyReceiver2 extends BroadcastReceiver &#123; private final String TAG = "MyReceiver2"; public MyReceiver2() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (Constant.BROADCAST_ACTION.equals(intent.getAction()))&#123; Log.d(TAG, intent.getStringExtra(Constant.CONFERENCE_KEY)); &#125; &#125;&#125; 第三个BroadcastReceiver12345678910111213141516171819package com.example.ljd.broadcastreceiver;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.util.Log;public class MyReceiver3 extends BroadcastReceiver &#123; private final String TAG = "MyReceiver3"; public MyReceiver3() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (Constant.BROADCAST_ACTION.equals(intent.getAction()))&#123; Log.d(TAG,intent.getStringExtra(Constant.CONFERENCE_KEY)); &#125; &#125;&#125; 对三个BroadcastReceiver进行静态注册。123456789101112131415161718192021222324252627&lt;receiver android:name=".MyReceiver1" android:process=":receiver1"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.ljd.BROADCASTRECEIVER" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=".MyReceiver3" android:process=":receiver3"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.ljd.BROADCASTRECEIVER" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;receiver android:name=".MyReceiver2" android:process=":receiver2"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.ljd.BROADCASTRECEIVER" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 我们在创建一个Activity，在这个Activity里面我们创建一个BroadcastReceiver并且对其进行动态注册。然后我们采用sendBroadcast进行发送广播。下面看一下Activity代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.ljd.broadcastreceiver;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity &#123; private final String TAG = "MainActivity"; private MyReceiver myReceiver = new MyReceiver(); class MyReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; if (Constant.BROADCAST_ACTION.equals(intent.getAction()))&#123; Log.d(TAG,intent.getStringExtra(Constant.CONFERENCE_KEY)); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_first); ButterKnife.bind(this); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(Constant.BROADCAST_ACTION); registerReceiver(myReceiver,intentFilter); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ButterKnife.bind(this); unregisterReceiver(myReceiver); &#125; @OnClick(R.id.send_button) public void onClickButton()&#123; Intent intent = new Intent(Constant.BROADCAST_ACTION); intent.putExtra(Constant.CONFERENCE_KEY,"你好，明天九点半101会议室开会。"); sendBroadcast(intent); &#125;&#125; 我们发送一条通知开会的广播，并且接收到广播后打印出来。由于代码非常简单这里就不在进行说明，从下面的结果我们可以看出，无论是采用静态注册还是动态注册，它们接收到的先后顺序是随机的。我们发送了三次广播。这时候可以通过DDMS查看一下日志信息。 结果1：结果2：结果3： 现在我们对MyReceiver2中的OnReceive添加一个abortBroadcast方法，这个方法是用来截断广播的。然后我们在看一下运行结果 我们可以看到虽然系统给我们抛出了了运行时异常，但是我们还是准确无误的接收到了广播。而这个异常是在abortBroadcast里面的checkSynchronousHint方法中抛出的，这个checkSynchronousHint方法是用来检测广播接收者是否同步接收广播。由于我们接收广播是随机的，所以抛出运行时异常。 现在又有一种情形，如果我们只是希望动态创建的BroadcastReceiver进行接收广播，而静态创建的BroadcastReceiver不进行接收。我们可以在发送广播的Intent中设置一个flag：FLAG_RECEIVER_REGISTERED_ONLY。 1intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY); 这时候我们可以看到只有动态注册的广播才接收到消息。 有序广播（Ordered Broadcast） 对于有序广播而言，BroadcastReceiver是按照接收者的优先级接收广播 , 优先级在 intent-filter 中的 priority 中声明 。priority的值从-1000 到1000 之间 , 值越大 , 优先级越高。如果我们没有设置priority的话，那么对于BroadcastReceiver的优先级则是先注册的要大于后注册的，动态注册优先级大于静态注册的优先级。对于刚才的例子来说在有序广播中它们的优先级就是MyReceiver&gt;MReceiver1&gt;MReceiver3&gt;MReceiver2。并且在在有序广播中我们可以终止广播 ，接收者也能够篡改内容。 我们可以通过sendOrderedBroadcast进行发送一个有序广播，他有两个重载方法。1234567public void sendOrderedBroadcast(Intent intent, String receiverPermission) public void sendOrderedBroadcast( Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras) 这里我们对里面的参数进行一下说明： intent：所有匹配的这个intent的BroadcastReceiver将接收广播。 receiverPermission：这个是权限，一个接收器必须持有接收我们的广播的权限。如果BroadcastReceiver没有设置任何权限，这里为null即可。 resultReceiver ：设置一个BroadcastReceiver 来当作最后的广播接收器。 initialCode：结果代码的初始值。通常为 Activity.RESULT_OK ，这个值是 -1 。也可以为其他 int 型，如 0,1,2 ； initialData： 一种结果数据的初始值。为String 类型 ; initialExtras：一种结果额外的初始值。为Bundle类型。 对于我们没有设置priority属性的BroadcastReceiver的优先级情况很简单这里也就不在进行验证。现在我们来修改上面代码来看一下是如何拦截广播并且修改广播中数据的。我们首先对动态注册的优先级设为0。对上面的MyReceiver1,MyReceiver2,MyReceiver3的优先级分别设为3，2，1。然后我们通过sendOrderedBroadcast发送一个有序广播。1234567Intent intent = new Intent(Constant.BROADCAST_ACTION);intent.putExtra(Constant.CONFERENCE_KEY, "你好，明天九点半101会议室开会。");Bundle bundle = new Bundle();bundle.putString(Constant.DINE_KEY, "今天晚上聚餐");intent.putExtras(bundle);sendOrderedBroadcast(intent,null,null,null, Activity.RESULT_OK ,null,bundle); 在MyReceiver1的onReceive方法中修改如下：1234567if (Constant.BROADCAST_ACTION.equals(intent.getAction()))&#123; Log.d(TAG, intent.getStringExtra(Constant.CONFERENCE_KEY)); Log.d(TAG, getResultExtras(true).getString(Constant.DINE_KEY)); Bundle bundle = getResultExtras(true); bundle.putString(Constant.DINE_KEY, "后天中午一起聚餐"); setResultExtras(bundle); &#125; 在MyReceiver2的onReceive方法中修改如下：12345if (Constant.BROADCAST_ACTION.equals(intent.getAction()))&#123; Log.d(TAG, intent.getStringExtra(Constant.CONFERENCE_KEY)); Log.d(TAG, getResultExtras(true).getString(Constant.DINE_KEY)); abortBroadcast();&#125; getResultExtras：优先级低的BroadcastReceiver可以通过这个方法获取到最新的经过处理的信息集合。 下面我们来看一下运行结果： 在这里我们可以看到由于在MyReceiver2中的onReceive方法中设置了abortBroadcast，比MyReceiver2优先级低的BroadcastReceiver接收不到广播。并且在MyReceiver1中将“今天晚上聚餐”成功修改为“后天中午聚餐”。 总结 BroadcastReceiver除了可以接收我们自己发送的广播以外，还能够接收一些系统的广播。例如对网络环境的监测，手机电量的监测，设备重启的监测等等。也就是说BroadcastReceiver可以方便应用程序和系统，应用程序之间，应用程序内的通信。所以对于我们单个应用程序来说它是存在安全性的问题。不过我们我们可以在发送广播时指定接收者必须具备的permission。当然我们也可以通过使用LocalBroadcastManager来解决安全性问题。对于LocalBroadcastManager使用也很简单。它是一个单例模式，可以通过LocalBroadcastManager.getInstance(context)获取LocalBroadcastManager对象。然后通过LocalBroadcastManager里面的registerReceiver方法进行BroadcastReceiver进行注册。也就是说使用LocalBroadcastManager必须进行动态注册。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(五)—ContentProvider的使用]]></title>
    <url>%2F2016%2F02%2F28%2Fipc-05%2F</url>
    <content type="text"><![CDATA[对于前面一些的ipc过程都是Service与客户端进行通信。那么在不同应用之间ipc可以采用哪些方式呢？首先我们会想到ContentProvider，因为我们平时获取手机上的联系人，图片等等都是通过ContentProvider得到的。ContentProvider是Android的四大组件之一。翻译成中文为内容提供者，也就是可以将自己的数据提供给别的应用进行使用。那么我们现在就来看一下ContentProvider的使用方法。 ContentProvider的用法 ContentProvider的用法其实也很简单。当我们的两个应用需要进行数据共享的时候，我们就可以利用ContentProvider为所需要共享的数据定义一个Uri，然后其他应用通过Context获得ContentResolver并将数据的Uri传入即可。对于ContentProvider最重要的就是他的数据模型(data model)和Uri。那么我们现在就先看一下他的数据模型和这个URI是什么。 数据模型 在ContentProvider中数据的存储也是为所有的共享数据创建了一个表。比如说我们的一个应用对其他应用提供了员工信息。那么下面这张表就体现出了ContentProvider中的数据在表中的存储情况。 id woekNum name department 1 1001 张三 销售部 2 1002 李四 人事部 3 1003 王五 研发部 4 1004 小明 研发部 5 1005 小强 销售部 在这个表中，id为主键，workNum,name,department分别对应着员工的工号，姓名，部门。每一行表示一条记录，对应着一个实例，每一列代表着某个数据。不过有一点要注意，ContentProvider中的主键不是必需的,并且它不需要使用ID作为一个主键的列名。 URI URI的全称为Uniform Resource Identifier（统一资源标识符）。是一个用于标识资源名称的字符串。 这种标识允许我们对任何（包括本地和互联网）的资源通过特定的协议进行交互。而每个ContentProvider都会对外提供一个公开的URI来标识自己的数据集。当管理多个数据集时，将会为每个数据集分配一个独立的URI。对于ContentProvider所提供的URI的格式如下。 1content://[Authority]/[path] 在这里说明一下： 1. 所有ContentProvider所提供的URI都是以”content://“开头。 2. 我们创建一个ContentProvider都会为对他指定一个Authority，也对应着URI中的Authority。 3. path为资源路径。它表示所请求的资源的类型。 使用案例 那么现在我们用一个例子来说明一下这个ContentProvider是如何使用的。在这里我们使用两个应用。第一个应用通过使用ContentProvider对外提供员工信息。而第二个应用来获取这个员工信息。 那么现在我们首先看一下第一个应用程序。在这里我们创建一个SQLite数据库，将员工信息存入数据库中。 我们首先简单的创建一个Sqlite数据库。123456789101112131415161718192021222324252627282930package com.example.ljd.employee;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class EmployeeDBHelper extends SQLiteOpenHelper &#123; private final static String DB_NAME = "myDatabase.db"; private final static int DB_VERSION = 1; public static final String EMPLOYEE_TABLE_NAME = "employee"; private String CREATE_BOOK_TABLE = "CREATE TABLE IF NOT EXISTS " + EMPLOYEE_TABLE_NAME + " (id INTEGER PRIMARY KEY," +"workNum TEXT,"+ "name TEXT,"+"department TEXT)"; public EmployeeDBHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 然后我们创建一个EmployeeProvider类，这个继承ContentProvider。我们看一下这个EmployeeProvider。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.example.ljd.employee;import android.content.ContentProvider;import android.content.ContentValues;import android.content.UriMatcher;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.net.Uri;import android.support.annotation.Nullable;public class EmployeeProvider extends ContentProvider &#123; private SQLiteDatabase mDb; private static final String AUTHORITY = "com.example.ljd.employee.EmployeeProvider"; private static final int EMPLOYEE_URI_CODE = 0; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static &#123; sUriMatcher.addURI(AUTHORITY, "employee", EMPLOYEE_URI_CODE); &#125; @Override public boolean onCreate() &#123; insertDataToDb(); return true; &#125; @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; String tableName = getTableName(uri); if (tableName == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; Cursor cursor = mDb.query(tableName, projection, selection, selectionArgs, null, null, sortOrder, null); return cursor; &#125; @Nullable @Override public String getType(Uri uri) &#123; return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; mDb.insert(table, null, values); getContext().getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; int count = mDb.delete(table, selection, selectionArgs); if (count &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; int row = mDb.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private void insertDataToDb() &#123; mDb = new EmployeeDBHelper(getContext()).getWritableDatabase(); mDb.execSQL("delete from " + EmployeeDBHelper.EMPLOYEE_TABLE_NAME); mDb.execSQL("insert into employee values(1,'1001','张三','销售部');"); mDb.execSQL("insert into employee values(2,'1002','李四','人事部');"); mDb.execSQL("insert into employee values(3,'1003','王五','研发部');"); mDb.execSQL("insert into employee values(4,'1004','小明','研发部');"); mDb.execSQL("insert into employee values(5,'1005','小强','销售部');"); &#125; private String getTableName(Uri uri) &#123; String tableName = null; if (sUriMatcher.match(uri) == EMPLOYEE_URI_CODE)&#123; tableName = EmployeeDBHelper.EMPLOYEE_TABLE_NAME; &#125; return tableName; &#125;&#125; 在这里我们实现了ContentProvider的六个抽象方法。在onCreate方法中，用于创建一个ContentProvider，在这里我们对数据库进行初始化操作。而getType方法中用来返回Uri请求所对应的MIME类型。而后剩下的四个方法中也就是对应的”CRUD”操作，也就是数据的增删改查功能。 然后我们还需要在AndroidManifest中注册这个ContentProvider。12345&lt;provider android:name=".EmployeeProvider" android:authorities="com.example.ljd.employee.EmployeeProvider" android:exported="true" android:permission="com.example.ljd.employee.provider" /&gt; authorities: 这个属性是ContentProvider的唯一标识，通过过这个属性外部应用才能访问我们的ContentProvider，也就是说authorities是唯一的。而且这个authorities也是我们Uri里面的authorities。 export: 设为true的时候表示当前ContentProvider可以被其它应用使用。任何应用可以使用Provider通过URI 来获得它，也可以通过相应的权限来使用Provider。设为false的时候表示当前ContentProvider不能被其它应用使用。 permission: 为我们的ContentProvider设置权限从而避免任何应用都能访问我们的ContentProvider。 所以现在我们还需要为我们的应用设置权限。12&lt;permission android:name="com.example.ljd.employee.provider" android:protectionLevel="normal"/&gt; 对于这个应用程序我们只需要在创建一个空白的Activity启动即可，在这个Activity里面不需要做任何的操作。然后我们现在看一下第二个应用是如何获取ContentProvider中数据的。 首先我们需要创建一个Employee实体类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.ljd.client;public class Employee &#123; private int id; private String workNum; private String name; private String department; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getWorkNum() &#123; return workNum; &#125; public void setWorkNum(String workNum) &#123; this.workNum = workNum; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDepartment() &#123; return department; &#125; public void setDepartment(String department) &#123; this.department = department; &#125; @Override public String toString()&#123; return String.format("workNum:%s, name:%s, department:%s", getWorkNum(),getName(),getDepartment()); &#125;&#125; 然后我们在看一下是如何ContentProvider中的数据进行操控的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.example.ljd.client;import android.content.ContentResolver;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.net.Uri;import android.util.Log;import java.util.ArrayList;import java.util.List;public class HandleProvider &#123; private static Context mContext; private static HandleProvider mInstance; private static Uri mEmployeeUri; private static final String EMPLOYEE_CONTENT_URI = "content://com.example.ljd.employee.EmployeeProvider/employee"; private HandleProvider(Context mContext) &#123; this.mContext = mContext.getApplicationContext(); mEmployeeUri = Uri.parse(EMPLOYEE_CONTENT_URI); &#125; public static HandleProvider getInstance(Context context) &#123; if (mInstance == null) &#123; synchronized (HandleProvider.class) &#123; if (mInstance == null) &#123; mInstance = new HandleProvider(context); &#125; &#125; &#125; return mInstance; &#125; public void delete() &#123; ContentResolver contentResolver = mContext.getContentResolver(); String where = "id=?"; String[] where_args = &#123;"7"&#125;; contentResolver.delete(mEmployeeUri, where, where_args); &#125; public void update() &#123; ContentResolver contentResolver = mContext.getContentResolver(); ContentValues values = new ContentValues(); values.put("name", "梁山伯"); String where = "id=?"; String[] where_args = &#123;"1"&#125;; contentResolver.update(mEmployeeUri, values, where, where_args); &#125; public void create() &#123; ContentValues values = new ContentValues(); values.put("id", 7); values.put("workNum", "1006"); values.put("name", "张三丰"); values.put("department", "研发部"); mContext.getContentResolver().insert(mEmployeeUri, values); &#125; public List&lt;String&gt; query() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Cursor cursor = mContext.getContentResolver().query(mEmployeeUri, new String[]&#123;"id", "workNum", "name", "department"&#125;, null, null, null); while (cursor.moveToNext()) &#123; Employee employee = new Employee(); employee.setId(cursor.getInt(0)); employee.setWorkNum(cursor.getString(1)); employee.setName(cursor.getString(2)); employee.setDepartment(cursor.getString(3)); String str = employee.toString(); list.add(str); Log.d("mainActivity", "query employee:" + str); &#125; cursor.close(); return list; &#125;&#125; 我们只需要在Activity使用这些方法即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.ljd.client;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;import android.widget.TextView;import java.util.List;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity &#123; @Bind(R.id.show_linear) LinearLayout showLinear; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ButterKnife.unbind(this); &#125; @OnClick(&#123;R.id.insert_button,R.id.delete_button,R.id.update_button,R.id.query_button,R.id.clear_button&#125;) public void onClickButton(View view)&#123; switch (view.getId())&#123; case R.id.insert_button: HandleProvider.getInstance(this).create(); break; case R.id.delete_button: HandleProvider.getInstance(this).delete(); break; case R.id.update_button: HandleProvider.getInstance(this).update(); break; case R.id.query_button: List&lt;String&gt; list = HandleProvider.getInstance(this).query(); for (int i = 0;i&lt;list.size();i++)&#123; TextView textView = new TextView(this); textView.setText(list.get(i)); showLinear.addView(textView); &#125; TextView lineText = new TextView(this); lineText.setText("-----------------------"); showLinear.addView(lineText); break; case R.id.clear_button: showLinear.removeAllViews(); break; default: break; &#125; &#125;&#125; 由于在ContentProvider中添加了权限，所以要为我们这个应用添加使用权限。1&lt;uses-permission android:name="com.example.ljd.employee.provider"/&gt; 最后在看一下我们的布局代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.example.ljd.client.MainActivity"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/insert_button" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_weight="1" android:text="@string/insert"/&gt; &lt;Button android:id="@+id/delete_button" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_weight="1" android:text="@string/delete"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/update_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="1" android:text="@string/update"/&gt; &lt;Button android:id="@+id/query_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="1" android:text="@string/query"/&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/clear_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/clear"/&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/show_linear" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt;&lt;/LinearLayout&gt; 演示 在这里我们看一下效果演示。 插入：我们将一个名叫张三丰的员工通过ContentProvider插入到数据库中。 删除：我们将上面插入的张三丰这个员工删除。 更新：我们将张三改名为梁山伯。 总结 在这里我们介绍了ContentProvider的使用方法，而在Android系统中为我们提供ContentProvider组件本身就是用来跨进程访问数据的。其实在Android应用的四大组件当中可以用于进程间通信的不止ContentProvider一个。那么另外一个是谁呢，在下一篇中会进行详细介绍。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(四)— Messenger的使用及源码分析]]></title>
    <url>%2F2016%2F02%2F25%2Fipc-04%2F</url>
    <content type="text"><![CDATA[在前面几篇中我们详细的介绍了AIDL的使用及原理。在这里我们感觉到AIDL的在使用过程中还是比较复杂的，那么有没有一种简单的方法来实现进程间的通信呢？当然是有的，那就是利用Messenger。Messenger翻译为信使，从他的名字就可以看出这个Messenger就是作为传递消息用的。那么我们就来看一下这个Messenger到底是如何使用的，以及在它内部是如何实现的。 Messenger的使用使用步骤 其实对于Messenger用起来是非常简单的，那么我们首先来看一下这个Messenger的使用步骤： 1. 在服务端我们实现一个 Handler，接收来自客户端的每个调用的回调 2. 这个Handler 用于创建 Messenger 对象（也就是对 Handler 的引用） 3. 用Messenger 创建一个 IBinder，服务端通过 onBind() 使其返回客户端 4. 客户端使用 IBinder 将 Messenger（引用服务的 Handler）实例化，然后使用后者将 Message 对象发送给服务端 5. 服务端在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message 在这里我们写一个例子来更详细的说明这个Messenger的使用。 演示 在这里我们写一个demo，我们通过客户端随机产生一个由小写字母组成的10位字符串发送给服务端，由服务端转换为大写后再发送给客户端。 源代码 下面是服务端代码。12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ljd.messenger;import android.app.Service;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.Messenger;import android.os.RemoteException;public class MessengerService extends Service &#123; private final Messenger mMessenger = new Messenger(new ServiceHandler()); private class ServiceHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 0: Messenger clientMessenger = msg.replyTo; Message replyMessage = Message.obtain(); replyMessage.what = 1; Bundle bundle = new Bundle(); //将接收到的字符串转换为大写后发送给客户端 bundle.putString("service", msg.getData().getString("client").toUpperCase()); replyMessage.setData(bundle); try &#123; clientMessenger.send(replyMessage); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mMessenger.getBinder(); &#125;&#125; 下面我们使服务端运行在独立的进程中。 1234&lt;service android:name=".MessengerService" android:process=":remote"&gt;&lt;/service&gt; 下面是客户端代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.ljd.messenger;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.Messenger;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;import android.widget.TextView;import java.util.Random;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;public class MainActivity extends AppCompatActivity &#123; @Bind(R.id.messenger_linear) LinearLayout mShowLinear; private Messenger mMessenger; private final String LETTER_CHAR = "abcdefghijkllmnopqrstuvwxyz"; private class ClientHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 1: TextView textView = new TextView(MainActivity.this); textView.setText("convert ==&gt;:" + (msg.getData().containsKey("service")?msg.getData().getString("service"):"")); mShowLinear.addView(textView); break; default: super.handleMessage(msg); &#125; &#125; &#125; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mMessenger = new Messenger(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; bindService(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); bindService(); &#125; @OnClick(&#123;R.id.test_button,R.id.clear_button&#125;) public void onClickButton(View v)&#123; switch (v.getId())&#123; case R.id.test_button: sendToService(); break; case R.id.clear_button: mShowLinear.removeAllViews(); break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(mConnection); ButterKnife.unbind(this); &#125; private void bindService()&#123; Intent intent = new Intent(MainActivity.this,MessengerService.class); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); &#125; private void sendToService()&#123; Message messageClient = Message.obtain(null,0); //用于传递给服务端回复的Messenger Messenger replyMessenger = new Messenger(new ClientHandler()); Bundle bundle = new Bundle(); bundle.putString("client",generateMixString()); messageClient.setData(bundle); //通过Message的replyTo属性将Messenger对象传递到服务端 messageClient.replyTo = replyMessenger; TextView textView = new TextView(MainActivity.this); textView.setText("send:" + (bundle.getString("client"))); mShowLinear.addView(textView); try &#123; mMessenger.send(messageClient); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; /** * 随机生成10位小写字母的字符串 * @return */ public String generateMixString() &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; 10; i++) &#123; sb.append(LETTER_CHAR.charAt(random.nextInt(LETTER_CHAR.length()))); &#125; return sb.toString(); &#125;&#125; 注意：我们可以看到在Messenger中通过Message进行传递数据的。在Message中的字段obj是不能用于进程间通信的。 Messenger原理分析 首先我们进入Messenger这个类里面看一下这个Messenger到底是什么东西。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package android.os;public final class Messenger implements Parcelable &#123; private final IMessenger mTarget; public Messenger(Handler target) &#123; mTarget = target.getIMessenger(); &#125; public void send(Message message) throws RemoteException &#123; mTarget.send(message); &#125; public IBinder getBinder() &#123; return mTarget.asBinder(); &#125; public boolean equals(Object otherObj) &#123; if (otherObj == null) &#123; return false; &#125; try &#123; return mTarget.asBinder().equals(((Messenger)otherObj) .mTarget.asBinder()); &#125; catch (ClassCastException e) &#123; &#125; return false; &#125; public int hashCode() &#123; return mTarget.asBinder().hashCode(); &#125; public int describeContents() &#123; return 0; &#125; public void writeToParcel(Parcel out, int flags) &#123; out.writeStrongBinder(mTarget.asBinder()); &#125; public static final Parcelable.Creator&lt;Messenger&gt; CREATOR = new Parcelable.Creator&lt;Messenger&gt;() &#123; public Messenger createFromParcel(Parcel in) &#123; IBinder target = in.readStrongBinder(); return target != null ? new Messenger(target) : null; &#125; public Messenger[] newArray(int size) &#123; return new Messenger[size]; &#125; &#125;; public static void writeMessengerOrNullToParcel(Messenger messenger, Parcel out) &#123; out.writeStrongBinder(messenger != null ? messenger.mTarget.asBinder() : null); &#125; public static Messenger readMessengerOrNullFromParcel(Parcel in) &#123; IBinder b = in.readStrongBinder(); return b != null ? new Messenger(b) : null; &#125; public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target); &#125;&#125; 我们可以看到这个Messenger实现Parcelable接口。然后声明了一个IMessenger 对象mTarget。并且在Messenger中的两个构造方法中都对这个mTarget进行了初始化。那么这个IMessenger 是什么东西呢？我们首先看一下Messenger中的第一个构造方法。123public Messenger(Handler target) &#123; mTarget = target.getIMessenger();&#125; 首先我们使用这个构造方法在服务端创建一个Messenger对象，在onBind中通过Messenger中的getBinder方法向客户端返回一个Binder对象。而在这个构造方法里面通过Handler中的getIMessenger方法初始化mTarget。那么我们进入Handler中看一下这个getIMessenger方法。 12345678910111213141516171819202122public class Handler &#123; ... final IMessenger getIMessenger() &#123; synchronized (mQueue) &#123; if (mMessenger != null) &#123; return mMessenger; &#125; mMessenger = new MessengerImpl(); return mMessenger; &#125; &#125; private final class MessengerImpl extends IMessenger.Stub &#123; public void send(Message msg) &#123; msg.sendingUid = Binder.getCallingUid(); Handler.this.sendMessage(msg); &#125; &#125; ...&#125; 这回我们看到了这个getIMessenger方法中返回了一个MessengerImpl对象，而这个MessengerImpl中对send方法实现，也只不过是通过Handler发送了一个message。并且在Handler中的handleMessage方法中进行处理。 而在我们的客户端当中，我们通过客户端的onServiceConnected中拿到服务端返回的Binder对象，并且在onServiceConnected方法中new Messenger(service)去获取这个IMessenger对象，下面我们就看一下这个Messenger的第二个构造方法。 123public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target);&#125; 这个构造方法一般用于客户端中。并且到现在我们一路走下来似乎看到了许多熟悉的身影IMessenger.Stub，Stub.asInterface等等。这些不正是我们在AIDL中使用到的吗？于是我们猜想这个IMessenger应该是一个AIDL接口。现在就去找找这个IMessenger。这个IMessenger位于frameworks的base中， 完整路径为frameworks/base/core/java/android/os/。我们就看一下这个AIDL接口，12345678package android.os;import android.os.Message;/** @hide */oneway interface IMessenger &#123; void send(in Message msg);&#125; 在这个IMessenger接口中只有一个send方法。而在这里关键字oneway表示当服务用户请求相应功能的时后不需要等待应答就可以直接调用返回，这个关键字可以用于接口声明或者方法声明语句中，如果接口声明语句中使用了oneway关键字，则这个接口中声明的所有方法都采用了oneway方式。这回我们也就明白这个Messenger了，其实这个Messenger就是进一步对AIDL进行了一次封装。 在这里客户端通过服务端返回的Binder创建了Messenger对象。然后我们只需要创建一个Message对象，在这个Message对象中携带我们所需要传递给服务端的数据，这时候就可以在服务端中的handleMessage进行处理。若是我们需要服务端给我们返回数据，只需要在客户端创建一个Handler，并且使用这个Handler创建一个Messenger对象，然后将这个Messenger对象通过Message中的replyTo字段传递到服务端，在服务端获取到客户端的Messenger对象后，便可以通过这个Messenger发送给客户端，然后在客户端中的handlerMessage处理即可。 AIDL与Messenger的区别 我们可以发现在IPC通信中使用Messenger要比使用AIDL简单很多。因为在Messenger中是通过Handler来对AIDL进行的封装，也就是说Messenger是通过队列来调用服务的，而单纯的AIDL会同时像服务端发出请求，这时候我们就必须对多线程进行处理。 那么对于一个应用来说。它的Service不需要执行多线程我们应该去使用这个Messenger，返过来若是我们Service处理是多线程的我们就应该使用AIDL去定义接口。 总结 Messenger它是一种轻量级的IPC 方法，我们使用起来也是非常的简单。他是使用Handler对AIDL进行了一次封装，一次只能处理一个请求。并且Messenger在发送Message的时候不能使用他的obj字段，我们可以用bundle来代替。最后还有一点就是Messenger只是在客户端与服务端跨进程的传递数据，而不能够去访问服务端的方法。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(三)—Binder连接池]]></title>
    <url>%2F2016%2F02%2F24%2Fipc-03%2F</url>
    <content type="text"><![CDATA[前两篇说到AIDL的使用方法，但是当我们的项目很大时，很多模块都需要用到Service，我们总不能为每一个模块都创建一个Service吧，这样一来我们的应用就会显得很笨重。那么有没有一种解决方案叫我们只需要创建一个Service，然后去管理AIDL呢？在任玉刚的《Android开发艺术探索》中给出了一个解决方案，那就是Binder连接池。在这里我们看一下他是怎么实现的。 Binder连接池的实现 在前面说到AIDL的使用及原理的时候，我们可以看到在服务端只是创建了一个Binder然后返回给客户端使用而已。于是我们可以想到是不是我们可以只有一个Service,对于不同可客户端我们只是去返回一个不同的Binder即可，这样就避免了创建了大量的Service。在任玉刚的《Android开发艺术探索》给出了一个Binder连接池的概念，很巧妙的避免了Service的多次创建。这个Binder连接池类似于设计模式中的工厂方法模式。为每一个客户端创建他们所需要的Binder对象。那么下面我们看一下它是如何实现的。 首先我们创建一个名为BinderPool的AIDL接口。 123456789101112// IBinderPool.aidlpackage com.example.ljd_pc.binderpool;// Declare any non-default types here with import statementsinterface IBinderPool &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ IBinder queryBinder(int binderCode);&#125; 在这个AIDL接口中我们根据传入的binderId返回了一个IBinder接口对象。我们再创建两个AIDL接口作为功能显示。 创建名为ICalculate的AIDL接口用作计算算术的加减法。12345678910111213// ICalculate.aidlpackage com.example.ljd_pc.binderpool;// Declare any non-default types here with import statementsinterface ICalculate &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ int add(int first, int second); int sub(int first, int second);&#125; 再创建一个名为IRect作为求矩形的面积与周长。12345678910111213// IRect.aidlpackage com.example.ljd_pc.binderpool;// Declare any non-default types here with import statementsinterface IRect &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ int area(int length,int width); int perimeter(int length,int width);&#125; 然后我们继承系统自动生成的Stub类去实现接口中的方法。下面是ICalculate实现。123456789101112131415package com.example.ljd_pc.binderpool;import android.os.RemoteException;public class ICalculateImpl extends ICalculate.Stub &#123; @Override public int add(int first, int second) throws RemoteException &#123; return first + second; &#125; @Override public int sub(int first, int second) throws RemoteException &#123; return first - second; &#125;&#125; IRect的实现。12345678910111213141516package com.example.ljd_pc.binderpool;import android.os.RemoteException;public class IRectImpl extends IRect.Stub &#123; @Override public int area(int length, int width) throws RemoteException &#123; return length * width; &#125; @Override public int perimeter(int length, int width) throws RemoteException &#123; return length*2 + width*2; &#125;&#125; 然后我们在看一下这个BinderPool是怎么实现的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.example.ljd_pc.binderpool;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import java.util.concurrent.CountDownLatch;public class BinderPool &#123; public static final int BINDER_NONE = -1; public static final int BINDER_CALCULATE = 0; public static final int BINDER_RECT = 1; private Context mContext; private static IBinderPool mBinderPool; private static BinderPool mInstance; private CountDownLatch mCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; public static BinderPool getInstance(Context context)&#123; if (mBinderPool == null)&#123; synchronized (BinderPool.class)&#123; if (mBinderPool == null)&#123; mInstance = new BinderPool(context); &#125; &#125; &#125; return mInstance; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient,0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mCountDownLatch.countDown(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient,0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; private synchronized void connectBinderPoolService()&#123; mCountDownLatch = new CountDownLatch(1); Intent service = new Intent("com.ljd.binder.BINDER_POOL_SERVICE"); mContext.bindService(service,mBinderPoolConnection,Context.BIND_AUTO_CREATE); try &#123; mCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public IBinder queryBinder(int binderCode)&#123; IBinder binder = null; if (mBinderPool != null)&#123; try &#123; binder = mBinderPool.queryBinder(binderCode); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; return binder; &#125; public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl()&#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode)&#123; case BINDER_CALCULATE: binder = new ICalculateImpl(); break; case BINDER_RECT: binder = new IRectImpl(); break; default: break; &#125; return binder; &#125; &#125;&#125; 在这个BinderPool中我们首先为这两个AIDL接口创建一个id。又创建了一个BinderPoolImpl的内部类，这个BinderPoolImpl内部类根据传入的id返回相对应的Binder。在BinderPool中采用单实例模式，而在BinderPool的构造方法中绑定了Service。对客户端提供了一个queryBinder方法来获取所需要的Binder对象。而对于服务端只需要new BinderPool.BinderPoolImpl()即可。从这我们就可以看出这个BinderPool也就是对客户端和服务端的代码进行了一次封装。然后进行对不同的客户端在Service中返回不同的Binder。由于AIDL支持多线程并发访问的，所以在绑定Service中做了采用synchronized和CountDownLatch做了线程同步处理。 由于BinderPool对代码进行了封装，所以服务端的代码就很简单了，只需要new BinderPool.BinderPoolImpl()返回即可。 123456789101112131415161718package com.example.ljd_pc.binderpool;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;public class BinderPoolService extends Service &#123; private Binder mBinderPool = new BinderPool.BinderPoolImpl(); public BinderPoolService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinderPool; &#125;&#125; 下面在看一下客户端代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.example.ljd_pc.binderpool;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.Toast;import butterknife.Bind;import butterknife.ButterKnife;public class BinderPoolActivity extends AppCompatActivity implements View.OnClickListener&#123; @Bind(R.id.add_btn) Button addBtn; @Bind(R.id.sub_btn) Button subBtn; @Bind(R.id.area_btn) Button areaBtn; @Bind(R.id.per_btn) Button perBtn; private final String TAG = "BinderPoolActivity"; private BinderPool mBinderPool; private ICalculate mCalculate; private IRect mRect; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; addBtn.setOnClickListener(BinderPoolActivity.this); subBtn.setOnClickListener(BinderPoolActivity.this); areaBtn.setOnClickListener(BinderPoolActivity.this); perBtn.setOnClickListener(BinderPoolActivity.this); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_binder_pool); ButterKnife.bind(this); getBinderPool(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ButterKnife.unbind(this); &#125; private void getBinderPool()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; mBinderPool = BinderPool.getInstance(BinderPoolActivity.this); mHandler.obtainMessage().sendToTarget(); &#125; &#125;).start(); &#125; @Override public void onClick(final View v) &#123; try &#123; switch (v.getId())&#123; case R.id.add_btn: mCalculate = ICalculateImpl.asInterface(mBinderPool.queryBinder(BinderPool.BINDER_CALCULATE)); Log.e(TAG,String.valueOf(mCalculate.add(3,2))); Toast.makeText(BinderPoolActivity.this,String.valueOf(mCalculate.add(3,2)),Toast.LENGTH_SHORT).show(); break; case R.id.sub_btn: mCalculate = ICalculateImpl.asInterface(mBinderPool.queryBinder(BinderPool.BINDER_CALCULATE)); Log.e(TAG,String.valueOf(mCalculate.sub(3,2))); Toast.makeText(BinderPoolActivity.this,String.valueOf(mCalculate.sub(3,2)),Toast.LENGTH_SHORT).show(); break; case R.id.area_btn: mRect = IRectImpl.asInterface(mBinderPool.queryBinder(BinderPool.BINDER_RECT)); Log.e(TAG,String.valueOf(mRect.area(3,2))); Toast.makeText(BinderPoolActivity.this,String.valueOf(mRect.area(3,2)),Toast.LENGTH_SHORT).show(); break; case R.id.per_btn: mRect = IRectImpl.asInterface(mBinderPool.queryBinder(BinderPool.BINDER_RECT)); Log.e(TAG,String.valueOf(mRect.perimeter(3,2))); Toast.makeText(BinderPoolActivity.this,String.valueOf(mRect.perimeter(3,2)),Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在这里我们要注意使用CountDownLatch对bindService这一异步操作变为同步，所以在获取BinderPool对象时不能再主线程中操作。并且在这一步中作者建议我们在Application中去初始化这个BinderPool对象。 布局代码如下。1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" android:orientation="vertical"&gt; &lt;Button android:id="@+id/add_btn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/add" /&gt; &lt;Button android:id="@+id/sub_btn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/sub"/&gt; &lt;Button android:id="@+id/area_btn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/area"/&gt; &lt;Button android:id="@+id/per_btn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/per"/&gt;&lt;/LinearLayout&gt; 演示 总结 这样以来我们就能在我们的应用中只建立一个Service就足够了。当我们添加一个AIDL接口的时候只需要在BinderPool中添加一个id，然后根据这个id，在BinderPoolImpl中创建一个对应的Binder对象即可。这样就很大程度上简化了我们的工作。但是我认为这样做依然存在一个问题。那就是当我们创建一个BinderPool对象时，我们的客户端就已经绑定了Service，之后只是根据不同的id获取不同的Binder。也就是说从我们绑定Service那时起，这个Service进程就一直在后台运行，即使这个应用已经不再前台使用。除非系统将这个Service进程杀死。但是总的来说，在我们的应用中若是用到了很多的AIDL，那么使用Binder连接池还是很好的选择。到这里有关IPC的AIDL内容就说完了。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(二)—AIDL实现原理简析]]></title>
    <url>%2F2016%2F02%2F20%2Fipc-02%2F</url>
    <content type="text"><![CDATA[上篇说到AIDL的使用方法，我们不能仅仅只是满足对AIDL的使用，那么对于AIDL到底是如何实现的呢？为什么我们只是创建一个AIDL文件，系统就会为我们自动生成一个Java文件，那么这个Java文件里面到底包含了哪些内容呢？我们今天就来研究一下。 AIDL实现原理 在这里我们首先看一下AIDL是怎么实现的。当我们创建一个Service和一个AIDL接口的时候，然后创建一个Binder对象并在Service中的onBind方法中去返回这个Binder对象到客户端，客户端得到这个对象后就可以绑定服务端的Service，并且与服务端建立连接后就可以访问服务端的方法了。所以在整个AIDL的实现过程中这个Binder是关键。那么这个Binder究竟是什么呢？在这里简要说明一下。 Binder是一种进程间的通信方式。Binder在Linux 内核中是一个驱动程序(/dev/binder)，ServiceManager通过这个Binder驱动连接各种Manager(AvtivityManager,WindowManager等)。在Android的应用层中通过Binder实现Android的RPC（Remote Procedure Call 远程进程调用）过程。 以上篇文章中的加法运算为例分析来一下Binder在应用层的实现机制，我们可以看到在服务端通过new ICalculate.Stub()来创建一个Binder对象，那么我们找到ICalculate的Java代码。 也就是系统根据我们的AIDL接口自动生成Java文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* * This file is auto-generated. DO NOT MODIFY. * Original file: G:\\Android\\androidstudioProject\\aidl\\AIDLClient\\app\\src\\main\\aidl\\com\\ljd\\aidl\\ICalculate.aidl */package com.ljd.aidl;// Declare any non-default types here with import statementspublic interface ICalculate extends android.os.IInterface &#123;/** Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.ljd.aidl.ICalculate &#123; private static final java.lang.String DESCRIPTOR = "com.ljd.aidl.ICalculate"; /** Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.ljd.aidl.ICalculate interface, * generating a proxy if needed. */ public static com.ljd.aidl.ICalculate asInterface(android.os.IBinder obj) &#123; if ((obj==null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.ljd.aidl.ICalculate))) &#123; return ((com.ljd.aidl.ICalculate)iin); &#125; return new com.ljd.aidl.ICalculate.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.ljd.aidl.ICalculate &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public int add(int first, int second) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(first); _data.writeInt(second); mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public int add(int first, int second) throws android.os.RemoteException;&#125; 其实这段代码很有规律可寻的。能够看出ICalculate 是一个继承IInterface的接口，IInterface中只声明了一个asBinder接口，用于返回Binder对象。所有在Binder传输的接口都必须继承这个IInterface接口。在ICalculate的java接口中再次声明了AIDL中的方法并且创建了一个继承Binder的内部抽象类Stub。也就是说这个Stub也就是一个Binder。 在服务端我们通过new ICalculate.Stub()来创建一个Binder对象，我们来看一下这个Stub里面的内容。Stub内定义了一个DESCRIPTOR作为Binder的唯一标识，定义了一个TRANSACTION_add 作为接口方法的id。下面看一下asInterface()方法。 12345678910public static com.ljd.binder.ICalculate asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.ljd.binder.ICalculate))) &#123; return ((com.ljd.binder.ICalculate) iin); &#125; return new com.ljd.binder.ICalculate.Stub.Proxy(obj);&#125; 这个方法是在客户端被调用，运行在主线程当中，是将服务端返回来的Binder对象转为客户端所需要的接口对象。通过Binder对象的queryLocalInterface方法去查找客户端进程中是否存在所需要的接口对象。存在的话就直接返回这个接口对象。也就是说这时候客户端和服务端在同一个进程内。若是不存在，就创建一个Proxy对象。Proxy是Stub的一个内部代理类。我们看一下Proxy里面到底做了什么。 1234567891011121314151617181920212223242526272829303132333435private static class Proxy implements com.ljd.aidl.ICalculate &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public int add(int first, int second) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(first); _data.writeInt(second); mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125;&#125; 在跨进程通信中，由于是在asInterface方法中创建了一个Proxy对象，所以，Proxy也是运行在客户端的主线程中。在Proxy类中实现了ICalculate接口，定义了IBinder接口对象。通过实现asBinder接口返回这个IBinder接口对象。而对于我们自己定义的add接口方法中创建两个Parcel对象_data和_reply （Parcel可以说是一个存放读取数据的容器，在Parcel内部包装了可序列化的数据，并且可以在Binder中自由的传输)。我们可以很清晰看出_data对象写入了我们传入的参数，而_reply 则是用来存放方法的返回值。紧接着调用了Binder的transact方法。在transact方法方法中将方法id,_data,_reply作为参数传入进去。下面看一下Binder的transact方法。 123456789101112public final boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; if (false) Log.v("Binder", "Transact: " + code + " to " + this); if (data != null) &#123; data.setDataPosition(0); &#125; boolean r = onTransact(code, data, reply, flags); if (reply != null) &#123; reply.setDataPosition(0); &#125; return r;&#125; 我们可以很明显的看到在transact方法中调用了onTransact方法并返回了一个boolean类型。当返回false的时候客户端请求就会失败。在Stub中我们重写onTransact方法。下面我们看一下onTransact方法。 1234567891011121314151617181920public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 在onTransact方法中我们会根据code来判断所需要执行的方法，通过data取出所需要的参数，然后执行该方法，若是有返回值则将将返回值写入reply中。在这里Parcel对象data和reply读写顺序要严格保持一致。 可以看出Binder运行的整个流程也就是：当客户端绑定服务端发起远程请求，客户端进程处于休眠，当前线程处于挂起状态。然后服务端开始执行，执行完毕后将结果返回给客户端。然后客户端继续执行。 这也说明了当远程方法是一个很耗时的操作时，我们不应该在主线程中发起请求。而服务端的Binder方法在Binder线程池中运行，所以Binder不论是否耗时都不应该重新为他在开启一个线程。 到这里AIDL中Binder的工作机制已经分析完了。现在我们可以发现完全不用AIDL文件也能够实现跨进程的方法调用。那么我们自己来写一个Binder去实现服务端与客户端的跨进程的方法调用。 自定义Binder的实现实现过程 在这里我们创建一个继承IInterfaceJava接口，在接口里面我们去声明算术的加减法运算。12345678910111213package com.ljd.binder.custombinder;import android.os.IInterface;public interface ICalculate extends IInterface &#123; static final int TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_sub = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); public int add(int first, int second) throws android.os.RemoteException; public int sub(int first, int second) throws android.os.RemoteException;&#125; 然后我们再去实现这个接口。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.ljd.binder.custombinder;import android.os.Binder;import android.os.IBinder;import android.os.IInterface;import android.os.Parcel;import android.os.RemoteException;import android.util.Log;/** * Created by ljd-PC on 2016/2/21. */public class Calculate extends Binder implements ICalculate&#123; private final String TAG = "Calculate"; private static final String DESCRIPTOR = "com.ljd.binder.ICalculate"; @Override public void attachInterface(IInterface owner, String descriptor) &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static ICalculate asInterface(IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof ICalculate))) &#123; return (ICalculate) iin; &#125; return new Proxy(obj); &#125; @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_add: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.add(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_sub: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.sub(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; @Override public int add(int first, int second) throws RemoteException &#123; Log.e(TAG,String.valueOf(first+second)); return first + second; &#125; @Override public int sub(int first, int second) throws RemoteException &#123; return first - second; &#125; @Override public IBinder asBinder() &#123; return null; &#125; private static class Proxy implements ICalculate &#123; private IBinder mRemote; Proxy(IBinder remote) &#123; mRemote = remote; &#125; @Override public IBinder asBinder() &#123; return mRemote; &#125; public String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int add(int first, int second) throws RemoteException &#123; Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(first); _data.writeInt(second); mRemote.transact(TRANSACTION_add, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public int sub(int first, int second) throws RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(first); _data.writeInt(second); mRemote.transact(TRANSACTION_sub, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125;&#125; 在这里创建一个Service。 123456789101112131415161718package com.ljd.binder.custombinder;import android.app.Service;import android.content.Intent;import android.os.IBinder;public class CalculateService extends Service &#123; private Calculate mCalculate; public CalculateService() &#123; mCalculate = new Calculate(); &#125; @Override public IBinder onBind(Intent intent) &#123; return mCalculate; &#125;&#125; 在上篇文章中说过我们可以通过android:process 属性为服务端开启一个进程。 12345678&lt;service android:name=".custombinder.CalculateService" android:process=":remote"&gt; &lt;intent-filter&gt; &lt;action android:name="com.ljd.binder.CUSTOM_BINDER"&gt;&lt;/action&gt; &lt;category android:name="android.intent.category.DEFAULT"&gt;&lt;/category&gt; &lt;/intent-filter&gt;&lt;/service&gt; 其中:remote是一种简写法，全称为com.ljd.binder.custombinder:remote。以:开头的进程是属于当前应用的私有进程，其他应用的组件不能和他运行在同一个进程中。 下面是客户端代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.ljd.binder.custombinder;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Toast;import com.ljd.binder.*;import butterknife.ButterKnife;import butterknife.OnClick;public class CustomBinderActivity extends AppCompatActivity &#123; private final String TAG = "CustomBinderActivity"; private ICalculate mCalculate; private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if(mCalculate != null)&#123; mCalculate.asBinder().unlinkToDeath(mDeathRecipient,0); mCalculate = null; bindService(); &#125; &#125; &#125;; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.e(TAG,"Bind Success"); mCalculate = Calculate.asInterface(service); try &#123; mCalculate.asBinder().linkToDeath(mDeathRecipient,0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mCalculate = null; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_custom_binder); ButterKnife.bind(this); bindService(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ButterKnife.unbind(this); unbindService(mConnection); &#125; @OnClick(&#123;R.id.custom_add_btn,R.id.custom_sub_btn&#125;) public void onClickButton(View v)&#123; if (mCalculate == null)&#123; return; &#125; switch (v.getId())&#123; case R.id.custom_add_btn: try &#123; Toast.makeText(this,String.valueOf(mCalculate.add(6,2)),Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; case R.id.custom_sub_btn: try &#123; Toast.makeText(this,String.valueOf(mCalculate.sub(6,2)),Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: break; &#125; &#125; private void bindService()&#123; Intent intent = new Intent("com.ljd.binder.CUSTOM_BINDER"); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); &#125;&#125; 效果演示 总结 我们现在自己已经实现了跨进程间的调用。而且我们构建的这个Binder几乎和系统生成的一模一样。所以AIDL就是对Binder进行了一次封装，并且能够支持多线程并发访问。通过AIDL的使用能够大大简化了我们开发过程，节约了我们的开发时间。 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的IPC机制(一)—AIDL的使用]]></title>
    <url>%2F2016%2F02%2F20%2Fipc-01%2F</url>
    <content type="text"><![CDATA[IPC(interprocess communication)是指进程间通信，也就是在两个进程间进行数据交互。不同的操作系统都有他们自己的一套IPC机制。例如在Linux操作系统中可以通过管道、信号量、消息队列、内存共享、套接字等进行进程间通信。那么在Android系统中我们可以通过Binder来进行进程间的通信。当然除了Binder我们还可以使用Socket来进行进程间的通信。 既然需要进程通信，那么就必须有多个进程。当然，在两个应用交互中必然出现多进程的情况。若是在一个应用中呢？我们可以通过给四大组件在AndroidMenifest中为他们指定android:process属性来实现不同的组件在不同进程中运行。下面就来介绍一下Android中进程间通信的实现方式。 AIDL简介 AIDL是 Android Interface Definition Language的缩写。AIDL 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行 IPC的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。 AIDL是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。 AIDL用法 首先我们创建一个AIDL文件，在AndroidStudio中当我们创建一个AIDL文件时会自动为我们创件一个AILD文件夹，用于存放AIDL文件。创建完之后重新rebuild会自动生成aidl实现类。 在下面的例子当中，我们将Service单独作为一个应用在系统中运行，在另一个用于访问Service的client也单独作为一个应用运行在系统中。这样保证了两个程序分别运行在两个进程中。并且使用了butterknife进行控件绑定。 AIDL简单用法演示 在Service中我们对客户端传来的两个整数做了一次加法运算并返回到客户端中。 AIDL代码123456789101112// ICalculate.aidlpackage com.ljd.aidl;// Declare any non-default types here with import statementsinterface ICalculate &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ int add(int first, int second);&#125; 服务端代码123456789101112131415161718192021222324252627package com.ljd.aidl.service;import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.RemoteException;import com.ljd.aidl.ICalculate;public class CalculateService extends Service &#123; public CalculateService() &#123; &#125; private Binder mBinder = new ICalculate.Stub()&#123; @Override public int add(int first, int second) throws RemoteException &#123; return first + second; &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.ljd.aidl.activity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.widget.Toast;import com.ljd.aidl.ICalculate;import com.ljd.aidl.client.R;import butterknife.ButterKnife;import butterknife.OnClick;public class Demo1Activity extends AppCompatActivity &#123; private final String TAG = "DEMO1"; //是否已经绑定service private boolean mIsBindService; private ICalculate mCalculate; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG,"bind success"); Toast.makeText(Demo1Activity.this,"bind service success",Toast.LENGTH_SHORT).show(); mCalculate = ICalculate.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; //重新绑定Service防止系统将服务进程杀死而产生的调用错误。 bindService(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo1); ButterKnife.bind(this); mIsBindService = false; &#125; @Override protected void onDestroy() &#123; unbindService(); ButterKnife.unbind(this); super.onDestroy(); &#125; @OnClick(&#123; R.id.bind_demo1_btn,R.id.unbind_demo1_btn,R.id.calculate_btn&#125;) public void onClickButton(View v) &#123; switch (v.getId())&#123; case R.id.bind_demo1_btn: bindService(); break; case R.id.unbind_demo1_btn: Toast.makeText(this,"unbind service success",Toast.LENGTH_SHORT).show(); unbindService(); break; case R.id.calculate_btn: if (mIsBindService &amp;&amp; mCalculate != null )&#123; try &#123; int result = mCalculate.add(2,4); Log.d(TAG,String.valueOf(result)); Toast.makeText(this,String.valueOf(result),Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; Toast.makeText(this,"not bind service",Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; private void bindService()&#123; Intent intent = new Intent(); intent.setAction("com.ljd.aidl.action.CALCULATE_SERVICE"); bindService(intent,mConnection, Context.BIND_AUTO_CREATE); mIsBindService = true; &#125; private void unbindService()&#123; if(mIsBindService)&#123; mIsBindService = false; unbindService(mConnection); &#125; &#125;&#125; AIDL高级用法 对于上面的例子，在AIDL接口中只是使用了一些Java的基本类型，对于AIDL文件并不是所有的类型都是可用的，那么在AIDL中究竟有哪些类型可以使用呢？ AIDL语法规则默认情况下AIDL支持以下数据类型： 所有Java的基本数据类型（例如： int, long,double, char, boolean等） String和CharSequence List：AIDL实际接收到的是ArrayList，并且List里面所有元素都必须被AIDL支持 Map: AIDL实际接收到的是HashMap，并且Map里面所有元素都必须被AIDL支持 如果不是上面所述类型，我们必须要显示import进来，即使他们在同一个包中。当我们使用自定义的对象时必须实现Parcelable接口，Parcelable为对象序列化接口，效率比实现Serializable接口高。并且新建一个与该类同名的AIDL文件，声明他为Parcelable类型。 我们定义AIDL接口还需要注意以下几点： 方法可以有多个或没有参数，可以有返回值也可以为void 在参数中，除了基本类型以外，我们必须为参数标上方向in, out, 或者 inout 在AIDL文件中只支持方法，不支持静态常量演示 在计算机商店中需要采购笔记本进行销售，在服务端中我们添加两台笔记本，在客户端中我们为商店加购一台dell笔记本。 实体类代码 我们首先构建一个计算机实体类，包含笔记本的id，品牌，型号，并且实现Parcelable接口，在AndroidStudio中会为我们自动构造代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.ljd.aidl.entity;import android.os.Parcel;import android.os.Parcelable;public class ComputerEntity implements Parcelable&#123; public int computerId; //id public String brand; //品牌 public String model; //型号 public ComputerEntity(int computerId, String brand, String model) &#123; this.brand = brand; this.computerId = computerId; this.model = model; &#125; protected ComputerEntity(Parcel in) &#123; computerId = in.readInt(); brand = in.readString(); model = in.readString(); &#125; public static final Creator&lt;ComputerEntity&gt; CREATOR = new Creator&lt;ComputerEntity&gt;() &#123; @Override public ComputerEntity createFromParcel(Parcel in) &#123; return new ComputerEntity(in); &#125; @Override public ComputerEntity[] newArray(int size) &#123; return new ComputerEntity[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(computerId); dest.writeString(brand); dest.writeString(model); &#125;&#125; AIDL代码 在AIDL中对实体类进行声明，包名和文件名必须与实体类一致。在AndroidStudio中新建一个与实体类同名的AIDL文件会报错，需要先用一个其它名字，然后修改与实体类名一致即可。 12345package com.ljd.aidl.entity;//包名必须和对用实体类的包名一致// Declare any non-default types here with import statementsparcelable ComputerEntity; 添加两个接口分别为添加一台笔记本和获取全部笔记本，在该文件中使用到了ComputerEntity类，显示的import进来。 12345678910111213package com.ljd.aidl;import com.ljd.aidl.entity.ComputerEntity;// Declare any non-default types here with import statementsinterface IComputerManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void addComputer(in ComputerEntity computer); List&lt;ComputerEntity&gt; getComputerList();&#125; 服务端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ljd.aidl.service;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.RemoteException;import com.ljd.aidl.IComputerManager;import com.ljd.aidl.entity.ComputerEntity;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;public class ComputerService extends Service &#123; private CopyOnWriteArrayList&lt;ComputerEntity&gt; mComputerList = new CopyOnWriteArrayList&lt;&gt;(); public ComputerService() &#123; &#125; private final IComputerManager.Stub mBinder = new IComputerManager.Stub() &#123; @Override public void addComputer(ComputerEntity computer) throws RemoteException &#123; mComputerList.add(computer); &#125; @Override public List&lt;ComputerEntity&gt; getComputerList() throws RemoteException &#123; return mComputerList; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mComputerList.add(new ComputerEntity(0,"apple","macbookpro")); mComputerList.add(new ComputerEntity(1,"microsoft","surfacebook")); mComputerList.add(new ComputerEntity(2,"dell","XPS13")); &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 注意：在该类中使用了CopyOnWriteArrayList，CopyOnWriteArrayList能够自动进行线程同步。可是在AIDL中接收和返回的只能是ArrayList，其实AIDL支持的是抽象的List，在Binder中会按照List访问数据并最终形成一个ArrayList，所以在AIDL中返回的还是一个ArrayList。 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package com.ljd.aidl.activity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import com.ljd.aidl.IComputerManager;import com.ljd.aidl.client.R;import com.ljd.aidl.entity.ComputerEntity;import java.util.List;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;public class Demo2Activity extends AppCompatActivity&#123; @Bind(R.id.show_linear) LinearLayout mShowLinear; private boolean mIsBindService; private IComputerManager mRemoteComputerManager; private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if(mRemoteComputerManager != null)&#123; mRemoteComputerManager.asBinder().unlinkToDeath(mDeathRecipient,0); mRemoteComputerManager = null; bindService(); &#125; &#125; &#125;; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mIsBindService = true; Toast.makeText(Demo2Activity.this,"bind service success",Toast.LENGTH_SHORT).show(); mRemoteComputerManager = IComputerManager.Stub.asInterface(service); try &#123; mRemoteComputerManager.asBinder().linkToDeath(mDeathRecipient,0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mRemoteComputerManager = null; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo2); ButterKnife.bind(this); mIsBindService = false; &#125; @Override protected void onDestroy() &#123; unbindService(); ButterKnife.unbind(this); super.onDestroy(); &#125; @OnClick(&#123;R.id.bind_demo2_btn,R.id.unbind_demo2_btn,R.id.test_demo2_btn,R.id.clear_demo2_btn&#125;) public void onClickButton(View v) &#123; switch (v.getId())&#123; case R.id.bind_demo2_btn: bindService(); break; case R.id.unbind_demo2_btn: Toast.makeText(this,"unbind service success",Toast.LENGTH_SHORT).show(); unbindService(); break; case R.id.test_demo2_btn: if (!mIsBindService || mRemoteComputerManager == null)&#123; Toast.makeText(this,"not bind service",Toast.LENGTH_SHORT).show(); return; &#125; try &#123; List&lt;ComputerEntity&gt; computerList = mRemoteComputerManager.getComputerList(); for (int i =0;i&lt;computerList.size();i++)&#123; String str = "computerId:" + String.valueOf(computerList.get(i).computerId) + " brand:" + computerList.get(i).brand + " model:" + computerList.get(i).model ; TextView textView = new TextView(this); textView.setText(str); mShowLinear.addView(textView); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; case R.id.clear_demo2_btn: mShowLinear.removeAllViews(); break; &#125; &#125; private void bindService()&#123; Intent intent = new Intent(); intent.setAction("com.ljd.aidl.action.COMPUTER_SERVICE"); mIsBindService = bindService(intent,mConnection, Context.BIND_AUTO_CREATE); &#125; private void unbindService()&#123; if(!mIsBindService)&#123; return; &#125; mIsBindService = false; unbindService(mConnection); &#125;&#125; 由于Binder是有可能会意外死亡的，也就是Service所在进程被系统杀死，这时候我们调用Service的方法就会失败。在第一个例子中我们通过onServiceDisconnected方法中重新绑定服务。在这个例子中我们采用了另外一种方法，由于在Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath可以给Binder设置一个死亡代理，Binder死亡时回调binderDied方法，在binderDied方法中我们重新绑定服务即可。 AIDL用法拓展 当我们需要一种笔记本的时候，由于商店缺货，这时候我们会给卖家说一声，我所需要的这款笔记本到货后通知我。也就成了所谓的观察者模式。 在Android系统中为我们提供了一个RemoteCallbackList,RemoteCallbackList是系统专门用来删除跨进程的listener接口，并且在RemoteCallbackList中自动实现了线程同步功能，下面看一下它的用法。 演示 客户端注册服务以后，服务端每隔三秒会添加一台笔记本，并通知给客户端显示。 AIDL代码 到货后的AIDL监听接口 123456789101112package com.ljd.aidl;import com.ljd.aidl.entity.ComputerEntity;// Declare any non-default types here with import statementsinterface IOnComputerArrivedListener &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void onComputerArrived(in ComputerEntity computer);&#125; 在IComputerManager接口中添加两个方法。显示importIOnComputerArrivedListener ,即使在同一个包下面。 1234567891011121314151617// IComputerManagerObserver.aidlpackage com.ljd.aidl;import com.ljd.aidl.entity.ComputerEntity;import com.ljd.aidl.IOnComputerArrivedListener;// Declare any non-default types here with import statementsinterface IComputerManagerObserver &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void addComputer(in ComputerEntity computer); List&lt;ComputerEntity&gt; getComputerList(); void registerUser(IOnComputerArrivedListener listener); void unRegisterUser(IOnComputerArrivedListener listener);&#125; 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import android.app.Service;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.RemoteCallbackList;import android.os.RemoteException;import com.ljd.aidl.IComputerManagerObserver;import com.ljd.aidl.IOnComputerArrivedListener;import com.ljd.aidl.entity.ComputerEntity;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;import java.util.concurrent.atomic.AtomicBoolean;public class ComputerObserverService extends Service&#123; public ComputerObserverService() &#123; &#125; private CopyOnWriteArrayList&lt;ComputerEntity&gt; mComputerList = new CopyOnWriteArrayList&lt;&gt;(); private RemoteCallbackList&lt;IOnComputerArrivedListener&gt; mComputerArrivedListenerList = new RemoteCallbackList&lt;&gt;(); private AtomicBoolean mIsServiceDestroy = new AtomicBoolean(false); private Binder mBinder = new IComputerManagerObserver.Stub()&#123; @Override public void addComputer(ComputerEntity computer) throws RemoteException &#123; mComputerList.add(computer); &#125; @Override public List&lt;ComputerEntity&gt; getComputerList() throws RemoteException &#123; return mComputerList; &#125; @Override public void registerUser(IOnComputerArrivedListener listener) throws RemoteException &#123; mComputerArrivedListenerList.register(listener); &#125; @Override public void unRegisterUser(IOnComputerArrivedListener listener) throws RemoteException &#123; mComputerArrivedListenerList.unregister(listener); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mComputerList.add(new ComputerEntity(0,"apple","macbookpro")); mComputerList.add(new ComputerEntity(1,"microsoft","surfacebook")); mComputerList.add(new ComputerEntity(2,"dell","XPS13")); new Thread(new Runnable() &#123; @Override public void run() &#123; while (!mIsServiceDestroy.get())&#123; try &#123; Thread.currentThread().sleep(3000); ComputerEntity computer = new ComputerEntity(mComputerList.size(),"******","******"); mComputerList.add(computer); final int COUNT = mComputerArrivedListenerList.beginBroadcast(); //通知所有注册过的用户 for (int i=0;i&lt;COUNT;i++)&#123; IOnComputerArrivedListener listener = mComputerArrivedListenerList.getBroadcastItem(i); if (listener != null)&#123; listener.onComputerArrived(computer); &#125; &#125; mComputerArrivedListenerList.finishBroadcast(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; @Override public void onDestroy() &#123; super.onDestroy(); mIsServiceDestroy.set(true); &#125;&#125; 注意：RemoteCallbackList并不是一个List，所以我们不能像操作List一样操作RemoteCallbackList。并且遍历RemoteCallbackList时，beginBroadcast和finishBroadcast是配对使用的。 客户端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.RemoteException;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import com.ljd.aidl.IComputerManagerObserver;import com.ljd.aidl.IOnComputerArrivedListener;import com.ljd.aidl.client.R;import com.ljd.aidl.entity.ComputerEntity;import java.util.List;import butterknife.Bind;import butterknife.ButterKnife;import butterknife.OnClick;public class Demo3Activity extends AppCompatActivity &#123; @Bind(R.id.show_demo3_linear) LinearLayout mShowLinear; private boolean mIsBindService; private static final int MESSAGE_COMPUTER_ARRIVED = 1; private IComputerManagerObserver mRemoteComputerManager; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case MESSAGE_COMPUTER_ARRIVED: ComputerEntity computer = (ComputerEntity)msg.obj; String str = "computerId:" + String.valueOf(computer.computerId) + " brand:" + computer.brand + " model:" + computer.model ; TextView textView = new TextView(Demo3Activity.this); textView.setText(str); mShowLinear.addView(textView); break; default: super.handleMessage(msg); break; &#125; &#125; &#125;; private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if(mRemoteComputerManager != null)&#123; mRemoteComputerManager.asBinder().unlinkToDeath(mDeathRecipient,0); mRemoteComputerManager = null; bindService(); &#125; &#125; &#125;; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mIsBindService = true; Toast.makeText(Demo3Activity.this,"bind service success",Toast.LENGTH_SHORT).show(); mRemoteComputerManager = IComputerManagerObserver.Stub.asInterface(service); try &#123; mRemoteComputerManager.asBinder().linkToDeath(mDeathRecipient,0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mRemoteComputerManager = null; &#125; &#125;; private IOnComputerArrivedListener mOnComputerArrivedListener = new IOnComputerArrivedListener.Stub()&#123; @Override public void onComputerArrived(ComputerEntity computer) throws RemoteException &#123; mHandler.obtainMessage(MESSAGE_COMPUTER_ARRIVED,computer).sendToTarget(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_demo3); ButterKnife.bind(this); mIsBindService = false; &#125; @Override protected void onDestroy() &#123; unbindService(); ButterKnife.unbind(this); super.onDestroy(); &#125; @OnClick(&#123;R.id.bind_demo3_btn,R.id.unbind_demo3_btn,R.id.test_demo3_btn,R.id.clear_demo3_btn&#125;) public void onClickButton(View v)&#123; switch (v.getId())&#123; case R.id.bind_demo3_btn: bindService(); break; case R.id.unbind_demo3_btn: Toast.makeText(this,"unbind service success",Toast.LENGTH_SHORT).show(); unbindService(); break; case R.id.test_demo3_btn: if (!mIsBindService || mRemoteComputerManager == null)&#123; Toast.makeText(this,"not bind service",Toast.LENGTH_SHORT).show(); return; &#125; try &#123; ComputerEntity computer = new ComputerEntity(3,"hp","envy13"); mRemoteComputerManager.addComputer(computer); List&lt;ComputerEntity&gt; computerList = mRemoteComputerManager.getComputerList(); for (int i =0;i&lt;computerList.size();i++)&#123; String str = "computerId:" + String.valueOf(computerList.get(i).computerId) + " brand:" + computerList.get(i).brand + " model:" + computerList.get(i).model ; TextView textView = new TextView(this); textView.setText(str); mShowLinear.addView(textView); &#125; mRemoteComputerManager.registerUser(mOnComputerArrivedListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; case R.id.clear_demo3_btn: mShowLinear.removeAllViews(); break; &#125; &#125; private void bindService()&#123; Intent intent = new Intent(); intent.setAction("com.ljd.aidl.action.COMPUTER_OBSERVER_SERVICE"); mIsBindService = bindService(intent,mConnection, Context.BIND_AUTO_CREATE); &#125; private void unbindService()&#123; if(!mIsBindService)&#123; return; &#125; if (mRemoteComputerManager != null &amp;&amp; mRemoteComputerManager.asBinder().isBinderAlive())&#123; try &#123; mRemoteComputerManager.unRegisterUser(mOnComputerArrivedListener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(mConnection); mIsBindService = false; &#125;&#125; 源码下载]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ipc</tag>
      </tags>
  </entry>
</search>
